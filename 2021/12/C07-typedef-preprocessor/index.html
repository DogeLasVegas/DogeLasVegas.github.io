

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/-221011ca0d9ca71f.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="DogeLasVegas">
  <meta name="keywords" content="">
  
  <title>C07-typedef-preprocessor - 性感咸鱼，在线翻身</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/hybrid.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>道格拉斯维加斯</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-brush"></i>
                养馬場
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/collect/index.html">
                    <i class="iconfont icon-pen"></i>
                    撑了
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/collect/other">
                    <i class="iconfont icon-pen"></i>
                    没饱
                  </a>
                
              </div>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://cdn.jsdelivr.net/gh/dogelasvegas/blog-img/page-bgimg/loadingpic160.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="C07-typedef-preprocessor">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-10 23:35" pubdate>
        2021年12月10日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.1k 字
    </span>
  

  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C07-typedef-preprocessor</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：1 小时前
                
              </p>
            
            <div class="markdown-body">
              <h2 id="C-typedef"><a href="#C-typedef" class="headerlink" title="C typedef"></a>C typedef</h2><p>使用关键字 typedef 可以为类型起一个新的别名。typedef 的用法一般为：<br><code>typedef  oldName  newName;</code></p>
<p>oldName 是类型原来的名字，newName 是类型新的名字。例如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">typedef</span> int INTEGER;<br><span class="hljs-attribute">INTEGER</span> a, b;<br><span class="hljs-attribute">a</span> = <span class="hljs-number">1</span>;<br><span class="hljs-attribute">b</span> = <span class="hljs-number">2</span>;<br></code></pre></div></td></tr></table></figure>

<p>INTEGER a, b;等效于int a, b;。</p>
<p>typedef 是赋予现有类型一个新的名字，而不是创建新的类型，按照惯例，定义时会大写字母，并且尽量使用含义明确的标识符，以便提醒用户类型名称是一个象征性的缩写。</p>
<p>typedef 还可以给数组、指针、结构体等类型定义别名。先来看一个给数组类型定义别名的例子：</p>
<p><code>typedef char ARRAY20[20];</code></p>
<p>表示 ARRAY20 是类型char [20]的别名。它是一个长度为 20 的数组类型。接着可以用 ARRAY20 定义数组：<br><code>ARRAY20 a1, a2, s1, s2;</code></p>
<p>它等价于：<br><code>char a1[20], a2[20], s1[20], s2[20];</code></p>
<p>注意，数组也是有类型的。例如char a1[20];定义了一个数组 a1，它的类型就是 char [20]。</p>
<p>又如，为结构体类型定义别名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span>&#123;</span><br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">char</span> sex;<br>&#125; STU;<br></code></pre></div></td></tr></table></figure>

<p>STU 是 struct stu 的别名，可以用 STU 定义结构体变量：<br><code>STU body1,body2;</code></p>
<p>它等价于：<br><code>struct stu body1, body2;</code></p>
<p>再如，为指针类型定义别名：<br><code>typedef int (*PTR_TO_ARR)[4];</code></p>
<p>表示 PTR_TO_ARR 是类型int * [4]的别名，它是一个二维数组指针类型。接着可以使用 PTR_TO_ARR 定义二维数组指针：<br><code>PTR_TO_ARR p1, p2;</code></p>
<p>按照类似的写法，还可以为函数指针类型定义别名：<br><code>typedef int (*PTR_TO_FUNC)(int, int);</code><br><code>PTR_TO_FUNC pfunc;</code></p>
<h3 id="typedef-与-define-比较"><a href="#typedef-与-define-比较" class="headerlink" title="typedef 与 #define 比较"></a>typedef 与 #define 比较</h3><p>（1）typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如可以定义 1 为 ONE。<br>（2）typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的，只是字面上的替换。</p>
<p>（3）#define可以使用其他类型说明符对宏类型名进行扩展，但对 typedef 所定义的类型名却不能这样做。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INTERGE int;</span><br><span class="hljs-keyword">unsigned</span> INTERGE n;  <span class="hljs-comment">//没问题</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> INTERGE;<br><span class="hljs-keyword">unsigned</span> INTERGE n;  <span class="hljs-comment">//错误，不能在 INTERGE 前面添加 unsigned</span><br></code></pre></div></td></tr></table></figure>

<p>（4）在连续定义几个变量的时候，typedef 能够保证定义的所有变量均为同一类型，而 #define 则无法保证。例如：</p>
<figure class="highlight smali"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs smali"><span class="hljs-comment">#define PTR_INT int *</span><br>PTR_INT p1, p2;        //p1、p2 类型不相同，宏展开后变为int *p1, p2;<br>typedef<span class="hljs-built_in"> int </span>* PTR_INT<br>PTR_INT p1, p2;        //p1、p2 类型相同，它们都是指向<span class="hljs-built_in"> int </span>类型的指针。<br></code></pre></div></td></tr></table></figure>

<p>经过宏替换以后，第二行变为：<br><code>int *p1, p2;</code></p>
<p>这使得 p1、p2 成为不同的类型：p1 是指向 int 类型的指针，p2 是 int 类型。</p>
<p>相反，在下面的代码中：</p>
<figure class="highlight smali"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs smali">typedef<span class="hljs-built_in"> int </span>* PTR_INT<br>PTR_INT p1, p2;<br></code></pre></div></td></tr></table></figure>

<p>p1、p2 类型相同，它们都是指向 int 类型的指针。</p>
<p>typedef 还有一个作用，就是为复杂的声明定义一个新的简单的别名。用在回调函数中特别好用：</p>
<p>原声明：<code>int *(*a[5])(int, char*);</code></p>
<p>在这里，变量名为 a，直接用一个新别名 pFun 替换 a 就可以了：</p>
<p><code>typedef int *(*pFun)(int, char*);</code><br>于是，原声明的最简化版：</p>
<p><code>pFun a[5];</code></p>
<p>另外也要注意，typedef 在语法上是一个存储类的关键字（如 auto、extern、mutable、static、register 等一样），虽然它并不真正影响对象的存储特性，如：</p>
<p><code>typedef static int INT2; // 不可行</code><br>编译将失败，会提示“指定了一个以上的存储类”。</p>
<h2 id="C预处理"><a href="#C预处理" class="headerlink" title="C预处理"></a>C预处理</h2><p>预处理指令是以#号开头的代码行，# 号必须是该行除了任何空白字符外的第一个字符，为了增强可读性，预处理器指令应从第一列开始。# 后是指令关键字，在关键字和 # 号之间允许存在任意个数的空白字符，整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。</p>
<p>下面列出了所有重要的预处理器指令：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>#define</td>
<td>定义宏（宏定义命令）</td>
</tr>
<tr>
<td>#include</td>
<td>包含一个源代码文件（文件包含命令）</td>
</tr>
<tr>
<td>#undef</td>
<td>取消已定义的宏</td>
</tr>
<tr>
<td>#ifdef</td>
<td>如果宏已经定义，则返回真，编译下面代码</td>
</tr>
<tr>
<td>#ifndef</td>
<td>如果宏没有定义，则返回真，编译下面代码</td>
</tr>
<tr>
<td>#if</td>
<td>如果给定条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#else</td>
<td>#if 的替代方案</td>
</tr>
<tr>
<td>#elif</td>
<td>如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#endif</td>
<td>结束一个 #if……#else 条件编译块</td>
</tr>
<tr>
<td>#error</td>
<td>当遇到标准错误时，输出错误消息</td>
</tr>
<tr>
<td>#pragma</td>
<td>使用标准化方法，向编译器发布特殊的命令到编译器中</td>
</tr>
</tbody></table>
<h3 id="预处理器实例"><a href="#预处理器实例" class="headerlink" title="预处理器实例"></a>预处理器实例</h3><p>分析下面的实例来理解不同的指令。</p>
<p><strong>#define</strong></p>
<p><code>#define MAX_ARRAY_LENGTH 20</code><br>这个指令告诉 CPP 把所有的 MAX_ARRAY_LENGTH 替换为 20。使用 #define 定义常量来增强可读性。</p>
<p><strong>#include</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;myheader.h&quot;</span></span><br></code></pre></div></td></tr></table></figure>

<p>这些指令告诉 CPP 从系统库中获取 stdio.h，并添加文本到当前的源文件中。下一行告诉 CPP 从本地目录中获取 myheader.h，并添加内容到当前的源文件中。</p>
<p>说明：</p>
<p>#include 的处理过程很简单，就是将头文件的内容插入到该命令所在的位置，从而把头文件和当前源文件连接成一个源文件，这与复制粘贴的效果相同。</p>
<p>#include 的用法有两种，如下所示：</p>
<figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdHeader.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;myHeader.h&quot;</span></span><br></code></pre></div></td></tr></table></figure>

<p>使用尖括号&lt; &gt;和双引号” “的区别在于头文件的搜索路径不同：</p>
<ul>
<li>使用尖括号&lt; &gt;，编译器会到系统路径下查找头文件；</li>
<li>而使用双引号” “，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找。</li>
</ul>
<p>像 stdio.h 和 stdlib.h 都是标准头文件，它们存放于系统路径下，所以使用尖括号和双引号都能够成功引入；而我们自己编写的头文件，一般存放于当前项目的路径下，所以不能使用尖括号，只能使用双引号。通常使用尖括号来引入标准头文件，使用双引号来引入自定义头文件（自己编写的头文件），这样一眼就能看出头文件的区别。</p>
<p>关于 #include 用法的注意事项：</p>
<ul>
<li>一个 #include 命令只能包含一个头文件，多个头文件需要多个 #include 命令。</li>
<li>同一个头文件可以被多次引入，多次引入的效果和一次引入的效果相同，因为头文件在代码层面有防止重复引入的机制。</li>
<li>文件包含允许嵌套，也就是说在一个被包含的文件中又可以包含另一个文件。</li>
</ul>
<p><strong>#undef</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span>  FILE_SIZE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILE_SIZE 42</span><br></code></pre></div></td></tr></table></figure>

<p>这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42。</p>
<p><strong>#ifndef</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> MESSAGE</span><br>   <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MESSAGE <span class="hljs-meta-string">&quot;You wish!&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>

<p>这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。</p>
<figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DEBUG</span><br>   <span class="hljs-comment">/* Your debugging statements here */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>

<p>这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 -DDEBUG 开关量，这个指令就非常有用。它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。</p>
<h3 id="define的用法，C语言宏定义"><a href="#define的用法，C语言宏定义" class="headerlink" title="#define的用法，C语言宏定义"></a>#define的用法，C语言宏定义</h3><p>#define 叫做宏定义命令，它也是C语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。在预处理阶段，对程序中所有出现的“宏名”，预处理器都会用宏定义中的字符串去代换，这称为“宏替换”或“宏展开”。</p>
<p>宏定义是由源程序中的宏定义命令#define完成的，宏替换是由预处理程序完成的。</p>
<p>宏定义的一般形式为：<br>#define  宏名  定义内容</p>
<p>#表示这是一条预处理命令，所有的预处理命令都以 # 开头。宏名是标识符的一种，命名规则和变量相同。定义内容可以是数字、表达式、if 语句、函数等。</p>
<p>对 #define 用法的几点说明</p>
<ol>
<li>宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单粗暴的替换。字符串中可以含任何字符，它可以是常数、表达式、if 语句、函数等，预处理程序对它不作任何检查，如有错误，只能在编译已被宏展开后的源程序时发现。</li>
<li>宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换。</li>
<li>宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用#undef命令。</li>
<li>代码中的宏名如果被引号包围，那么预处理程序不对其作宏代替</li>
<li>宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换。</li>
<li>习惯上宏名用大写字母表示，以便于与变量区别。但也允许用小写字母。</li>
<li>可用宏定义表示数据类型，使书写方便。</li>
</ol>
<p><strong>带参数的宏定义</strong></p>
<p>C语言允许宏带有参数。在宏定义中的参数称为“形式参数”，在宏调用中的参数称为“实际参数”，这点和函数有些类似。对带参数的宏，在展开过程中不仅要进行字符串替换，还要用实参去替换形参。</p>
<p>带参宏定义的一般形式为：<br>#define 宏名(形参列表) 字符串</p>
<p>在字符串中可以含有各个形参。</p>
<p>带参宏调用的一般形式为：<br>宏名(实参列表);</p>
<p>例如：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">#define <span class="hljs-constructor">M(<span class="hljs-params">y</span>)</span> y*y+<span class="hljs-number">3</span>*y  <span class="hljs-comment">//宏定义</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>k=<span class="hljs-constructor">M(5)</span>;  <span class="hljs-comment">//宏调用</span><br></code></pre></div></td></tr></table></figure>

<p>在宏展开时，用实参 5 去代替形参 y，经预处理程序展开后的语句为<code>k=5*5+3*5</code>。</p>
<p><strong>对带参宏定义的说明</strong></p>
<ol>
<li>带参宏定义中，形参之间可以出现空格，但是宏名和形参列表之间不能有空格出现。</li>
</ol>
<p>例如把：<br><code>#define MAX(a,b) (a&gt;b)?a:b</code><br>写为：<br><code>#define MAX  (a,b)  (a&gt;b)?a:b</code><br>将被认为是无参宏定义，宏名 MAX 代表字符串(a,b) (a&gt;b)?a:b。宏展开时，宏调用语句：<br><code>max = MAX(x,y);</code><br>将变为：<br><code>max = (a,b)(a&gt;b)?a:b(x,y);</code><br>这显然是错误的。</p>
<ol start="2">
<li>在带参宏定义中，不会为形式参数分配内存，因此不必指明数据类型。而在宏调用中，实参包含了具体的数据，要用它们去替换形参，因此实参必须要指明数据类型。</li>
</ol>
<p>这一点和函数是不同的：在函数中，形参和实参是两个不同的变量，都有自己的作用域，调用时要把实参的值传递给形参；而在带参数的宏中，只是符号的替换，不存在值传递的问题。</p>
<ol start="3">
<li>在宏定义中，字符串内的形参通常要用括号括起来以避免出错。</li>
</ol>
<h3 id="预处理器运算符"><a href="#预处理器运算符" class="headerlink" title="预处理器运算符"></a>预处理器运算符</h3><p>C 预处理器提供了下列的运算符来帮助您创建宏：</p>
<p><strong>宏延续运算符（\）</strong></p>
<p>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#define  message_for(a, b)  \</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-comment">#a &quot; and &quot; #b &quot;: We love you!\n&quot;)</span><br></code></pre></div></td></tr></table></figure>

<p><strong>字符串常量化运算符（#）</strong></p>
<p>在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  message_for(a, b)  \</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-meta">#a <span class="hljs-meta-string">&quot; and &quot;</span> #b <span class="hljs-meta-string">&quot;: We love you!\n&quot;</span>)</span><br><br><span class="hljs-keyword">int</span> <span class="hljs-built_in">main</span>(<span class="hljs-keyword">void</span>)<br>&#123;<br>   <span class="hljs-built_in">message_for</span>(Carole, Debra);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<p><code>Carole and Debra: We love you!</code></p>
<p><strong>标记粘贴运算符（##）</strong></p>
<p>宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> tokenpaster(n) printf (<span class="hljs-meta-string">&quot;token&quot;</span> #n <span class="hljs-meta-string">&quot; = %d&quot;</span>, token##n)</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">int</span> token34 = <span class="hljs-number">40</span>;<br>   <br>   <span class="hljs-built_in">tokenpaster</span>(<span class="hljs-number">34</span>);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<p><code>token34 = 40</code><br>这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：</p>
<p><code>printf (&quot;token34 = %d&quot;, token34);</code><br>这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了字符串常量化运算符（#）和标记粘贴运算符（##）。</p>
<p><strong>defined() 运算符</strong></p>
<p>预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined (MESSAGE)</span><br>   <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MESSAGE <span class="hljs-meta-string">&quot;You wish!&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Here is the message: %s\n&quot;</span>, MESSAGE);  <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<p><code>Here is the message: You wish!</code></p>
<h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p>ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DATE</strong></td>
<td>当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。</td>
</tr>
<tr>
<td><strong>TIME</strong></td>
<td>当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。</td>
</tr>
<tr>
<td><strong>FILE</strong></td>
<td>这会包含当前文件名，一个字符串常量。</td>
</tr>
<tr>
<td><strong>LINE</strong></td>
<td>这会包含当前行号，一个十进制常量。</td>
</tr>
<tr>
<td><strong>STDC</strong></td>
<td>当编译器以 ANSI 标准编译时，则定义为 1。</td>
</tr>
</tbody></table>
<p>实例：</p>
<figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>main()<br>&#123;<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;File :%s\n&quot;</span>, __FILE_<span class="hljs-number">_</span> );<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Date :%s\n&quot;</span>, __DATE_<span class="hljs-number">_</span> );<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Time :%s\n&quot;</span>, __TIME_<span class="hljs-number">_</span> );<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Line :%d\n&quot;</span>, __LINE_<span class="hljs-number">_</span> );<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;ANSI :%d\n&quot;</span>, __STDC_<span class="hljs-number">_</span> );<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>当上面的代码（在文件 test.c 中）被编译和执行时，它会产生下列结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">File</span> :test.c<br><span class="hljs-attribute">Date</span> :Jun <span class="hljs-number">2</span> <span class="hljs-number">2012</span><br><span class="hljs-attribute">Time</span> :<span class="hljs-number">03</span>:<span class="hljs-number">36</span>:<span class="hljs-number">24</span><br><span class="hljs-attribute">Line</span> :<span class="hljs-number">8</span><br><span class="hljs-attribute">ANSI</span> :<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>

<h3 id="if、-ifdef、-ifndef的用法详解，C语言条件编译详解"><a href="#if、-ifdef、-ifndef的用法详解，C语言条件编译详解" class="headerlink" title="#if、##ifdef、#ifndef的用法详解，C语言条件编译详解"></a>#if、##ifdef、#ifndef的用法详解，C语言条件编译详解</h3><p>能够根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。条件编译是预处理程序的功能，不是编译器的功能。</p>
<p><strong>#if 的用法</strong></p>
<p>#if 用法的一般格式为：</p>
<figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta">#if 整型常量表达式1</span><br>    程序段<span class="hljs-number">1</span><br><span class="hljs-meta">#elif 整型常量表达式2</span><br>    程序段<span class="hljs-number">2</span><br><span class="hljs-meta">#elif 整型常量表达式3</span><br>    程序段<span class="hljs-number">3</span><br><span class="hljs-meta">#else</span><br>    程序段<span class="hljs-number">4</span><br><span class="hljs-meta">#endif</span><br></code></pre></div></td></tr></table></figure>

<p>它的意思是：如常“表达式1”的值为真（非0），就对“程序段1”进行编译，否则就计算“表达式2”，结果为真的话就对“程序段2”进行编译，为假的话就继续往下匹配，直到遇到值为真的表达式，或者遇到 #else。这一点和 if else 非常类似。</p>
<p>需要注意的是，#if 命令要求判断条件为“整型常量表达式”，也就是说，表达式中不能包含变量，而且结果必须是整数；而 if 后面的表达式没有限制，只要符合语法就行。这是 #if 和 if 的一个重要区别。</p>
<p><strong>#ifdef 的用法</strong></p>
<p>#ifdef 用法的一般格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span>  宏名</span><br>    程序段<span class="hljs-number">1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    程序段<span class="hljs-number">2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>

<p>它的意思是，如果当前的宏已被定义过，则对“程序段1”进行编译，否则对“程序段2”进行编译。<br>#ifdef 可以认为是 #if defined 的缩写。</p>
<p><strong>#ifndef 的用法</strong></p>
<p>#ifndef 用法的一般格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> 宏名</span><br>    程序段<span class="hljs-number">1</span> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span> </span><br>    程序段<span class="hljs-number">2</span> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>

<p>与 #ifdef 相比，仅仅是将 #ifdef 改为了 #ifndef。它的意思是，如果当前的宏未被定义，则对“程序段1”进行编译，否则对“程序段2”进行编译，这与 #ifdef 的功能正好相反。</p>
<p><strong>三者之间的区别</strong></p>
<p>最后需要注意的是，#if 后面跟的是“整型常量表达式”，而 #ifdef 和 #ifndef 后面跟的只能是一个宏名，不能是其他的。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/C08-files/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C08-files</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/C06-struct-union-bitfield/">
                        <span class="hidden-mobile">C06-struct-union-bitfield</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81MDkyMy8yNzQwNQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
