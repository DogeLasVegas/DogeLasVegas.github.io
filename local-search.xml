<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>datastruct-note06</title>
    <link href="/2021/12/datastruct-note06/"/>
    <url>/2021/12/datastruct-note06/</url>
    
    <content type="html"><![CDATA[<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p><a href="https://www.dotcpp.com/course/145">https://www.dotcpp.com/course/145</a><br>图的定义</p><p>一个图G是一个二元组，即序偶&lt;V,E&gt;，或记作G=&lt;V,E&gt; ，其中V是有限非空集合，称为G的顶点集,V中的元素称为顶点或结点；E称为G的边的集合，所有的边ei都属于E，都有v中的结点与之对应，称ei为G的边。</p><p>图的基本常识</p><p>弧头和弧尾</p><p>有向图中，无箭头一端的顶点通常被称为”初始点”或”弧尾”，箭头直线的顶点被称为”终端点”或”弧头”。</p><p>入度和出度</p><p>对于有向图中的一个顶点 V 来说，箭头指向 V 的弧的数量为 V 的入度（InDegree，记为 ID(V)）；箭头远离 V 的弧的数量为 V 的出度（OutDegree，记为OD(V)）。</p><p>(V1,V2) 和 &lt;V1,V2&gt; 的区别</p><p>无向图中描述两顶点（V1 和 V2）之间的关系可以用 (V1,V2) 来表示，而有向图中描述从 V1 到 V2 的”单向”关系用 &lt;V1,V2&gt; 来表示。</p><p>由于图存储结构中顶点之间的关系是用线来表示的，因此 (V1,V2) 还可以用来表示无向图中连接 V1 和 V2 的线，又称为边；同样，&lt;V1,V2&gt; 也可用来表示有向图中从 V1 到 V2 带方向的线，又称为弧。</p><p>集合 VR 的含义</p><p>并且，图中习惯用 VR 表示图中所有顶点之间关系的集合。例如，无向图的集合 VR={(v1,v2),(v1,v4),(v1,v3),(v3,v4)}，有向图的集合 VR={&lt;v1,v2&gt;,&lt;v1,v3&gt;,&lt;v3,v4&gt;,&lt;v4,v1&gt;}。</p><p>路径和回路</p><p>无论是无向图还是有向图，从一个顶点到另一顶点途径的所有顶点组成的序列（包含这两个顶点），称为一条路径。如果路径中第一个顶点和最后一个顶点相同，则此路径称为”回路”（或”环”）。</p><p>并且，若路径中各顶点都不重复，此路径又被称为”简单路径”；同样，若回路中的顶点互不重复，此回路被称为”简单回路”（或简单环）。在有向图中，每条路径或回路都是有方向的。</p><p>子图：指的是由图中一部分顶点和边构成的图，称为原图的子图。</p><p>图存储结构的分类</p><p>根据不同的特征，图又可分为完全图，连通图、稀疏图和稠密图：</p><p>完全图：若图中各个顶点都与除自身外的其他顶点有关系，这样的无向图称为完全图）。同时，满足此条件的有向图则称为有向完全图）。</p><p>具有 n 个顶点的完全图，图中边的数量为 n(n-1)/2；而对于具有 n 个顶点的有向完全图，图中弧的数量为 n(n-1)。</p><p>稀疏图和稠密图：这两种图是相对存在的，即如果图中具有很少的边（或弧），此图就称为”稀疏图”；反之，则称此图为”稠密图”。</p><p>稀疏和稠密的判断条件是：<code>e&lt;nlogn</code>，其中 e 表示图中边（或弧）的数量，n 表示图中顶点的数量。如果式子成立，则为稀疏图；反之为稠密图。</p><p>无向图中，如果任意两个顶点之间都能够连通，则称此无向图为连通图。</p><p>若无向图不是连通图，但图中存储某个子图符合连通图的性质，则称该子图为连通分量。这里的子图指的是图中”最大”的连通子图（也称”极大连通子图”）。</p><p>有向图中，若任意两个顶点 Vi 和 Vj，满足从 Vi 到 Vj 以及从 Vj 到 Vi 都连通，也就是都含有至少一条通路，则称此有向图为强连通图。</p><p>与此同时，若有向图本身不是强连通图，但其包含的最大连通子图具有强连通图的性质，则称该子图为强连通分量。</p><p>对连通图进行遍历，过程中所经过的边和顶点的组合可看做是一棵普通树，通常称为生成树。</p><p>连通图中，由于任意两顶点之间可能含有多条通路，遍历连通图的方式有多种，往往一张连通图可能有多种不同的生成树与之对应。</p><p>连通图中的生成树必须满足以下 2 个条件：<br>包含连通图中所有的顶点；<br>任意两顶点之间有且仅有一条通路；</p><p>因此，连通图的生成树具有这样的特征，即生成树中边的数量 = 顶点数 - 1。</p><p>图的顺序存储结构</p><p>用数组存储图时，需要使用两个数组，一个数组存放图中顶点本身的数据（一维数组），另外一个数组用于存储各顶点之间的关系（二维数组）。</p><p>存储图中各顶点本身数据，使用一维数组就足够了；存储顶点之间的关系时，要记录每个顶点和其它所有顶点之间的关系，所以需要使用二维数组。</p><p>不同类型的图，存储的方式略有不同，根据图有无权，可以将图划分为两大类：图和网 。</p><p>图，包括无向图和有向图；网，是指带权的图，包括无向网和有向网。存储方式的不同，指的是：在使用二维数组存储图中顶点之间的关系时，如果顶点之间存在边或弧，在相应位置用 1 表示，反之用 0 表示；如果使用二维数组存储网中顶点之间的关系，顶点之间如果有边或者弧的存在，在数组的相应位置存储其权值；反之用 0 表示。</p><p>它的优点是可以在O(1)时间内得到一条边是否存在，缺点是需要占用O(n^2)的空间。对于一个稀疏的图（边相对于点数的平方比较少）来说，用邻接矩阵来存储的话，成本偏高。</p><p>邻接矩阵存在以下缺点</p><p>a) 浪费空间—— 存稀疏图（点很多而边很少）有大量无效元素</p><p>b) 浪费时间—— 统计稀疏图中一共有多少条边</p><p>图的链式存储</p><p>通常，图更多的是采用链表存储，具体的存储方法有 3 种，分别是邻接表、邻接多重表和十字链表。</p><p>在图中，如果两个点相互连通，即通过其中一个顶点，可直接找到另一个顶点，则称它们互为邻接点。<br>邻接指的是图中顶点之间有边或者弧的存在。</p><p>在常规情况下，邻接表是O(n+e)的复杂程度（n表示节点数，e表示边长），邻界矩阵则是O(n^2)的复杂程度。</p><p>邻接表</p><p>邻接表存储图的实现方式是，给图中的各个顶点独自建立一个链表，用节点存储该顶点，用链表中其他节点存储各自的临界点。</p><p>与此同时，为了便于管理这些链表，通常会将所有链表的头节点存储到数组中（也可以用链表存储）。也正因为各个链表的头节点存储的是各个顶点，因此各链表在存储临界点数据时，仅需存储该邻接顶点位于数组中的位置下标即可。</p><p>n个顶点e条边的无向图的邻接表表示中有n个顶点表结点和2e个边表结点。(换句话说，每条边（i,j）在邻接表 中出现两次：一次在关于i的邻接表中，另一次在关于j的邻接表中)。</p><p>邻接表计算顶点的出度和入度</p><p>使用邻接表计算无向图中顶点的入度和出度会非常简单，只需从数组中找到该顶点然后统计此链表中节点的数量即可。</p><p>而使用邻接表存储有向图时，通常各个顶点的链表中存储的都是以该顶点为弧尾的邻接点，因此通过统计各顶点链表中的节点数量，只能计算出该顶点的出度，而无法计算该顶点的入度。</p><p>对于利用邻接表求某顶点的入度，有两种方式：</p><p>遍历整个邻接表中的节点，统计数据域与该顶点所在数组位置下标相同的节点数量，即为该顶点的入度；</p><p>建立一个逆邻接表，该表中的各顶点链表专门用于存储以此顶点为弧头的所有顶点在数组中的位置下标。</p><p>对于具有 n 个顶点和 e 条边的无向图，邻接表中需要存储 n 个头结点和 2e 个表结点。在图中边或者弧稀疏的时候，使用邻接表要比邻接矩阵更加节省空间。</p><p>十字链表</p><p>与邻接表不同，十字链表法仅适用于存储有向图和有向网。不仅如此，十字链表法还改善了邻接表计算图中顶点入度的问题。</p><p>十字链表存储有向图（网）的方式与邻接表有一些相同，都以图（网）中各顶点为首元节点建立多条链表，同时为了便于管理，还将所有链表的首元节点存储到同一数组（或链表）中。</p><p>首元节点中有一个数据域和两个指针域（分别用 firstin 和 firstout 表示）：</p><p>firstin 指针用于连接以当前顶点为弧头的其他顶点构成的链表；<br>firstout 指针用于连接以当前顶点为弧尾的其他顶点构成的链表；<br>data 用于存储该顶点中的数据；</p><p>由此可以看出，十字链表实质上就是为每个顶点建立两个链表，分别存储以该顶点为弧头的所有顶点和以该顶点为弧尾的所有顶点。</p><p>注意，存储图的十字链表中，各链表中首元节点与其他节点的结构并不相同</p><p>十字链表中普通节点的存储分为 5 部分内容，它们各自的作用是：</p><ul><li>tailvex 用于存储以首元节点为弧尾的顶点位于数组中的位置下标；</li><li>headvex 用于存储以首元节点为弧头的顶点位于数组中的位置下标；</li><li>hlink 指针：用于链接下一个存储以首元节点为弧头的顶点的节点；</li><li>tlink 指针：用于链接下一个存储以首元节点为弧尾的顶点的节点；</li><li>info 指针：用于存储与该顶点相关的信息，例如量顶点之间的权值；</li></ul><p>邻接多重表</p><p>邻接多重表仅适用于存储无向图或无向网。</p><p>邻接多重表存储无向图的方式，可看作是邻接表和十字链表的结合。同邻接表和十字链表存储图的方法相同，都是独自为图中各顶点建立一张链表，存储各顶点的节点作为各链表的首元节点，同时为了便于管理将各个首元节点存储到一个数组中。</p><p>各首元节点结构为：</p><ul><li>data：存储此顶点的数据；</li><li>firstedge：指针域，用于指向同该顶点有直接关联的存储其他顶点的节点。</li></ul><p>邻接多重表采用与邻接表相同的首元节点结构。但各链表中其他节点的结构与十字链表中相同，如下：</p><ul><li>mark：标志域，用于标记此节点是否被操作过，例如在对图中顶点做遍历操作时，为了防止多次操作同一节点，mark 域为 0 表示还未被遍历；mark 为 1 表示该节点已被遍历；</li><li>ivex 和 jvex：数据域，分别存储图中各边两端的顶点所在数组中的位置下标；</li><li>ilink：指针域，指向下一个存储与 ivex 有直接关联顶点的节点；</li><li>jlink：指针域，指向下一个存储与 jvex 有直接关联顶点的节点；</li><li>info：指针域，用于存储与该顶点有关的其他信息，比如无向网中各边的权；</li></ul><p>深度优先搜索（DFS）和广度优先搜索（BFS）</p><p>所谓深度优先搜索，是从图中的一个顶点出发，每次遍历当前访问顶点的临界点，一直到访问的顶点没有未被访问过的临界点为止。然后采用依次回退的方式，查看来的路上每一个顶点是否有其它未被访问的临界点。访问完成后，判断图中的顶点是否已经全部遍历完成，如果没有，以未访问的顶点为起始点，重复上述过程。</p><p>具体做法是：从某个点一直往深处走，走到不能往下走之后，就回退到上一步，直到找到解或把所有点走完。</p><p>在实现这一个依次的访问顺序时，操作动作存储与数据结构（栈）的思想及其相似，同时也由于栈的性质，我们可以通过递归来简化栈的创建，因此DFS算法的两种做法分别时利用栈或者递归实现。</p><p>算法步骤（递归或栈实现）</p><p>a)访问指定起始地点。</p><p>b)若当前访问顶点的邻接顶点有未被访问的顶点，就任选一个访问。如果没有就回退到最近访问的顶点，直到与起始顶点相通的所有点被遍历完。</p><p>c)若途中还有顶点未被访问，则再选一个点作为起始顶点，并重复前面的步骤。</p><p>深度优先搜索是一个不断回溯的过程。</p><p>广度优先搜索类似于树的层次遍历。从图中的某一顶点出发，遍历每一个顶点时，依次遍历其所有的邻接点，然后再从这些邻接点出发，同样依次访问它们的邻接点。按照此过程，直到图中所有被访问过的顶点的邻接点都被访问到。</p><p>最后还需要做的操作就是查看图中是否存在尚未被访问的顶点，若有，则以该顶点为起始点，重复上述遍历的过程。</p><p>BFS算法和核心思路就是：从某个点一直把其邻接点走完，然后任选一个邻接点把与之邻接的未被遍历的点走完，如此反复走完所有结点。类似于树的层序遍历。</p><p>BFS的核心就是要把当前在哪作为一个状态存储，并将这个状态交给队列进行入队操作，故而，算法步骤（用队列实现）</p><p>a) 访问指定起始点。</p><p>b) 访问当前顶点的邻接顶点有未被访问的顶点，并将之放入队列中。</p><p>c) 删除队列的队首节点。访问当前队列的队首，前面的步骤。直到队列为空。</p><p>d) 若若途中还有顶点未被访问，则再选一个点作为起始顶点。重复前面的步骤。（针对非连通图）</p><p>深度优先搜索算法的实现运用的主要是回溯法，类似于树的先序遍历算法。广度优先搜索算法借助队列的先进先出的特点，类似于树的层次遍历。</p><p>深度优先生成树和广度优先生成树</p><p>在对无向图进行遍历的时候，遍历过程中所经历过的图中的顶点和边的组合，就是图的生成树或者生成森林。</p><p>非连通图在进行遍历时，实则是对非连通图中每个连通分量分别进行遍历，在遍历过程经过的每个顶点和边，就构成了每个连通分量的生成树。</p><p>非连通图中，多个连通分量构成的多个生成树为非连通图的生成森林。</p><p>非连通图在遍历生成森林时，可以采用孩子兄弟表示法将森林转化为一整棵二叉树进行存储。</p><p>非连通图采用广度优先搜索算法进行遍历时，经过的顶点以及边的集合为该图的广度优先生成森林。</p><p>重连通图</p><p>在无向图中，如果任意两个顶点之间含有不止一条通路，这个图就被称为重连通图。在重连通图中，在删除某个顶点及该顶点相关的边后，图中各顶点之间的连通性也不会被破坏。</p><p>在一个无向图中，如果删除某个顶点及其相关联的边后，原来的图被分割为两个及以上的连通分量，则称该顶点为无向图中的一个关节点（或者“割点”）。</p><p>重连通图其实就是没有关节点的连通图。</p><p>在重连通图中，只删除一个顶点及其相关联的边，肯定不会破坏其连通性。如果一味地做删除顶点的操作，直到删除 K 个顶点及其关联的边后，图的连通性才遭到破坏，则称此重连通图的连通度为 K 。</p><p>判断一个图是否是重连通图</p><p>对于任意一个连通图来说，都可以通过深度优先搜索算法获得一棵深度优先生成树，树中的虚线表示遍历生成树时未用到的边，简称“回边”。也就是图中有，但是遍历时没有用到，生成树中用虚线表示出来。</p><p>在深度优先生成树中，图中的关节点有两种特性：</p><p>首先判断整棵树的树根结点，如果树根有两条或者两条以上的子树，则该顶点肯定是关节点。因为一旦树根丢失，生成树就会变成森林。</p><p>然后判断生成树中的每个非叶子结点，以该结点为根结点的每棵子树中如果有结点的回边与此非叶子结点的祖宗结点相关联，那么此非叶子结点就不是关节点；反之，就是关节点。</p><p>注意：必须是和该非叶子结点的祖宗结点（不包括结点本身）相关联，才说明此结点不是关节点。</p><p>所以，判断一个图是否是重连通图，也可以转变为：判断图中是否有关节点，如果没有关节点，证明此图为重连通图；反之则不是。</p><p>AOE网</p><p>AOE 网是在 AOV 网的基础上，其中每一个边都具有各自的权值，是一个有向无环网。其中权值表示活动持续的时间。</p><p>起始点是入度为 0 的点，称为“源点”；结束点是出度为 0 的点，称为“汇点”。这条最长的路径，被称为”关键路径“。</p><p>为了求出一个给定 AOE 网的关键路径，需要知道以下 4 个统计数据：</p><p>对于 AOE 网中的顶点有两个时间：最早发生时间（用 Ve(j) 表示）和最晚发生时间（用 Vl(j) 表示）；</p><p>对于边来说，也有两个时间：最早开始时间（用 e(i) 表示）和最晚开始时间（ l(i) 表示）。</p><p>Ve(j)：对于 AOE 网中的任意一个顶点来说，从源点到该点的最长路径代表着该顶点的最早发生时间，通常用 Ve(j) 表示。</p><p>Vl(j)：表示在不推迟整个工期的前提下，事件 Vk 允许的最晚发生时间。</p><p>e(i)：表示活动 ai 的最早开始时间，如果活动 ai 是由弧 &lt;Vk,Vj&gt; 表示的，那么活动 ai 的最早开始的时间就等于时间 Vk 的最早发生时间，也就是说：e[i] = ve[k]。</p><p>l(i)：表示活动 ai 的最晚开始时间，如果活动 ai 是由弧 &lt;Vk,Vj&gt; 表示，ai 的最晚开始时间的设定要保证 Vj 的最晚发生时间不拖后。所以，l[i]=Vl[j]-len&lt;Vk,Vj&gt;。</p><p>在得知以上四种统计数据后，就可以直接求得 AOE 网中关键路径上的所有的关键活动，方法是：对于所有的边来说，如果它的最早开始时间等于最晚开始时间，称这条边所代表的活动为关键活动。由关键活动构成的路径为关键路径。</p><p>最小生成树</p><p>最小生成树（又名：最小权重生成树）</p><p>概念：将给出的所有点连接起来（即从一个点可到任意一个点），且连接路径之和最小的图叫最小生成树。最小生成树属于一种树形结构（树形结构是一种特殊的图），或者说是直链型结构，因为当n个点相连，且路径和最短，那么将它们相连的路一定是n-1条。</p><p>普利姆(Prim)算法</p><p>普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图</p><p>具体过程如下：</p><p>(1)设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合 </p><p>(2)若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1</p><p>(3)若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1</p><p>(4)重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边</p><p>克鲁斯卡尔(Kruskal)算法</p><p>克鲁斯卡尔算法是一种用来寻找最小生成树的算法（用来求加权连通图的最小生成树的算法）。在剩下的所有未选取的边中，找最小边，如果和已选取的边构成回路，则放弃，选取次小边。</p><p>而具体的操作过程为：</p><p>a) 将图的所有连接线去掉，只剩顶点</p><p>b) 从图的边集数组中找到权值最小的边，将边的两个顶点连接起来</p><p>c)  继续寻找权值最小的边，将两个顶点之间连接起来，如果选择的边使得最小生成树出现了环路，则放弃该边，选择权值次小的边</p><p>d) 直到所有的顶点都被连接在一起并且没有环路，最小生成树就生成了。</p><p>两个核心问题</p><ul><li><p>问题一 对图的所有边按照权值大小进行排序。</p></li><li><p>问题二 将边添加到最小生成树中时，怎么样判断是否形成了回路。</p></li></ul><p>问题一直接采用排序算法进行排序即可。</p><p>问题二的核心思想是记录处理，处理方式是：记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。</p><p>最短路径</p><p>何为最短路径</p><p>最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径，大致可以分为如下几种问题，可无论如何分类问题，其本质思想还是不变的，即，求两点间的最短距离。</p><p>a) 确定起点的最短路径问题 - 即已知起始结点，求最短路径的问题。</p><p>b) 确定终点的最短路径问题 - 与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。</p><p>c) 确定起点终点的最短路径问题 - 即已知起点和终点，求两结点之间的最短路径。</p><p>d) 全局最短路径问题 - 求图中所有的最短路径。</p><p>迪杰斯特拉(Dijkstra)算法</p><p><a href="https://www.dotcpp.com/oj/ueditor/php/upload/image/20191212/1576142323256715.png">https://www.dotcpp.com/oj/ueditor/php/upload/image/20191212/1576142323256715.png</a></p><p>如上图，迪杰斯特拉算法的核心思路是：</p><ol><li><p>指定一个节点，例如我们要计算 ‘A’ 到其他节点的最短路径</p></li><li><p>引入两个集合（S、U），S集合包含已求出的最短路径的点（以及相应的最短长度），U集合包含未求出最短路径的点（以及A到该点的路径，注意 如上图所示，A-&gt;C由于没有直接相连 初始时为∞）</p></li><li><p>初始化两个集合，S集合初始时 只有当前要计算的节点，A-&gt;A = 0，</p></li><li><p>U集合初始时为 A-&gt;B = 4, A-&gt;C = ∞, A-&gt;D = 2, A-&gt;E = ∞</p></li><li><p>从U集合中找出路径最短的点，加入S集合，例如 A-&gt;D = 2</p></li><li><p>更新U集合路径，if ( ‘D 到 B,C,E 的距离’ + ‘AD 距离’ &lt; ‘A 到 B,C,E 的距离’ ) 则更新U</p></li><li><p>循环执行 4、5 两步骤，直至遍历结束，得到A 到其他节点的最短路径</p></li></ol><p>弗洛伊德(Floyd)算法</p><p>弗洛伊德算法的思路是：首先初始化距离矩阵，然后从第一个点开始逐渐更新矩阵点值。d[i][j]表示从i点到j点的距离。第k次更新时，判断d[i][k]+d[k][j]与d[i][j]的大小，如果前者小，则更新这个值，否则不变。</p><p>这个算法的核心点在于去往每一个点我们所要尽力的每一个点的记录</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>线性（顺序）查找</p><p>顺序查找的查找过程为：从表中的最后一个数据元素开始，逐个同记录的关键字做比较，如果匹配成功，则查找成功；反之，如果直到表中第一个关键字查找完也没有成功匹配，则查找失败。</p><p>顺序查找的性能分析<br><a href="http://data.biancheng.net/view/54.html">http://data.biancheng.net/view/54.html</a><br>查找操作的性能分析主要考虑其时间复杂度，而整个查找过程其实大部分时间花费在关键字和查找表中的数据进行比较上。</p><p>所以查找算法衡量好坏的依据为：查找成功时，查找的关键字和查找表中的数据元素中进行过比较的个数的平均值，称为平均查找长度（Average Search Length，用 ASL 表示）。</p><p>例如，对于具有 n 个数据元素的查找表，查找成功的平均查找长度的计算公式为：</p><p>Pi 为第 i 个数据元素被查找的概率，所有元素被查找的概率的和为 1；Ci 表示在查找到第 i 个数据元素之前已进行过比较的次数。若表中有 n 个数据元素，查找第一个元素时需要比较 n 次；查找最后一个元素时需要比较 1 次，所以有 Ci = n – i + 1 。<br>一般情况，表中各数据元素被查找的概率是未知的。假设含有 n 个数据元素的查找表中，各数据被查找的概率是相同的，则：</p><p>换算后，得：</p><p>如果对于查找表中各个数据元素有可能被查找的概率提前已知，就应该根据其查找概率的大小对查找表中的数据元素进行适当的调整：被查找概率越大，离查找出发点 i 越近；反之，越远。这样可以适当的减少查找操作中的比较次数。</p><p>上边的平均查找长度是在假设查找算法每次都成功的前提下得出的。而对于查找算法来说，查找成功和查找失败的概率是相同的。所以，查找算法的平均查找长度应该为查找成功时的平均查找长度加上查找失败时的平均查找长度。</p><p>对于含有 n 个数据的表来说，每次查找失败，比较的次数都是 n+1。所以查找算法的平均查找长度的计算公式为：</p><p>折半查找（二分查找）</p><p>它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列，注意必须要是有序排列，但有一种特殊情况可以不必须有序排列，即商品选取，从一堆标准重量为10的商品中查找出唯一的次品，这种特殊的数据情况也可以使用二分查找。</p><p>折半查找的性能分析</p><p>折半查找的运行过程可以用二叉树来描述，这棵树通常称为“判定树”。时间复杂度可以表示O(log2n) </p><p>对于具有 n 个结点（查找表中含有 n 个关键字）的判定树，它的层次数至多为：log2n + 1（如果结果不是整数，则做取整操作，例如： log211 +1 = 3 + 1 = 4 ）。</p><p>同时，在查找表中各个关键字被查找概率相同的情况下，折半查找的平均查找长度为：ASL = log2(n+1) – 1。</p><p>分块查找</p><p>分块查找是折半查找和顺序查找的一种改进方法，分块查找由于只要求索引表是有序的，对块内节点没有排序要求，因此特别适合于节点动态变化的情况，其核心有二索引表，二是分块处理。</p><p>分块查找要求把一个大的线性表分解成若干块，每块中的节点可以任意存放，但块与块之间必须排序。假设是按关键码值非递减的，那么这种块与块之间必须满足已排序要求，实际上就是对于任意的i，第i块中的所有节点的关键码值都必须小于第i+1块中的所有节点的关键码值。此外，还要建立一个索引表，把每块中的最大关键码值作为索引表的关键码值，按块的顺序存放到一个辅助数组中，显然这个辅助数组是按关键码值费递减排序的。查找时，首先在索引表中进行查找，确定要找的节点所在的块。由于索引表是排序的，因此，对索引表的查找可以采用顺序查找或折半查找；然后，在相应的块中采用顺序查找，即可找到对应的节点。</p><p>动态查找-二叉排序树</p><p>该树属于一种输入数据就默认产生一种顺序的数据结构</p><p>二叉排序树要么是空二叉树，要么具有如下特点：</p><ul><li>二叉排序树中，如果其根结点有左子树，那么左子树上所有结点的值都小于根结点的值；</li><li>二叉排序树中，如果其根结点有右子树，那么右子树上所有结点的值都大小根结点的值；</li><li>二叉排序树的左右子树也要求都是二叉排序树；</li></ul><p>即对于每一个根结点，其左孩子永远小于根，右孩子永远大于根。</p><p>使用二叉排序树查找关键字</p><p>二叉排序树中查找某关键字时，查找过程类似于次优二叉树，在二叉排序树不为空树的前提下，首先将被查找值同树的根结点进行比较，会有 3 种不同的结果：</p><ul><li>如果相等，查找成功；</li><li>如果比较结果为根结点的关键字值较大，则说明该关键字可能存在其左子树中；</li><li>如果比较结果为根结点的关键字值较小，则说明该关键字可能存在其右子树中；</li></ul><p>即考虑如果树是空的，则查找结束，无匹配。如果被查找的值和根结点的值相等，查找成功。否则就在子树中继续查找。如果被查找的值小于根结点的值就选择左子树，大于根结点的值就选择右子树。</p><p>二叉排序树中插入关键字</p><p>二叉排序树本身是动态查找表的一种表示形式，有时会在查找过程中插入或者删除表中元素，当因为查找失败而需要插入数据元素时，该数据元素的插入位置一定位于二叉排序树的叶子结点，并且一定是查找失败时访问的最后一个结点的左孩子或者右孩子。</p><p>二叉排序树中删除关键字</p><p>在查找过程中，如果在使用二叉排序树表示的动态查找表中删除某个数据元素时，需要在成功删除该结点的同时，依旧使这棵树为二叉排序树。</p><p>假设要删除的为结点 p，则对于二叉排序树来说，需要根据结点 p 所在不同的位置作不同的操作，有以下 3 种可能：</p><p>1、结点 p 为叶子结点，此时只需要删除该结点，并修改其双亲结点的指针即可；<br>2、结点 p 只有左子树或者只有右子树，此时只需要将其左子树或者右子树直接变为结点 p 双亲结点的左子树即可；<br>3、结点 p 左右子树都有，此时有两种处理方式：</p><p>1）令结点 p 的左子树为其双亲结点的左子树；结点 p 的右子树为其自身直接前驱结点的右子树</p><p>2）用结点 p 的直接前驱（或直接后继）来代替结点 p，同时在二叉排序树中对其直接前驱（或直接后继）做删除操作。</p><p>使用二叉排序树在查找表中做查找操作的时间复杂度同建立的二叉树本身的结构有关。即使查找表中各数据元素完全相同，但是不同的排列顺序，构建出的二叉排序树大不相同。</p><p>使用二叉排序树实现动态查找操作的过程，实际上就是从二叉排序树的根结点到查找元素结点的过程，所以时间复杂度同被查找元素所在的树的深度（层次数）有关。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>datastruct-note05</title>
    <link href="/2021/12/datastruct-note05/"/>
    <url>/2021/12/datastruct-note05/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的定义：n个节点组成的有限集合。n=0，空树；n&gt;0,1个根节点，m个互不相交的有限集，每个子集为根的子树。</p><p>树的基本术语</p><p>节点的度：树中某个节点的子树的个数。</p><p>树的度：树中各节点的度的最大值。</p><p>树根结点（简称“根结点”）：每一个非空树都有且只有一个被称为根的结点。</p><p>分支节点：度不为零的节点。</p><p>叶子节点：度为零的节点。</p><p>路径：i-&gt;j；路径长度：路径经过节点数目减1。</p><p>孩子节点：某节点的后继节点；<br>双亲节点：该节点为其孩子节点的双亲节点（父母节点）；<br>兄弟节点：同一双亲的孩子节点；<br>子孙节点：某节点所有子树中的节点；<br>祖先节点：从树节点到该节点的路径上的节点。</p><p>节点的层次：根节点为第一层（以此类推）；</p><p>树的高度：树中节点的最大层次。</p><p>有序树：树中节点子树按次序从左向右安排，次序不能改变；无序树：与之相反</p><p>空树：如果集合本身为空，那么构成的树就被称为空树。空树中没有结点。</p><p>森林：互不相交的树的集合。</p><p>树的性质</p><p>树的节点树为所有节点度数加1（加根节点）。</p><p>度为m的树中第i层最多有m^(i-1)个节点。</p><p>高度为h的m次树至多(m^h-1)/(m-1)个节点。</p><p>具有n个节点的m次树的最小高度为logm( n(m-1) + 1 )  向上取整。</p><p><strong>二叉树</strong></p><p>二叉树是n(n&gt;=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成，本身是有序树。</p><p><strong>二叉树的特点</strong></p><p>1）每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点，即只能是 0、1 或者 2。</p><p>2）左子树和右子树是有顺序的，次序不能任意颠倒。</p><p>3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</p><p><strong>二叉树的性质</strong></p><p>经过前人的总结，二叉树具有以下几个性质：</p><ol><li>二叉树中，第 i 层最多有 2^(i-1) 个结点。</li><li>深度为k的二叉树至多有2^k-1个结点(k≥1)。</li><li>包含n个结点的二叉树的高度至少为log2(n+1)。</li><li>在任意一棵二叉树中，若终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。</li></ol><p>性质4 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n1），那么总结点 n=n0+n1+n2。<br>同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B=n1+2<em>n2。所以，n 用另外一种方式表示为 n=n1+2</em>n2+1。<br>两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1。</p><p>斜树：所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p><p>满二叉树：在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p><p>满二叉树的特点有：</p><p>1）叶子只能出现在最下一层。出现在其它层就不可能达成平衡。</p><p>2）非叶子结点的度一定是2。</p><p>3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</p><p>满二叉树除了满足普通二叉树的性质，还具有以下性质：</p><ol><li>满二叉树中第 i 层的节点数为 2^(n-1) 个。</li><li>深度为 k 的满二叉树必有 2^k-1 个节点 ，叶子数为 2^(k-1)。</li><li>满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。</li><li>具有 n 个节点的满二叉树的深度为 log2(n+1)。</li></ol><p>完全二叉树：对一颗具有n个结点的二叉树按层编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。<br>（如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。）</p><p>完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊log2n⌋+1。</p><p><code>⌊log2n⌋ 表示取小于 log2n 的最大整数。例如，⌊log24⌋ = 2，而 ⌊log25⌋ 结果也是 2。</code></p><p>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号，对于任意一个结点 i ，完全二叉树还有以下几个结论成立：</p><ol><li>当 i&gt;1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）</li><li>如果 2<em>i&gt;n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2</em>i 。</li><li>如果 2<em>i+1&gt;n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2</em>i+1 。</li></ol><p><strong>二叉树的顺序存储和链式存储</strong></p><p>如果想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树。普通二叉树转完全二叉树的方法很简单，只需给二叉树额外添加一些节点，将其”拼凑”成完全二叉树即可。</p><p>完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可。</p><p>从顺序表中还原完全二叉树也很简单。我们知道，完全二叉树具有这样的性质，将树中节点按照层次并从左到右依次标号（1,2,3,…），若节点 i 有左右孩子，则其左孩子节点为 2<em>i，右孩子节点为 2</em>i+1。此性质可用于还原数组中存储的完全二叉树。</p><p>一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用链表存储即可。</p><p>一颗二叉树的结点设计一定要有如下内容：</p><p>a)结点元素，data域，用来存储数据，其可以是int，char等基本的类型，同时也可以是struct等这些复杂的复合数据类型。</p><p>b)左孩子结点，left指针，总是用来指向当前结点的下一层的左边结点，其属于一种指针。</p><p>c)右孩子结点，right指针，总是用来指向当前结点的下一层的右边结点，其属于一种指针。</p><p>d)父结点（可选），parent指针，总是指向当前结点的前一个结点，简称父亲结点，其不属于必须结点设计，省略掉可以达到节省内存的效果，而使用则可以更方便进行定向搜索，本案例中不使用父节点。</p><p>以上就是一颗二叉树的结点设计，除此之外，我们使用一棵树的时候需要建立一颗树根，由这个“根”，来进行逐步的向下构建。</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">其设计代码可以表示为：<br><br>//树的结点<br>typedef struct <span class="hljs-keyword">node</span><span class="hljs-title">&#123;</span><br><span class="hljs-title">    int</span> data;<br>    struct <span class="hljs-keyword">node</span><span class="hljs-title">* left</span>;<br>    struct <span class="hljs-keyword">node</span><span class="hljs-title">* right</span>;<br>    // struct <span class="hljs-keyword">node</span> <span class="hljs-title">*parent</span>;<br>&#125; <span class="hljs-keyword">Node</span><span class="hljs-title">;</span><br><span class="hljs-title">  </span><br><span class="hljs-title">//树根</span><br><span class="hljs-title">typedef</span> struct &#123;<br>    <span class="hljs-keyword">Node</span><span class="hljs-title">* root</span>;<br>&#125; Tree;<br></code></pre></div></td></tr></table></figure><p><strong>二叉树的遍历</strong></p><p>先序遍历：根左右</p><p>中序遍历：左根右</p><p>后序遍历：左右根</p><p>二叉树先序遍历的实现思想是：</p><p>访问根节点；访问当前节点的左子树；若当前节点无左子树，则访问当前节点的右子树；</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">//树的先序遍历 Preorder traversal递归实现<br>void preorder(<span class="hljs-keyword">Node</span><span class="hljs-title">* node</span>)&#123;<br>    if (<span class="hljs-keyword">node</span> <span class="hljs-title">!= NULL</span>)&#123;<br>        printf(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;data</span>);//调用操作结点数据的函数方法<br>        preorder(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>);//访问该结点的左孩子<br>        preorder(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>);//访问该结点的右孩子<br>    &#125;<br>    //如果结点为空，返回上一层<br>    return;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>而递归的底层实现依靠的是栈存储结构，因此，二叉树的先序遍历既可以直接采用递归思想实现，也可以使用栈的存储结构模拟递归的思想实现。</p><p>二叉树中序遍历的实现思想是：访问当前节点的左子树；访问根节点；访问当前节点的右子树；</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">//树的中序遍历 <span class="hljs-keyword">In</span>-<span class="hljs-keyword">order</span> <span class="hljs-title">traversal</span>递归实现<br>void inorder(<span class="hljs-keyword">Node</span><span class="hljs-title">* node</span>)&#123;<br>    if (<span class="hljs-keyword">node</span> <span class="hljs-title">!= NULL</span>)&#123;<br>        inorder(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>);//访问该结点的左孩子<br>        printf(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;data</span>);//调用操作结点数据的函数方法<br>        inorder(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>);//访问该结点的右孩子<br>    &#125;<br>    //如果结点为空，返回上一层<br>    return;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>中序遍历的非递归方式实现思想是：从根结点开始，遍历左孩子同时压栈，当遍历结束，说明当前遍历的结点没有左孩子，从栈中取出来调用操作函数，然后访问该结点的右孩子，继续以上重复性的操作。<br>除此之外，还有另一种实现思想：中序遍历过程中，只需将每个结点的左子树压栈即可，右子树不需要压栈。当结点的左子树遍历完成后，只需要以栈顶结点的右孩子为根结点，继续循环遍历即可。</p><p>二叉树后序遍历的实现思想是：从根节点出发，依次遍历各节点的左右子树，直到当前节点左右子树遍历完成后，才访问该节点元素。</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">//树的后序遍历 Post-<span class="hljs-keyword">order</span> <span class="hljs-title">traversal</span>递归实现<br>void postorder(<span class="hljs-keyword">Node</span><span class="hljs-title">* node</span>)&#123;<br>    if (<span class="hljs-keyword">node</span> <span class="hljs-title">!= NULL</span>)&#123;<br>        postorder(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>);//访问该结点的左孩子<br>        postorder(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>);//访问该结点的右孩子<br>        printf(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;data</span>);//调用操作结点数据的函数方法<br>    &#125;<br>    //如果结点为空，返回上一层<br>    return;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>后序遍历是在遍历完当前结点的左右孩子之后，才调用操作函数，所以需要在操作结点进栈时，为每个结点配备一个标志位。当遍历该结点的左孩子时，设置当前结点的标志位为 0，进栈；当要遍历该结点的右孩子时，设置当前结点的标志位为 1，进栈。这样，当遍历完成，该结点弹栈时，查看该结点的标志位的值：如果是 0，表示该结点的右孩子还没有遍历；反之如果是 1，说明该结点的左右孩子都遍历完成，可以调用操作函数。</p><p><strong>二叉树层次遍历</strong></p><p>按照二叉树中的层次从左到右依次遍历每层中的结点。具体的实现思路是：通过使用队列的数据结构，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果。</p><p>通常，普通树的存储具有普通树结构数据的方法有 3 种：</p><p>双亲表示法；孩子表示法；孩子兄弟表示法；</p><p>双亲表示法采用顺序表（也就是数组）存储普通树，其实现的核心思想是：顺序存储各个节点的同时，给各节点附加一个记录其父节点位置的变量。<br>注意，根节点没有父节点（父节点又称为双亲节点），因此根节点记录父节点位置的变量通常置为 -1。</p><p>孩子表示法存储普通树采用的是 “顺序表+链表” 的组合结构，其存储过程是：从树的根节点开始，使用顺序表依次存储树中各个节点，需要注意的是，与双亲表示法不同，孩子表示法会给各个节点配备一个链表，用于存储各节点的孩子节点位于顺序表中的位置。<br>如果节点没有孩子节点（叶子节点），则该节点的链表为空链表。</p><p>孩子兄弟表示法，采用的是链式存储结构，其存储树的实现思想是：从树的根节点开始，依次用链表存储各个节点的孩子节点和兄弟节点。</p><p>因此，该链表中的节点应包含以下 3 部分内容：<br>节点的值；指向孩子节点的指针；指向兄弟节点的指针；</p><p>表示节点结构代码为：</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ElemType char</span><br>typedef <span class="hljs-keyword">struct</span> <span class="hljs-type">CSNode</span>&#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">CSNode</span> * firstchild,*nextsibling;<br>&#125;CSNode,*CSTree;<br></code></pre></div></td></tr></table></figure><p>可以得出这样一个结论，即通过孩子兄弟表示法，任意一棵普通树都可以相应转化为一棵二叉树，换句话说，任意一棵普通树都有唯一的一棵二叉树于其对应。</p><p>因此，孩子兄弟表示法可以作为将普通树转化为二叉树的最有效方法，通常又被称为”二叉树表示法”或”二叉链表表示法”。</p><p><strong>树与森林</strong></p><p>树转换成二叉树</p><p>操作过程如下：</p><p>加线：在兄弟（即同一层之间的孩子）之间加一连线</p><p>抹线：对每个结点，除了其第一个孩子外，除去其与其余孩子之间的连线</p><p>旋转：以树的根结点为轴心，将整树顺时针转45°</p><p>注意：树转换成二叉树其右子树一定为空</p><p>二叉树转换成树</p><p>加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子，……沿分支找到的所有右孩子，都与p的双亲用线连起来</p><p>抹线：抹掉原二叉树中双亲与右孩子之间的连线</p><p>调整：将结点按层次排列，形成树结构</p><p>森林转换成二叉树</p><p>将各棵树分别转换成二叉树</p><p>将每棵树的根结点用线相连</p><p>以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构</p><p>二叉树转换成森林</p><p>抹线：将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树</p><p>还原：将孤立的二叉树还原成树（二叉树→树）</p><p><strong>哈夫曼树</strong></p><p>哈夫曼树（Huffman Tree），又名：最优二叉树，赫夫曼树</p><p>其标准含义是：给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><p>哈夫曼树相关的几个名词</p><p>a) 路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。</p><p>b) 路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。</p><p>c) 结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。</p><p>d) 结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。</p><p>e)  树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL”。</p><p>在构建哈夫曼树时，只需要遵循一个原则，那就是权重越大的结点距离树根越近。</p><p>首先，选出我们数据中最小的两个数据，构建成二叉树的左孩子和右孩子，而根的数据为两者之和</p><p>其次，将刚才合成的数据作为右孩子，左孩子从未处理的数据中选出最小的一个，作为左孩子，他们的根同样为左右孩子的权值和</p><p>不断重复上述的步骤，直到将所有的数据全部处理完并构建出二叉树，这棵二叉树就是我们的哈夫曼树。</p><p>哈夫曼树的结点结构</p><p>其代码表示为：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//哈夫曼树结点结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> weight; <span class="hljs-comment">//结点权重</span><br>    <span class="hljs-keyword">int</span> parent, left, right;    <span class="hljs-comment">//父结点、左孩子、右孩子在数组中的位置下标</span><br>&#125; HTNode, *HuffmanTree;<br></code></pre></div></td></tr></table></figure><p>构建哈夫曼树时，需要每次根据各个结点的权重值，筛选出其中值最小的两个结点，然后构建二叉树。</p><p>查找权重值最小的两个结点的思想是：从数组起始位置开始，首先找到两个无父结点的结点（说明还未使用其构建成树），然后和后续无父结点的结点依次做比较，有两种情况需要考虑：</p><p>如果比两个结点中较小的那个还小，就保留这个结点，删除原来较大的结点；<br>如果介于两个结点权重值之间，替换原来较大的结点；</p><p>哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，可变字长编码(VLC)的一种。哈夫曼编码就是在哈夫曼树的基础上构建的，这种编码方式最大的优点就是用最少的字符包含最多的信息内容。霍夫曼编码是一种无前缀编码。解码时不会混淆。其主要应用在数据压缩，加密解密等场合，也包括文件传输的场合。</p><p>根据发送信息的内容，通过统计文本中相同字符的个数作为每个字符的权值，建立哈夫曼树。对于树中的每一个子树，统一规定其左孩子标记为 0 ，右孩子标记为 1 。这样，用到哪个字符时，从哈夫曼树的根结点开始，依次写出经过结点的标记，最终得到的就是该结点的哈夫曼编码。</p><p>文本中字符出现的次数越多，在哈夫曼树中的体现就是越接近树根。编码的长度越短。</p><p>使用程序求哈夫曼编码有两种方法：</p><p>从叶子结点一直找到根结点，逆向记录途中经过的标记。</p><p>从根结点出发，一直到叶子结点，记录途中经过的标记。</p><p>n 个结点可以构建多少种形态不同的二叉树。</p><p>每一棵普通树对应的都是一棵没有右子树的二叉树，所以对于 n 个结点的树来说，树的形态改变是因为除了根结点之外的其它结点改变形态得到的，所以，n 个结点构建的形态不同的树与之对应的是 n-1 个结点构建的形态不同的二叉树。</p><p>如果 tn 表示 n 个结点构建的形态不同的树的数量，bn 表示 n 个结点构建的形态不同的二叉树的数量，则两者之间有这样的关系：tn=bn-1。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>datastruct-note04</title>
    <link href="/2021/12/datastruct-note04/"/>
    <url>/2021/12/datastruct-note04/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="数组和广义表"><a href="#数组和广义表" class="headerlink" title="数组和广义表"></a>数组和广义表</h2><p>由于数组可以是多维的，而顺序存储结构是一维的，因此数组中数据的存储要制定一个先后次序。通常，数组中数据的存储有两种先后存储方式：</p><p>以列序为主（先列后行）：按照行号从小到大的顺序，依次存储每一列的元素<br>以行序为主（先行后序）：按照列号从小到大的顺序，依次存储每一行的元素。</p><p>多维数组查找指定元素</p><p>当需要在顺序存储的多维数组中查找某个指定元素时，需知道以下信息：</p><p>多维数组的存储方式；<br>多维数组在内存中存放的起始地址；<br>该指定元素在原多维数组的坐标（比如说，二维数组中是通过行标和列标来表明数据元素的具体位置的）；<br>数组中数组的具体类型，即数组中单个数据元素所占内存的大小，通常用字母 L 表示；</p><p>根据存储方式的不同，查找目标元素的方式也不同。如果二维数组采用以行序为主的方式，则在二维数组 anm 中查找 aij 存放位置的公式为：</p><p><code>LOC(i,j) = LOC(0,0) + (i*m + j) * L;</code></p><p>其中，LOC(i,j) 为 aij 在内存中的地址，LOC(0,0) 为二维数组在内存中存放的起始位置（也就是 a00 的位置）。</p><p>而如果采用以列存储的方式，在 anm 中查找 aij 的方式为：</p><p><code>LOC(i,j) = LOC(0,0) + (i*n + j) * L;</code></p><p>矩阵（稀疏矩阵）压缩存储（3种方式）</p><p>主要分为以下两类的特殊矩阵：，</p><p>含有大量相同数据元素的矩阵，比如对称矩阵；</p><p>含有大量 0 元素的矩阵，比如稀疏矩阵、上（下）三角矩阵；</p><p>针对以上两类矩阵，数据结构的压缩存储思想是：矩阵中的相同数据元素（包括元素 0）只存储一个。</p><p>对称矩阵的实现过程是，若存储下三角中的元素，只需将各元素所在的行标 i 和列标 j 代入下面的公式：</p><p>存储上三角的元素要将各元素的行标 i 和列标 j 代入另一个公式：</p><p>最终求得的 k 值即为该元素存储到数组中的位置（矩阵中元素的行标和列标都从 1 开始）。</p><p>上(下)三角矩阵存储元素和提取元素的过程和对称矩阵相同。</p><p>压缩存储稀疏矩阵的方法是：只存储矩阵中的非 0 元素，与前面的存储方法不同，稀疏矩阵非 0 元素的存储需同时存储该元素所在矩阵中的行标和列标。</p><p>稀疏矩阵的压缩存储，数据结构提供有 3 种具体实现方式：</p><p>三元组顺序表；行逻辑链接的顺序表；十字链表；</p><p>三元组（即由 3 部分数据组成的集合），组中数据分别表示（行标，列标，元素值）。</p><p>C 语言中，三元组需要用结构体实现，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//三元组结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> i,j;<span class="hljs-comment">//行标i，列标j</span><br>    <span class="hljs-keyword">int</span> data;<span class="hljs-comment">//元素值</span><br>&#125;triple;<br></code></pre></div></td></tr></table></figure><p>由于稀疏矩阵中非 0 元素有多个，因此需要建立 triple 数组存储各个元素的三元组。除此之外，考虑到还要存储矩阵的总行数和总列数，因此可以采用以下结构表示整个稀疏矩阵：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> number 20</span><br><span class="hljs-comment">//矩阵的结构表示</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    triple data[number];<span class="hljs-comment">//存储该矩阵中所有非0元素的三元组</span><br>    <span class="hljs-keyword">int</span> n,m,num;<span class="hljs-comment">//n和m分别记录矩阵的行数和列数，num记录矩阵中所有的非0元素的个数</span><br>&#125;TSMatrix;<br></code></pre></div></td></tr></table></figure><p>可以看到，TSMatrix 是一个结构体，其包含一个三元组数组，以及用于存储矩阵总行数、总列数和非 0 元素个数的变量。</p><p>行逻辑链接的顺序表和三元组顺序表的实现过程类似，它们存储矩阵的过程完全相同，都是将矩阵中非 0 元素的三元组（行标、列标和元素值）存储在一维数组中。但为了提高提取数据的效率，前者在存储矩阵时比后者多使用了一个数组，专门记录矩阵中每行第一个非 0 元素在一维数组中的位置。</p><p>用十字链表存储稀疏矩阵，该存储方式采用的是 “链表+数组” 结构，矩阵中的各行各列都各用一各链表存储，与此同时，所有行链表的表头存储到一个数组（rhead），所有列链表的表头存储到另一个数组（chead）中。</p><p>链表中节点的 C 语言代码表示应为：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OLNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> i,j;<span class="hljs-comment">//元素的行标和列标</span><br>    <span class="hljs-keyword">int</span> data;<span class="hljs-comment">//元素的值</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OLNode</span> * <span class="hljs-title">right</span>,*<span class="hljs-title">down</span>;</span><span class="hljs-comment">//两个指针域</span><br>&#125;OLNode;<br></code></pre></div></td></tr></table></figure><p>矩阵转置的实现过程需完成以下 3 步：</p><p>将矩阵的行数和列数互换；<br>将三元组表（存储矩阵）中的 i 列和 j 列互换，实现矩阵的转置；<br>以 j 列为序，重新排列三元组表中存储各三元组的先后顺序；<br>此 3 步中，前两步比较简单，关键在于最后一步的实现。</p><p>矩阵转置的实现思路是：不断遍历存储矩阵的三元组表，每次都取出表中 j 列最小的那一个三元组，互换行标和列标的值，并按次序存储到一个新三元组表中，。</p><p><strong>广义表</strong></p><p>广义表，又称列表，也是一种线性存储结构。</p><p>同数组类似，广义表中既可以存储不可再分的元素，也可以存储广义表，记作：<br><code>LS = (a1,a2,…,an)</code></p><p>其中，LS 代表广义表的名称，an 表示广义表存储的数据。广义表中每个 ai 既可以代表单个元素，也可以代表另一个广义表。</p><p>原子和子表</p><p>通常，广义表中存储的单个元素称为 “原子”，而存储的广义表称为 “子表”。</p><p>例如创建一个广义表 LS = {1,{1,2,3}} ，我们可以这样解释此广义表的构成：广义表 LS 存储了一个原子 1 和子表 {1,2,3} 。</p><p>以下是广义表存储数据的一些常用形式：</p><p>A = ()：A 表示一个广义表，只不过表是空的。<br>B = (e)：广义表 B 中只有一个原子 e。<br>C = (a,(b,c,d)) ：广义表 C 中有两个元素，原子 a 和子表 (b,c,d)。<br>D = (A,B,C)：广义表 D 中存有 3 个子表，分别是A、B和C。这种表示方式等同于 D = ((),(e),(b,c,d)) 。<br>E = (a,E)：广义表 E 中有两个元素，原子 a 和它本身。这是一个递归广义表，等同于：E = (a,(a,(a,…)))。</p><p>注意，A = () 和 A = (()) 是不一样的。前者是空表，而后者是包含一个子表的广义表，只不过这个子表是空表。</p><p>广义表的表头和表尾</p><p>当广义表不是空表时，称第一个数据（原子或子表）为”表头”，剩下的数据构成的新广义表为”表尾”。<br>强调一下，除非广义表为空表，否则广义表一定具有表头和表尾，且广义表的表尾一定是一个广义表。</p><p>例如在广义表中 LS={1,{1,2,3},5}  中，表头为原子 1，表尾为子表 {1,2,3}  和原子 5 构成的广义表，即 {{1,2,3},5}。</p><p>再比如，在广义表 LS = {1}  中，表头为原子 1 ，但由于广义表中无表尾元素，因此该表的表尾是一个空表，用 {}  表示</p><p>一般来说，广义表具有如下重要的特性：</p><p>（1）广义表中的数据元素有相对次序</p><p>（2）广义表的长度定义为最外层包含元素个数</p><p>（3）广义表的深度定义为所含括弧的重数。其中原子的深度为0，空表的深度为1</p><p>（4）广义表可以共享；一个广义表可以为其他广义表共享；这种共享广义表称为再入表</p><p>（5）广义表可以是一个递归的表。一个广义表可以是自已的子表。这种广义表称为递归表。递归表的深度是无穷值,长度是有限值</p><p>（6）任何一个非空广义表GL均可分解为表头head(GL) = a1和表尾tail(GL) = ( a2,…,an) 两部分。 </p><p>广义表是一种不定规模的数据结构，很难为之分配具体的空间，因此创建的方法采用动态的链式方法，动态的创建空间。</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>tag</td><td>atom/node</td><td>link</td></tr></tbody></table><p>对于每一个结点而言由如上三大部分组成，其中Tag域为标志字段，其只有两个参数，0或者1（Tag域使用int类型，在某些情况下因为只需要简单判断也可以使用更短的类型，如bool）；Atom/Node域的内容由tag标志决定，当Tag为0时表示该节点是原子结点（即存放原子数据），当Tag为1时表示该节点为指向下一个广义表的指针（即表结点），Link域存放与本元素同一层的下一个元素所在的结点地址，当本元素时所在层的最后一个元素时，Link域为NULL；</p><p>链式法设计：</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AtomType int</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span>&#123;</span>ATOM,LIST&#125;ElemTag; <span class="hljs-comment">//ATOM = 0：原子；LIST = 1:子表 </span><br><span class="hljs-comment">/*结点设计*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span>&#123;</span><br>    ElemTag tag; <span class="hljs-comment">//枚举类型的标志域，只能取定义了的枚举值</span><br>    <span class="hljs-comment">//或者直接写数字 int tag;//标志域</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span>   <br>        <span class="hljs-comment">//union联合体，下面两部分只能取其一；要么取AtomType;要么取结构体ptr,ptr包括两个指针hp,tp </span><br>        AtomType atom;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span> *<span class="hljs-title">hp</span>,*<span class="hljs-title">tp</span>;</span><br>        &#125;ptr;<br>    &#125;; <br>&#125;*GList; <span class="hljs-comment">//定义广义表类型，GList为指针</span><br></code></pre></div></td></tr></table></figure><p>下面是子表法设计：</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss"><span class="hljs-comment">/*线性表存储之扩展线性表 = 子表法*/</span> <br>typedef <span class="hljs-keyword">struct</span> <span class="hljs-type">GLNode</span>&#123;<br>    ElemTag tag;<br>    <span class="hljs-comment">//或者直接写数字 int tag;//标志域</span><br>    <span class="hljs-built_in">union</span>&#123;<br>        AtomType atom;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-type">GLNode</span> *hp;   <span class="hljs-comment">//对于列表，hp指向本列表内部第一个元素，而tp是指向本层次上的下一个元素 </span><br>    &#125;;                        <br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">GLNode</span> *tp;<br>&#125; *GList;<br></code></pre></div></td></tr></table></figure><p>对于任意一个非空广义表来说，都是由两部分组成：表头和表尾。反之，只要确定的一个广义表的表头和表尾，那么这个广义表就可以唯一确定下来。</p><p>复制一个广义表，也是不断的复制表头和表尾的过程。如果表头或者表尾同样是一个广义表，依旧复制其表头和表尾。</p><p>所以，复制广义表的过程，其实就是不断的递归，复制广义表中表头和表尾的过程。</p><p>递归的出口有两个：</p><p>如果当前遍历的数据元素为空表，则直接返回空表。<br>如果当前遍历的数据元素为该表的一个原子，那么直接复制，返回即可。</p><p>在实现复制广义表的过程中，实现函数为：</p><p><code>void copyGlist(Glist C, Glist *T);</code></p><p>其中，Glist *T，等同于: struct GLNode* *T，此为二级指针，不是一级指针。在主函数中，调用此函数时，传入的是指针 T 的地址，而不是 T 。</p><p>这里使用的是地址传递，而不是值传递。如果在这里使用值传递，会导致广义表 T 丢失结点，复制失败。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>datastruct-note03</title>
    <link href="/2021/12/datastruct-note03/"/>
    <url>/2021/12/datastruct-note03/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="栈和队列和串"><a href="#栈和队列和串" class="headerlink" title="栈和队列和串"></a>栈和队列和串</h2><p>栈是一种只能从表的一端存取数据且遵循 “先进后出” 原则的线性存储结构。</p><p>通常，栈的开口端被称为栈顶；相应地，封口端被称为栈底。</p><p>将链表头部作为栈顶的一端，可以避免在实现数据 “入栈” 和 “出栈” 操作时做大量遍历链表的耗时操作。</p><p>链表的头部作为栈顶，意味着：<br>在实现数据”入栈”操作时，需要将数据从链表的头部插入；<br>在实现数据”出栈”操作时，需要删除链表头部的首元节点；</p><p>因此，链栈实际上就是一个只能采用头插法插入或删除数据的链表。</p><p>数据从表的一端进，从另一端出，且遵循 “先进先出” 原则的线性存储结构就是队列。</p><p>通常，称进数据的一端为 “队尾”，出数据的一端为 “队头”，数据元素进队列的过程称为 “入队”，出队列的过程称为 “出队”。</p><p>栈和队列不要混淆，栈结构是一端封口，特点是”先进后出”；而队列的两端全是开口，特点是”先进先出”。</p><p>作为队列用的存储区还没有满,但队列却发生了溢出,我们把这种现象称为”假溢出”。也就是说，整个顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。</p><p>链式队列数据入队</p><p>链队队列中，当有新的数据元素入队，只需进行以下 3 步操作：<br>将该数据元素用节点包裹，例如新节点名称为 elem；<br>与 rear 指针指向的节点建立逻辑关系，即执行 rear-&gt;next=elem；<br>最后移动 rear 指针指向该新节点，即 rear=elem；</p><p>链式队列数据出队</p><p>链式队列中队头元素出队，需要做以下 3 步操作：<br>通过 top 指针直接找到队头节点，创建一个新指针 p 指向此即将出队的节点；<br>将 p 节点（即要出队的队头节点）从链表中摘除；<br>释放节点 p，回收其所占的内存空间；</p><p>串存储结构的具体实现</p><p>存储一个字符串，数据结构包含以下 3 种具体存储结构：</p><p>定长顺序存储：实际上就是用普通数组（又称静态数组）存储，可以简单地理解为采用 “固定长度的顺序存储结构” 来存储字符串，因此限定了其底层实现只能使用静态数组。例如 C 语言使用普通数据存储字符串的代码为 char a[20] = “data.biancheng.net”。</p><p>堆分配存储：用动态数组存储字符串；动态数组相比普通数组（静态数组）的优势是长度可变，换句话说，根据需要动态数组可额外申请更多的堆空间（使用 relloc 函数）；</p><p><code>char * a = (char*)malloc(5*sizeof(char));</code><br>此行代码创建了一个动态数组 a，通过使用 malloc 申请了 5 个 char 类型大小的堆存储空间。</p><p><code>a = (char*)realloc(a, 10*sizeof(char));</code><br>通过使用这行代码，之前具有 5 个 char 型存储空间的动态数组，其容量扩大为可存储 10 个 char 型数据。</p><p>块链存储：用链表存储字符串；串的块链存储，指的是使用链表结构存储字符串。</p><p>链表各节点存储数据个数的多少可参考以下几个因素：</p><p>串的长度和存储空间的大小：若串包含数据量很大，且链表申请的存储空间有限，此时应尽可能的让各节点存储更多的数据，提高空间的利用率（每多一个节点，就要多申请一个指针域的空间）；反之，如果串不是特别长，或者存储空间足够，就需要再结合其他因素综合考虑；</p><p>程序实现的功能：如果实际场景中需要对存储的串做大量的插入或删除操作，则应尽可能减少各节点存储数据的数量；反之，就需要再结合其他因素。</p><p>串的模式匹配算法，通俗地理解，是一种用来判断两个串之间是否具有”主串与子串”关系的算法。</p><p>主串与子串：如果串 A（如 “shujujiegou”）中包含有串 B（如 “ju”），则称串 A 为主串，串 B 为子串。主串与子串之间的关系可简单理解为一个串 “包含” 另一个串的关系。</p><p>实现串的模式匹配的算法主要有以下两种：</p><p>普通的模式匹配算法；<br>快速模式匹配算法；</p><p>普通模式匹配算法，其实现过程没有任何技巧，就是简单粗暴地拿一个串同另一个串中的字符一一比对，得到最终结果。</p><p>BF算法时间复杂度<br>该算法最理想的时间复杂度 O(n)，n 表示串 A 的长度，即第一次匹配就成功。</p><p>BF 算法最坏情况的时间复杂度为 O(n*m)，n 为串 A 的长度，m 为串 B 的长度。例如，串 B 为 “0000000001”，而串 A 为 “01”，这种情况下，两个串每次匹配，都必须匹配至串 A 的最末尾才能判断匹配失败，因此运行了 n*m 次。</p><p><strong>KMP算法</strong></p><p><a href="https://blog.csdn.net/v_JULY_v/article/details/7041827">https://blog.csdn.net/v_JULY_v/article/details/7041827</a></p><p>KMP算法与前文的暴力匹配算法，核心的区别就是没有不匹配的回溯，而是根据整个字符串的情况进行一次位移，这样大大减少了回溯产生的缺陷，KMP算法的时间复杂度可以优化到 O( n + m)级别，是二次优化到线性的程度。</p><p>给定一个主字符串 T = “AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB”(47位)<br>同时给定模式串 P = “AAAAAB”（6位）</p><p>构造next表(以-1开头)</p><p>对于模式串P而言，我们需要知道模式串中P的每一位的前一位是否存在相等的完全相等的前后缀，并且求这个最大的完全相等的前后缀，如一个模式串”ABCABDE”对于第倒数第二位字符而言，其符合情况的前后缀就是”AB”，而最后一位则没有完全相等的前后缀。</p><p>PS：何为前后缀：如一个字符串”ABCD”,其前缀有可能为”A”“AB”“ABC”(即除去本身的全部字符)，同理，则后缀可能为：”D””CD””BCD”</p><p>我们需要求的就是每一个字符其相对应的最大前后缀数，这样与模式串P一一对应的表称之为next表。</p><p>因此”ABCABDE”的next表为：-1 0 0 0 1 2 0 （字符用空格隔开）</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>A</td><td>B</td><td>C</td><td>A</td><td>B</td><td>D</td><td>E</td></tr><tr><td>-1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td></tr></tbody></table><p>对于每一个当前需要判断的字符而言，在构造next表时，应该向前进行比对，以上一个已经判断的情况为基础（初始值赋-1，部分教程中初始值赋0，两者没有实质区别），后缀如果+1位置的字符与前缀+1位置的字符相等，则next[i]就是next[i-1]+1，而如果不相等，则说明无法匹配，则next[i]=0。</p><p>KMP实现</p><p>与暴力匹配极其相似，利用while循环的条件控制， 进行匹配失败时，只需要将失败的模式串P的索引指向next表中对应的数值即可，其余匹配照旧线性执行即可。</p><p>要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</p><p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，</p><p>　　－　“A”的前缀和后缀都为空集，共有元素的长度为0；</p><p>　　－　“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</p><p>　　－　“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</p><p>　　－　“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</p><p>　　－　“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</p><p>　　－　“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</p><p>　　－　“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</p><p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>datastruct-note02</title>
    <link href="/2021/12/datastruct-note02/"/>
    <url>/2021/12/datastruct-note02/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构（简称顺序表）；<br>数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构（简称链表）；</p><p>也就是说，线性表存储结构可细分为顺序存储结构和链式存储结构。</p><p>某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”；<br>某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”；</p><p>定义顺序表：</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Table</span>&#123;</span><br>    <span class="hljs-keyword">int</span> * head;<span class="hljs-comment">//声明了一个名为head的长度不确定的数组，也叫“动态数组”</span><br>    <span class="hljs-keyword">int</span> length;<span class="hljs-comment">//记录当前顺序表的长度</span><br>    <span class="hljs-keyword">int</span> size;<span class="hljs-comment">//记录顺序表分配的存储容量</span><br>&#125;table;<br></code></pre></div></td></tr></table></figure><p>链表中每个数据的存储都由以下两部分组成：</p><p>数据元素本身，其所在的区域称为数据域；<br>指向直接后继元素的指针，所在的区域称为指针域；</p><p>链表中每个节点的具体实现：</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Link</span>&#123;</span><br>    <span class="hljs-keyword">char</span> elem; <span class="hljs-comment">//代表数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Link</span> * <span class="hljs-title">next</span>;</span> <span class="hljs-comment">//代表指针域，指向直接后继元素</span><br>&#125;link; <span class="hljs-comment">//link为节点名，每个节点都是一个 link 结构体</span><br></code></pre></div></td></tr></table></figure><p>提示，由于指针域中的指针要指向的也是一个节点，因此要声明为 Link 类型（这里要写成 struct Link* 的形式）。</p><p>头节点，头指针和首元节点</p><p>一个完整的链表需要由以下几部分构成：</p><p>头指针：一个普通的指针，它的特点是永远指向链表第一个节点的位置。很明显，头指针用于指明链表的位置，便于后期找到链表并使用表中的数据；</p><p>节点：链表中的节点又细分为头节点、首元节点和其他节点：</p><p>头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题；</p><p>首元节点：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；</p><p>其他节点：链表中其他的节点；</p><p>单链表的创建分为头插入法和尾插入法两种，两者并无本质上的不同，都是利用指针指向下一个结点元素的方式进行逐个创建，只不过使用头插入法最终得到的结果是逆序的。</p><p>链表插入元素，只需做以下两步操作，即可将新元素插入到指定的位置：</p><p>1.将新结点的 next 指针指向插入位置后的结点；<br>2.将插入位置前结点的 next 指针指向插入结点；</p><p>注意：链表插入元素的操作必须是先步骤 1，再步骤 2；反之，若先执行步骤 2，会导致插入位置后续的部分链表丢失，无法再实现步骤 1。</p><p>从链表中删除数据元素需要进行以下 2 步操作：</p><p>将结点从链表中摘下来;<br>手动释放掉结点，回收被结点占用的存储空间;</p><p>其中，从链表上摘除某节点的实现非常简单，只需找到该节点的直接前驱节点 temp，执行一行程序：<br><code>temp-&gt;next=temp-&gt;next-&gt;next;</code></p><p>双向链表中各节点包含以下 3 部分信息：</p><p>指针域：用于指向当前节点的直接前驱节点；<br>数据域：用于存储数据元素；<br>指针域：用于指向当前节点的直接后继节点。</p><p>双链表的节点结构用 C 语言实现为：</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">typedef <span class="hljs-keyword">struct</span> <span class="hljs-type">line</span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">line</span> * prior; <span class="hljs-comment">//指向直接前趋</span><br>    int data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">line</span> * next; <span class="hljs-comment">//指向直接后继</span><br>&#125;<span class="hljs-keyword">line</span>;<br></code></pre></div></td></tr></table></figure><p>双向链表添加节点</p><p>根据数据添加到双向链表中的位置不同，可细分为以下 3 种情况：</p><ol><li>添加至表头<br>将新数据元素添加到表头，只需要将该元素与表头元素建立双层逻辑关系即可。</li></ol><p>换句话说，假设新元素节点为 temp，表头节点为 head，则需要做以下 2 步操作即可：<br>temp-&gt;next=head; head-&gt;prior=temp;<br>将 head 移至 temp，重新指向新的表头；</p><ol start="2"><li><p>添加至表的中间位置<br>同单链表添加数据类似，双向链表中间位置添加数据需要经过以下 2 个步骤：<br>新节点先与其直接后继节点建立双层逻辑关系；<br>新节点的直接前驱节点与之建立双层逻辑关系；</p></li><li><p>添加至表尾<br>与添加到表头是一个道理，实现过程如下：<br>找到双链表中最后一个节点；<br>让新节点与最后一个节点进行双层逻辑关系；</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>datastruct-note01</title>
    <link href="/2021/12/datastruct-note01/"/>
    <url>/2021/12/datastruct-note01/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h2><p>算法的特性</p><p>(1) 输入输出 (2) 确定性 (3)有穷性 (4)可行性</p><p>算法设计要求</p><p>(1) 正确性 (2)健壮性 (3)可读性 (4)耗时低，占用空间少</p><p>基本概念和术语</p><p>(1)数据</p><p>数据（Data）是信息的载体，是可以被计算机识别，存储并加工处理的描述客观事物的信息符号的总称。数据不仅仅包括了整形，浮点数等数值类型，还包括了字符甚至声音，视频，图像等非数值的类型。</p><p>(2)数据元素</p><p>数据元素（Data Element）是描述数据的基本单位，也被称为记录。一个数据元素有若干个数据项组成。</p><p>如禽类，鸡鸭都属于禽类的数据元素。</p><p>(3)数据项</p><p>数据项（Data Item）是描述数据的最小单位，其可以分为组合项和原子项：</p><p>(a)组合项</p><p>如果数据元素可以再度分割，则每一个独立处理单元就是数据项，数据元素就是数据项的集合。</p><p>(b)原子项</p><p>如果数据元素不能再度分割，则每一个独立处理的单元就是原子项。</p><p>如日期2019年4月25日就是一个组合项，其表示日期，但如果单独拿25日这个数据出来观测，这就是一个原子项，因为其不可以再分割。</p><p>(4)数据对象</p><p>数据对象（Data Object）是性质相同的一类数据元素的集合，是数据的一个子集。数据对象可以是有限的，也可以是无限的。</p><p>(5)数据结构</p><p>数据结构（Data Structures）主要是指数据和关系的集合</p><p>四大逻辑结构（Logic Structure）</p><p>(1) 集合结构</p><p>集合结构（Set Structure）中所有数据元素除了同属于一个集合外，并无其他关系。</p><p>(2) 线性结构</p><p>线性结构（Linear Structure）指的是数据元素之间存在“一对一的关系”</p><p>(3) 树形结构</p><p>树形结构（Tree Structure）指的是数据元素之间存在“一对多”的层次关系。</p><p>(4) 图形结构</p><p>图形结构（Graphic Structure，也称：网状结构）指的是数据元素之间存在“多对多的关系”（注：此时的“多对多”中的多表示，至少有一个）</p><p>数据类型</p><ol><li>数据类型</li></ol><p>数据类型（Data Type）是高级程序设计语言中的概念，是数据的取值范围和对数进行操作的总和。数据类型规定了程序中对象的特性。程序中的每一个变量，常量或者表达式都属于一种数据类型。</p><ol start="2"><li>抽象数据类型</li></ol><p>抽象数据类型（Abstract Data Type，ADT）只是一个数学模型以及定义在模型上的一组操作。通常是对数据的抽象，定义了数据的取值范围以及对数据操作的集合。</p><p>抽象数据类型的特征是实现与操作分离，从而实现封装。</p><p>时间空间复杂度定义</p><ol><li>时间复杂度</li></ol><p>时间频度中，n称为问题的规模，当n不断变化时,时间频度T(n)也会不断变化。一般情况下，算法中的基本操作重复次数的是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</p><p>2)空间复杂度</p><p>一个程序的空间复杂度是指运行完一个程序所需内存的大小，其包括两个部分。</p><p>a)固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。</p><p>b)可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。</p><p>如下列举了常用的几种时间复杂度，以及它们之间的大小关系：</p><p>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(n2)平方阶 &lt; O(n3)(立方阶) &lt; O(2n) (指数阶)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C09-others</title>
    <link href="/2021/12/C09-others/"/>
    <url>/2021/12/C09-others/</url>
    
    <content type="html"><![CDATA[<h2 id="C错误处理"><a href="#C错误处理" class="headerlink" title="C错误处理"></a>C错误处理</h2><p>在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。在 errno.h 头文件中可以找到各种各样的错误代码。<br>在程序初始化时，把 errno 设置为 0，0 值表示程序中没有错误，这是一种良好的编程习惯。</p><p><strong>errno、perror() 和 strerror()</strong><br>C 语言提供了 perror() 和 strerror() 函数来显示与 errno 相关的文本消息。</p><ul><li>perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。</li><li>strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。</li></ul><p><strong>程序退出状态</strong></p><p>通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。</p><p>如果程序中存在一种错误情况，当退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。</p><h2 id="C其他"><a href="#C其他" class="headerlink" title="C其他"></a>C其他</h2><p><a href="http://c.biancheng.net/c/example/">http://c.biancheng.net/c/example/</a></p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>C 语言为内存的分配和管理提供了几个函数。这些函数可以在 &lt;stdlib.h&gt; 头文件中找到。</p><table><thead><tr><th>序号</th><th>函数和描述</th><th></th></tr></thead><tbody><tr><td>1</td><td>void *calloc(int num, int size);</td><td>在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</td></tr></tbody></table><p>|2|void free(void *address);|该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。<br>|3|void *malloc(int num);|在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。|<br>|4|void *realloc(void *address, int newsize);|该函数重新分配内存，把内存扩展到 newsize。|<br>注意：void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。</p><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>执行程序时，可以从命令行传值给 C 程序。这些值被称为命令行参数，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。</p><p>命令行参数是使用 main() 函数参数来处理的，其中，argc 是指传入参数的个数，argv[] 是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[] )</span>  </span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>( argc == <span class="hljs-number">2</span> )<br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The argument supplied is %s\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>   &#125;<br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( argc &gt; <span class="hljs-number">2</span> )<br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Too many arguments supplied.\n&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">else</span><br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;One argument expected.\n&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用一个参数，编译并执行上面的代码，它会产生下列结果：</p><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">$./a.<span class="hljs-keyword">out</span> testing<br>The argument supplied <span class="hljs-keyword">is</span> testing<br></code></pre></div></td></tr></table></figure><p>使用两个参数，编译并执行上面的代码，它会产生下列结果：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$./a.out testing1 testing2<br>Too many <span class="hljs-built_in">arguments</span> supplied.<br></code></pre></div></td></tr></table></figure><p>不传任何参数，编译并执行上面的代码，它会产生下列结果：</p><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata">$./a.<span class="hljs-keyword">out</span><br><span class="hljs-keyword">One</span> argument expected<br></code></pre></div></td></tr></table></figure><p>应当指出的是，argv[0] 存储程序的名称，argv[1] 是一个指向第一个命令行参数的指针，*argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，argc 将被设置为 2。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="数的阶乘"><a href="#数的阶乘" class="headerlink" title="数的阶乘"></a>数的阶乘</h3><p>下面的实例使用递归函数计算一个给定的数的阶乘：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>(i &lt;= <span class="hljs-number">1</span>)<br>   &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> i * <span class="hljs-built_in">factorial</span>(i - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">15</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d 的阶乘为 %f\n&quot;</span>, i, <span class="hljs-built_in">factorial</span>(i));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><p>15 的阶乘为 1307674368000.000000</p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>下面的实例使用递归函数生成一个给定的数的斐波那契数列：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fibonaci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)<br>   &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   &#125;<br>   <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)<br>   &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">fibonaci</span>(i<span class="hljs-number">-1</span>) + <span class="hljs-built_in">fibonaci</span>(i<span class="hljs-number">-2</span>);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t\n&quot;</span>, <span class="hljs-built_in">fibonaci</span>(i));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><p>0<br>1<br>1<br>2<br>3<br>5<br>8<br>13<br>21<br>34</p><h2 id="指针处理链表"><a href="#指针处理链表" class="headerlink" title="指针处理链表"></a>指针处理链表</h2><p><a href="https://www.runoob.com/w3cnote/c-structures-intro.html">https://www.runoob.com/w3cnote/c-structures-intro.html</a></p><h3 id="链表概述"><a href="#链表概述" class="headerlink" title="链表概述"></a>链表概述</h3><p>链表是一种常见的重要的数据结构。它是动态地进行存储分配的一种结构。</p><p>链表有一个 头指针 变量，它存放一个地址，该地址指向一个元素，链表中每一个元素称为 结点，每个结点都应包括两个部分，一为用户需要用的实际数据，二为下一个结点的地址。可以看出，头指针 head 指向第一个元素，第一个元素又指向第二个元素，。。。。直到最后一个元素，该元素不再指向其他元素，它称为 表尾，它的地址部分放一个 NULL（表示 空地址）链表到此结束。</p><p>可以看到链表中各元素在内存中可以不是连续存放的，要找某一元素，必须先找到上一个元素，根据它提供的下一元素地址才能找到下一个元素。如果不提供 头指针 head 则整个链表无法访问。</p><p>可以看到。这种链表的数据结构，必须利用指针变量才能实现，即一个结点中应包含一个指针变量，用它存放下一结点的地址。</p><p>前面介绍了结构体变量，用它作链表中的结点是最合适的，一个结构体变量包含若干成员，这些成员可以是数值类型，字符类型，数组类型，也可以是指针类型，我们用这个指针类型成员来存放下一个结点的地址。例如可以设计这样一个结构体类型：</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">struct student<br>&#123;<br>    int num<span class="hljs-comment">;</span><br>    float score<span class="hljs-comment">;</span><br>    struct student *next<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>其中成员 num 和 score 用来存放结点中的有用数据（用户需要用到的数据），next 是指针类型成员，它指向 struct student 类型数据（这是 next 所在结构体类型）。一个指针类型的成员既可以指向其他类型的结构体数据，也可以指向自己所在的结构体类型的数据。现在 next 是 struct student 类型中的一个成员，它又指向 struct student 类型的数据。用这种方法就可以建立链表。</p><p>请注意：只是定义一个 struct student 类型，并未实际分配存储空间，只有定义了变量才分配内存单元。</p><h3 id="简单链表"><a href="#简单链表" class="headerlink" title="简单链表"></a>简单链表</h3><p>下面通过一个例子来说明如何建立和输出一个简单链表:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NULL 0</span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">long</span> num;<br>    <span class="hljs-keyword">float</span> score;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> <span class="hljs-title">a</span>, <span class="hljs-title">b</span>, <span class="hljs-title">c</span>, *<span class="hljs-title">head</span>, *<span class="hljs-title">p</span>;</span><br>    a.num = <span class="hljs-number">99101</span>; a.score = <span class="hljs-number">89.5</span>;<br>    b.num = <span class="hljs-number">99103</span>; b.score = <span class="hljs-number">90</span>;<br>    c.num = <span class="hljs-number">99107</span>; c.score = <span class="hljs-number">85</span>;<span class="hljs-comment">//对结点的 num 和 score 成员赋值</span><br>    head = &amp;a;<span class="hljs-comment">//将结点 a 的起始地址赋给头指针 head</span><br>    a.next = &amp;b;<span class="hljs-comment">//将结点 b 的起始地址赋给 a 结点的 next 成员</span><br>    b.next = &amp;c;<br>    c.next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// c 结点的 next 成员不存放其他结点地址</span><br>    p = head;<span class="hljs-comment">//使 p 指针指向 a 结点</span><br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld %5.1f\n&quot;</span>, p-&gt;num, p-&gt;score);<span class="hljs-comment">// 输出 p 指向的结点的数据</span><br>        p = p-&gt;next;<span class="hljs-comment">//使 p 指向下一结点</span><br>    &#125;<span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//输出完 c 结点后 p 的值为 NULL</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果:</p><p>99101  89.5<br>99103  90.0<br>99107  85.0</p><h3 id="处理动态链表所需的函数"><a href="#处理动态链表所需的函数" class="headerlink" title="处理动态链表所需的函数"></a>处理动态链表所需的函数</h3><p>（1）malloc 函数</p><p><code>void *malloc(unsigned int size);</code></p><p>作用是在内存的动态存储区中分配一个长度为 size 的连接空间。些函数的值（即返回值）是一个指向分配空间起始地址的指针（基类型为 void）。如果些函数未能成功地执行（例如内存空间不足）则返回空指针 NULL。</p><p>（2）calloc 函数</p><p><code>void *calloc(unsigned n, unsigned size);</code></p><p>其作用是在内存的动态区存储中分配 n 个长度为 size 的连续空间。函数返回一个指向分配空间起始地址的指针，如果分配不成功，返回 NULL。 用 calloc 函数可以为一维数组开辟动态存储空间， n 为数组元素个数，每个元素长度为 size。</p><p>（3）free 函数</p><p><code>void free(void *p);</code></p><p>其作用是释放由 p 指向的内存区，使这部分内存区能被其它变量使用， p 是最后一次调用 calloc 或 malloc 函数时返回的值。free 函数无返回值。 请注意：以前的C版本提供的 malloc 和 calloc 函数得到的是指向字符型数据的指针。ANSI C 提供的 malloc 和 calloc 函数规定为 void * 类型。</p><h3 id="建立动态链表"><a href="#建立动态链表" class="headerlink" title="建立动态链表"></a>建立动态链表</h3><p>所谓建立动态链表是指在程序执行过程中从无到有地建立起一个键表，即一个一个地开辟结点和输入各结点数据，并建立起前后相链的关系。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NULL 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEN sizeof(struct student)</span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">long</span> num;<br>    <span class="hljs-keyword">float</span> score;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br> <br><span class="hljs-function">struct student *<span class="hljs-title">create</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> *<span class="hljs-title">p1</span>, *<span class="hljs-title">p2</span>, *<span class="hljs-title">head</span>;</span><br>    <span class="hljs-keyword">int</span> num;<br>    <span class="hljs-keyword">float</span> score;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br> <br>    head = <span class="hljs-literal">NULL</span>;<br> <br>    p1 = p2 = (struct student *)<span class="hljs-built_in">malloc</span>(LEN);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;please input num and score.\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d,%f&quot;</span>, &amp;p1-&gt;num, &amp;p1-&gt;score);<br> <br>    <span class="hljs-keyword">while</span>(p1-&gt;num != <span class="hljs-number">0</span>)<br>    &#123;<br>        n ++;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>            head = p1;<br>        <span class="hljs-keyword">else</span><br>            p2-&gt;next = p1;<br>        p2 = p1;<br>        p1 = (struct student *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct student));<br> <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;please input num and score.\n&quot;</span>);<br> <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d,%f&quot;</span>, &amp;p1-&gt;num, &amp;p1-&gt;score);<br>    &#125;<br>    p2-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printlist</span><span class="hljs-params">(struct student *head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> *<span class="hljs-title">p</span>;</span><br>    p = head;<br>    <span class="hljs-keyword">if</span>(head != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num=%d score=%f\n&quot;</span>, p-&gt;num, p-&gt;score);<br>            p = p-&gt;next;<br>        &#125;<span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>);<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> *<span class="hljs-title">head</span>;</span><br>    head = <span class="hljs-built_in">create</span>();<br>    <span class="hljs-built_in">printlist</span>(head);<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="链表的各种操作"><a href="#链表的各种操作" class="headerlink" title="链表的各种操作"></a>链表的各种操作</h3><h4 id="打印链表："><a href="#打印链表：" class="headerlink" title="打印链表："></a>打印链表：</h4><figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl">void printlist(struct student *head)<br>&#123;<br>    struct student *p;<br>    p = head;<br><br>    <span class="hljs-keyword">if</span>(head != NULL)<br>    &#123;<br>        <span class="hljs-keyword">do</span> <br>        &#123;<br>            <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;num=%d score=%5.2f\n&quot;</span>, p-&gt;num, p-&gt;score);<br>            p = p-&gt;<span class="hljs-keyword">next</span>;<br>        &#125; <span class="hljs-keyword">while</span> (p != NULL);<br>    &#125;<br>    /* <span class="hljs-keyword">while</span>(p -&gt; <span class="hljs-keyword">next</span> != NULL)<br>    &#123;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;num=%d score=%f\n&quot;</span>, p-&gt;num, p-&gt;score);<br>        p = p-&gt;<span class="hljs-keyword">next</span>;<br>    &#125;*/<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点:"></a>删除节点:</h4><figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">struct</span> student *delNode(struct student *head, int num)<br>&#123;<br>    printf(<span class="hljs-string">&quot;delNode.\n&quot;</span>)<span class="hljs-comment">;</span><br>    struct student *<span class="hljs-built_in">p1</span>, *<span class="hljs-built_in">p2</span><span class="hljs-comment">;</span><br>    <span class="hljs-meta">if</span>(head == NULL)<br>    &#123;<br>        printf(<span class="hljs-string">&quot;The List is NULL.\n&quot;</span>)<span class="hljs-comment">;</span><br>    &#125;<br>    <span class="hljs-meta">else</span><br>    &#123;<br>        <span class="hljs-built_in">p1</span> = head<span class="hljs-comment">;</span><br>        <span class="hljs-meta">while</span>(<span class="hljs-built_in">p1</span>-&gt;next != NULL &amp;&amp; <span class="hljs-built_in">p1</span>-&gt;num != num)<br>        &#123;<br>            <span class="hljs-built_in">p2</span> = <span class="hljs-built_in">p1</span><span class="hljs-comment">;</span><br>            <span class="hljs-built_in">p1</span> = <span class="hljs-built_in">p1</span>-&gt;next<span class="hljs-comment">;</span><br>        &#125;<br>        <span class="hljs-meta">if</span>(<span class="hljs-built_in">p1</span>-&gt;num == num)<br>        &#123;<br>            <span class="hljs-meta">if</span>(<span class="hljs-built_in">p1</span> == head)<br>                head = <span class="hljs-built_in">p1</span>-&gt;next<span class="hljs-comment">;</span><br>            <span class="hljs-meta">else</span><br>                <span class="hljs-built_in">p2</span>-&gt;next = <span class="hljs-built_in">p1</span>-&gt;next<span class="hljs-comment">;</span><br>        &#125;<br>        <span class="hljs-meta">else</span><br>            printf(<span class="hljs-string">&quot;Can not find list num.\n&quot;</span>)<span class="hljs-comment">;</span><br>    &#125;<br>    return head<span class="hljs-comment">;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点:"></a>更新节点:</h4><figure class="highlight ocaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ocaml"><span class="hljs-keyword">struct</span> student *update(<span class="hljs-keyword">struct</span> student *head, <span class="hljs-built_in">int</span> index, <span class="hljs-built_in">int</span> num, <span class="hljs-built_in">float</span> score)<br>&#123;<br>    printf(<span class="hljs-string">&quot;update.\n&quot;</span>);<br>    <span class="hljs-keyword">struct</span> student *p;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-type">NULL</span>)<br>    &#123;<br>        printf(<span class="hljs-string">&quot;The List is NULL.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        p = head;<br>        <span class="hljs-keyword">while</span>(p-&gt;next != <span class="hljs-type">NULL</span> &amp;&amp; p-&gt;num != index)<br>        &#123;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p-&gt;num == index)<br>        &#123;<br>            p-&gt;num = num;<br>            p-&gt;score = score;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            printf(<span class="hljs-string">&quot;Can not find list index.\n&quot;</span>);<br>    &#125;<br>    return head;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点:"></a>增加节点:</h4><figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">struct</span> student *add(struct student *head, int index, int num, float score)<br>&#123;<br>    printf(<span class="hljs-string">&quot;add.\n&quot;</span>)<span class="hljs-comment">;</span><br>    struct student *<span class="hljs-built_in">p1</span>, *<span class="hljs-built_in">p2</span>, *<span class="hljs-built_in">p3</span><span class="hljs-comment">;</span><br>    <span class="hljs-meta">if</span>(head == NULL)<br>    &#123;<br>        printf(<span class="hljs-string">&quot;The List is NULL.\n&quot;</span>)<span class="hljs-comment">;</span><br>    &#125;<br>    <span class="hljs-meta">else</span><br>    &#123;<br>        <span class="hljs-built_in">p1</span> = <span class="hljs-built_in">p2</span> = head<span class="hljs-comment">;</span><br>        <span class="hljs-meta">while</span>(<span class="hljs-built_in">p1</span>-&gt;next != NULL &amp;&amp; <span class="hljs-built_in">p1</span>-&gt;num != index)<br>        &#123;<br>            <span class="hljs-built_in">p1</span> = <span class="hljs-built_in">p1</span>-&gt;next<span class="hljs-comment">;</span><br>            <span class="hljs-built_in">p2</span> = <span class="hljs-built_in">p1</span><span class="hljs-comment">;</span><br>        &#125;<br>        <span class="hljs-meta">if</span>(<span class="hljs-built_in">p1</span>-&gt;num == index)<br>        &#123;<br>            <span class="hljs-built_in">p3</span> = (struct student *)malloc(LEN)<span class="hljs-comment">;</span><br>            <span class="hljs-built_in">p3</span>-&gt;num = num<span class="hljs-comment">;</span><br>            <span class="hljs-built_in">p3</span>-&gt;score = score<span class="hljs-comment">;</span><br><br>            <span class="hljs-meta">if</span>(<span class="hljs-built_in">p2</span>-&gt;next == NULL)<br>            &#123;<br>                <span class="hljs-built_in">p2</span>-&gt;next = <span class="hljs-built_in">p3</span><span class="hljs-comment">;</span><br>                <span class="hljs-built_in">p3</span>-&gt;next = NULL<span class="hljs-comment">;</span><br>            &#125;<br>            <span class="hljs-meta">else</span><br>            &#123;<br>                <span class="hljs-built_in">p3</span>-&gt;next = <span class="hljs-built_in">p2</span>-&gt;next<span class="hljs-comment">;</span><br>                <span class="hljs-built_in">p2</span>-&gt;next = <span class="hljs-built_in">p3</span><span class="hljs-comment">;   </span><br>            &#125;<br>        &#125;<br>        <span class="hljs-meta">else</span><br>            printf(<span class="hljs-string">&quot;Can not find list index.\n&quot;</span>)<span class="hljs-comment">;</span><br>    &#125;<br>    return head<span class="hljs-comment">;</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C08-files</title>
    <link href="/2021/12/C08-files/"/>
    <url>/2021/12/C08-files/</url>
    
    <content type="html"><![CDATA[<h2 id="C文件读写"><a href="#C文件读写" class="headerlink" title="C文件读写"></a>C文件读写</h2><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>使用 &lt;stdio.h&gt; 头文件中的 fopen() 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：</p><p><code>FILE *fopen(char *filename, char *mode);</code></p><p>filename为文件名（包括文件路径），mode为访问模式，它们都是字符串。</p><p>文件也有不同的类型，按照数据的存储方式可以分为二进制文件和文本文件，它们的操作细节是不同的。最基本的文件打开方式有以下几种：</p><p>|控制读写权限的字符串（必须指明）|</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>“r”</td><td>以“只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败。</td></tr><tr><td>“w”</td><td>以“写入”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。</td></tr><tr><td>“a”</td><td>以“追加”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。</td></tr><tr><td>“r+”</td><td>以“读写”方式打开文件。既可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败。</td></tr><tr><td>“w+”</td><td>以“写入/更新”方式打开文件，相当于w和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。</td></tr><tr><td>“a+”</td><td>以“追加/更新”方式打开文件，相当于a和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。</td></tr><tr><td>控制读写方式的字符串（可以不写）</td><td></td></tr><tr><td>打开方式</td><td>说明</td></tr><tr><td>“t”</td><td>文本文件。如果不写，默认为”t”。</td></tr><tr><td>“b”</td><td>二进制文件。</td></tr></tbody></table><p>读写权限和读写方式可以组合使用，但是必须将读写方式放在读写权限的中间或者尾部（换句话说，不能将读写方式放在读写权限的开头）。例如：</p><p>将读写方式放在读写权限的末尾：”rb”、”wt”、”ab”、”r+b”、”w+t”、”a+t”</p><p>将读写方式放在读写权限的中间：”rb+”、”wt+”、”ab+”</p><p>其中r+和w+看似一样，都是读写，其实还是有几点区别的：</p><p>1.模式r+找不到文件不会自动新建，而w+会；</p><p>2.模式r+打开文件后，不会清除文件原数据，若直接开始写入，只会从起始位置开始进行覆盖，而w+会直接清零后，再开始读写；</p><p>模式的合法性说明：不能用大写，只能是小写，且rb+和r+b都是合法的，但br+和+rb等都是非法的，w和a也是一样的处理；</p><p>模式w的自动新建文件是有条件的，只有对应的路径存在（即文件所在的文件夹存在），文件不存在才会新建，否则是不会新建的，返回NULL</p><p>整体来说，文件打开方式由 r、w、a、t、b、+ 六个字符拼成，各字符的含义是：<br>r(read)：读；w(write)：写；a(append)：追加；t(text)：文本文件；b(binary)：二进制文件；+：读和写</p><p>fopen() 会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个 FILE 类型的结构体变量中，然后将该变量的地址返回。</p><p>FILE 是 &lt;stdio.h&gt; 头文件中的一个结构体，它专门用来保存文件信息。</p><p>如果希望接收 fopen() 的返回值，就需要定义一个 FILE 类型的指针。例如：<br><code>FILE *fp = fopen(&quot;demo.txt&quot;, &quot;r&quot;);</code><br>表示以“只读”方式打开当前目录下的 demo.txt 文件，并使 fp 指向该文件，这样就可以通过 fp 来操作 demo.txt 了。fp 通常被称为文件指针。</p><p><strong>判断文件是否打开成功</strong></p><p>打开文件出错时，fopen() 将返回一个空指针，也就是 NULL，我们可以利用这一点来判断文件是否打开成功，请看下面的代码：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">FILE *fp;<br><span class="hljs-keyword">if</span>( (fp=fopen(<span class="hljs-string">&quot;D:\\demo.txt&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>)) == NULL )&#123;<br>    printf(<span class="hljs-string">&quot;Fail to open file!\n&quot;</span>);<br>    <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-regexp">//</span>退出程序（结束程序）<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们通过判断 fopen() 的返回值是否和 NULL 相等来判断是否打开失败：如果 fopen() 的返回值为 NULL，那么 fp 的值也为 NULL，此时 if 的判断条件成立，表示文件打开失败。</p><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>文件一旦使用完毕，应该用 fclose() 函数把文件关闭，以释放相关资源，避免数据丢失。这个函数实际上会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。</p><p>fclose() 的用法为：<br><code>int fclose(FILE *fp);</code>fp 为文件指针。例如：<code>fclose(fp);</code></p><p>文件正常关闭时，fclose() 的返回值为0，如果关闭文件时发生错误，函数返回 EOF。<br>EOF 是 end of file 的缩写，表示文件末尾，是一个定义在头文件 stdio.h 中的宏，它的值是一个负数，往往是 -1。EOF 不绝对是 -1，也可以是其他负数，这要看编译器的实现。</p><h3 id="读取-amp-写入文件"><a href="#读取-amp-写入文件" class="headerlink" title="读取&amp;写入文件"></a>读取&amp;写入文件</h3><h4 id="fgetc和fputc函数用法详解（以字符形式读写文件）"><a href="#fgetc和fputc函数用法详解（以字符形式读写文件）" class="headerlink" title="fgetc和fputc函数用法详解（以字符形式读写文件）"></a>fgetc和fputc函数用法详解（以字符形式读写文件）</h4><p>以字符形式读写文件时，每次可以从文件中读取一个字符，或者向文件中写入一个字符。主要使用两个函数，分别是 fgetc() 和 fputc()。</p><p><strong>fgetc() 的用法为：</strong></p><p><code>int fgetc (FILE *fp);</code><br>fp 为文件指针。fgetc() 读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回EOF。</p><p>举例：</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">char</span> ch;<br><span class="hljs-attribute">FILE</span> *fp = fopen(<span class="hljs-string">&quot;D:\\demo.txt&quot;</span>, <span class="hljs-string">&quot;r+&quot;</span>);<br><span class="hljs-attribute">ch</span> = fgetc(fp);<br></code></pre></div></td></tr></table></figure><p>表示从D:\demo.txt文件中读取一个字符，并保存到变量 ch 中。</p><p>在文件内部有一个位置指针，用来指向当前读写到的位置，也就是读写到第几个字节。在文件打开时，该指针总是指向文件的第一个字节。使用 fgetc() 函数后，该指针会向后移动一个字节，所以可以连续多次使用 fgetc() 读取多个字符。</p><p><strong>fputc() 的用法为：</strong></p><p><code>int fputc ( int ch, FILE *fp );</code><br>ch 为要写入的字符，fp 为文件指针。fputc() 写入成功时返回写入的字符，失败时返回 EOF，返回值类型为 int 也是为了容纳这个负数。例如：</p><p><code>fputc(&#39;a&#39;, fp);</code>或者<code>char ch = &#39;a&#39;;fputc(ch, fp);</code><br>表示把字符 ‘a’ 写入fp所指向的文件中。</p><p><strong>两点说明</strong></p><ol><li><p>被写入的文件可以用写、读写、追加方式打开，用写或读写方式打开一个已存在的文件时将清除原有的文件内容，并将写入的字符放在文件开头。如需保留原有文件内容，并把写入的字符放在文件末尾，就必须以追加方式打开文件。不管以何种方式打开，被写入的文件若不存在时则创建该文件。</p></li><li><p>每写入一个字符，文件内部位置指针向后移动一个字节。</p></li></ol><p><strong>判断文件读取完毕还是读取出错</strong></p><p>feof() 函数用来判断文件内部指针是否指向了文件末尾，它的原型是：</p><p><code>int feof ( FILE * fp );</code><br>当指向文件末尾时返回非零值，否则返回零值。</p><p>ferror() 函数用来判断文件操作是否出错，它的原型是：</p><p><code>int ferror ( FILE *fp );</code><br>出错时返回非零值，否则返回零值。</p><h4 id="fgets和fputs函数的用法详解（以字符串的形式读写文件）"><a href="#fgets和fputs函数的用法详解（以字符串的形式读写文件）" class="headerlink" title="fgets和fputs函数的用法详解（以字符串的形式读写文件）"></a>fgets和fputs函数的用法详解（以字符串的形式读写文件）</h4><p><strong>fgets() 函数</strong>用来从指定的文件中读取一个字符串，并保存到字符数组中，它的用法为：</p><p><code>char *fgets ( char *str, int n, FILE *fp );</code><br>str 为字符数组，n 为要读取的字符数目，fp 为文件指针。</p><p>返回值：读取成功时返回字符数组首地址，也即 str；读取失败时返回 NULL；如果开始读取时文件内部指针已经指向了文件末尾，那么将读取不到任何字符，也返回 NULL。例如：</p><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta"><span class="hljs-meta">#define N 101</span><br><span class="hljs-built_in">char</span> <span class="hljs-built_in">str</span>[N];<br>FILE *fp = fopen(<span class="hljs-string">&quot;D:\\demo.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>fgets(<span class="hljs-built_in">str</span>, N, fp);<br>表示从 D:\\demo.txt 中读取 <span class="hljs-number">100</span> 个字符，并保存到字符数组 <span class="hljs-built_in">str</span> 中。<br></code></pre></div></td></tr></table></figure><p>注意，读取到的字符串会在末尾自动添加 ‘\0’，n 个字符也包括 ‘\0’。也就是说，实际只读取到了 n-1 个字符，如果希望读取 100 个字符，n 的值应该为 101。</p><p>需要重点说明的是，在读取到 n-1 个字符之前如果出现了换行，或者读到了文件末尾，则读取结束。这就意味着，不管 n 的值多大，fgets() 最多只能读取一行数据，不能跨行。在C语言中，没有按行读取文件的函数，我们可以借助 fgets()，将 n 的值设置地足够大，每次就可以读取到一行数据。</p><p><strong>fputs() 函数</strong>用来向指定的文件写入一个字符串，它的用法为：</p><p><code>int fputs(const char *str, FILE *fp );</code><br>str 为要写入的字符串，fp 为文件指针。写入成功返回非负数，失败返回 EOF。例如：</p><figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">char</span> *<span class="hljs-keyword">str</span> = <span class="hljs-string">&quot;hello world&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-symbol">FILE</span> *<span class="hljs-built_in">fp</span> = fopen(<span class="hljs-string">&quot;D:\\demo.txt&quot;</span>, <span class="hljs-string">&quot;at+&quot;</span>)<span class="hljs-comment">;</span><br><span class="hljs-symbol">fputs</span>(str, <span class="hljs-built_in">fp</span>)<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>表示把字符串 str 写入到 D:\demo.txt 文件中。</p><h4 id="fread和fwrite的用法详解（以数据块的形式读写文件，二进制-I-O-函数）"><a href="#fread和fwrite的用法详解（以数据块的形式读写文件，二进制-I-O-函数）" class="headerlink" title="fread和fwrite的用法详解（以数据块的形式读写文件，二进制 I/O 函数）"></a>fread和fwrite的用法详解（以数据块的形式读写文件，二进制 I/O 函数）</h4><p>对于 Windows 系统，使用 fread() 和 fwrite() 时应该以二进制的形式打开文件，下面两个函数用于二进制输入和输出：</p><p><strong>fread() 函数</strong>用来从指定文件中读取块数据。所谓块数据，也就是若干个字节的数据，可以是一个字符，可以是一个字符串，可以是多行数据，并没有什么限制。fread() 的原型为：</p><p><code>size_t fread ( void *ptr, size_t size, size_t nmemb, FILE *fp );</code></p><p><strong>fwrite() 函数</strong>用来向文件中写入块数据，它的原型为：</p><p><code>size_t fwrite ( void * ptr, size_t size, size_t nmemb, FILE *fp );</code></p><p>对参数的说明：</p><p>ptr 为要写入的数据的头指针，它可以是数组、变量、结构体等。fread() 中的 ptr 用来存放读取到的数据，fwrite() 中的 ptr 用来存放要写入的数据。</p><p>size：表示要被写入的每个元素的大小，以字节为单位。</p><p>nmemb：表示要读写的数据元素的个数。</p><p>fp：表示文件指针，表示往哪里写。</p><p>理论上，每次读写 size*nmemb 个字节的数据。</p><p>size_t 是在 stdio.h 和 stdlib.h 头文件中使用 typedef 定义的数据类型，表示无符号整数，也即非负数，常用来表示数量。</p><p>返回值：返回成功读写的块数，也即 nmemb。如果返回值小于 nmemb：</p><p>对于 fwrite() 来说，肯定发生了写入错误，可以用 ferror() 函数检测。</p><p>对于 fread() 来说，可能读到了文件末尾，可能发生了错误，可以用 ferror() 或 feof() 检测。</p><p>数据写入完毕后，位置指针在文件的末尾，要想读取数据，必须将文件指针移动到文件开头，这要使用rewind(fp);函数。</p><p><strong>实例</strong></p><p>下面的实例演示了 fwrite() 函数的用法。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   FILE *fp;<br>   <span class="hljs-keyword">char</span> str[] = <span class="hljs-string">&quot;This is runoob.com&quot;</span>;<br> <br>   fp = <span class="hljs-built_in">fopen</span>( <span class="hljs-string">&quot;file.txt&quot;</span> , <span class="hljs-string">&quot;w&quot;</span> );<br>   <span class="hljs-built_in">fwrite</span>(str, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(str) , <span class="hljs-number">1</span>, fp );<br> <br>   <span class="hljs-built_in">fclose</span>(fp);<br>  <br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译并运行上面的程序，这将创建一个文件 file.txt，它的内容如下：</p><p><code>This is runoob.com</code></p><p>下面的实例演示了 fread() 函数的用法。</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   FILE *fp;<br>   <span class="hljs-keyword">char</span> c[] = <span class="hljs-string">&quot;This is runoob&quot;</span>;<br>   <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">20</span>];<br> <br>   <span class="hljs-comment">/* 打开文件用于读写 */</span><br>   fp = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>);<br> <br>   <span class="hljs-comment">/* 写入数据到文件 */</span><br>   <span class="hljs-built_in">fwrite</span>(c, <span class="hljs-built_in">strlen</span>(c) + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, fp);<br> <br>   <span class="hljs-comment">/* 查找文件的开头 */</span><br>   <span class="hljs-built_in">fseek</span>(fp, <span class="hljs-number">0</span>, SEEK_SET);<br> <br>   <span class="hljs-comment">/* 读取并显示数据 */</span><br>   <span class="hljs-built_in">fread</span>(buffer, <span class="hljs-built_in">strlen</span>(c)+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, fp);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buffer);<br>   <span class="hljs-built_in">fclose</span>(fp);<br>   <br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译并运行上面的程序，这将创建一个文件 file.txt，然后写入内容 This is runoob。接下来我们使用 fseek() 函数来重置写指针到文件的开头，文件内容如下所示：</p><p><code>This is runoob</code></p><h4 id="fprintf和fscanf的用法详解（格式化读写文件）"><a href="#fprintf和fscanf的用法详解（格式化读写文件）" class="headerlink" title="fprintf和fscanf的用法详解（格式化读写文件）"></a>fprintf和fscanf的用法详解（格式化读写文件）</h4><p>fprintf函数它的原型是：</p><p><code>int fprintf (FILE* stream, const char*format, [argument])</code></p><p>该函数是一个格式化写入文件的库函数，可以看到，除了长得和printf函数很像以外，参数也非常像，多了一个第一个参数，文件指针，即第一步打开文件时得到的文件指针，后面的参数和printf一样，按照指定的格式将数据写入文件。</p><p><strong>返回值</strong></p><p>如果成功，则返回写入的字符总数，否则返回一个负数。</p><p>实例</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   FILE * fp;<br>   fp = <span class="hljs-built_in">fopen</span> (<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>);<br>   <span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;%s %s %d&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-number">111</span>);<br>   <span class="hljs-built_in">fclose</span>(fp);<br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译并运行上面的程序，这将创建文件 file.txt，它的内容如下：</p><p><code>hello world 111</code></p><p>fscanf函数可以从文件里读数据，它的函数原型如下：</p><p><code>int fscanf(FILE *stream, char *format[,argument...]);</code></p><p>作为格式化写数据函数，它的参数同样比scanf也多一个参数，即第一个参数文件指针，表示读取的文件目标，其余参数和scanf一样，按照相应的格式进行读取，返回值表示读取数据的字节数。</p><p><strong>返回值</strong></p><p>如果成功，该函数返回成功匹配和赋值的个数。但是在遇到第一个空格和换行符时，它会停止读取。如果到达文件末尾或发生读错误，则返回 EOF。</p><p>实例</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">char</span> str1[<span class="hljs-number">10</span>], str2[<span class="hljs-number">10</span>];<br>   <span class="hljs-keyword">int</span> num;<br>   FILE * fp;<br><br>   fp = <span class="hljs-built_in">fopen</span> (<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>);<br>   <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;hello world 111&quot;</span>, fp);<br>   <br>   <span class="hljs-built_in">rewind</span>(fp);<br>   <span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%s %s %d&quot;</span>, str1, str2, &amp;num);<br>   <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read String1 |%s|\n&quot;</span>, str1 );<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read String2 |%s|\n&quot;</span>, str2 );<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read Integer |%d|\n&quot;</span>, num );<br><br>   <span class="hljs-built_in">fclose</span>(fp);<br>   <br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译并运行上面的程序，这将产生以下结果：</p><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">Read String1 |<span class="hljs-string">hello</span>|<br>Read String2 |<span class="hljs-string">world</span>|<br>Read Integer |<span class="hljs-string">111</span>|<br></code></pre></div></td></tr></table></figure><h4 id="rewind和fseek函数的用法详解（随机读写文件）"><a href="#rewind和fseek函数的用法详解（随机读写文件）" class="headerlink" title="rewind和fseek函数的用法详解（随机读写文件）"></a>rewind和fseek函数的用法详解（随机读写文件）</h4><p>移动文件内部位置指针的函数主要有两个，即 rewind() 和 fseek()。</p><p>rewind() ，用于将文件指针重新指向文件的开头，同时清除和文件流相关的错误和eof标记，相当于调用<code>fseek(stream, 0, SEEK_SET)</code>，它的原型为：</p><p><code>void rewind ( FILE *stream );</code></p><p>参数</p><p>stream 为指向 FILE 对象（已打开文件）的指针，该 FILE 对象标识流。</p><p>例如，把一个文件的内容显示在屏幕上，并同时复制到另一个文件。</p><figure class="highlight mel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mel">#include <span class="hljs-string">&quot;stdio.h&quot;</span><br>void main()<br>&#123;<br>    FILE *fp1, *fp2;<br>    fp1 = <span class="hljs-keyword">fopen</span>(<span class="hljs-string">&quot;file1.c&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);  <span class="hljs-comment">// 源文件</span><br>    fp2 = <span class="hljs-keyword">fopen</span>(<span class="hljs-string">&quot;file2.c&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);  <span class="hljs-comment">// 复制到file2.c</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">feof</span>(fp1)) putchar(fgetc(fp1));  <span class="hljs-comment">// 显示到屏幕上</span><br>    rewind(fp1);   <span class="hljs-comment">// fp回到开始位置</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">feof</span>(fp1)) fputc(fgetc(fp1), fp2);<br>    <span class="hljs-keyword">fclose</span>(fp1);<br>    <span class="hljs-keyword">fclose</span>(fp2);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>fseek() 用来将位置指针移动到任意位置，它的原型为：</p><p><code>int fseek ( FILE *steam, long offset, int whence );</code></p><p>参数说明：</p><ol><li><p>steam 为文件指针，也就是被移动的文件。</p></li><li><p>offset 为偏移量，也就是要移动的字节数。之所以为 long 类型，是希望移动的范围更大，能处理的文件更大。offset 为正时，向后移动；offset 为负时，向前移动。</p></li><li><p>whence 为起始位置，也就是从何处开始计算偏移量。C语言规定的起始位置有三种，分别为文件开头、当前位置和文件末尾，每个位置都用对应的常量来表示：</p></li></ol><table><thead><tr><th>起始点</th><th>常量名</th><th>常量值</th></tr></thead><tbody><tr><td>文件开头</td><td>SEEK_SET</td><td>0</td></tr><tr><td>当前位置</td><td>SEEK_CUR</td><td>1</td></tr><tr><td>文件末尾</td><td>SEEK_END</td><td>2</td></tr></tbody></table><p>例如，把位置指针移动到离文件开头100个字节处：</p><p><code>fseek(fp, 100, 0);</code></p><p>返回值：如果成功，则该函数返回零，否则返回非零值。</p><p>值得说明的是，fseek() 一般用于二进制文件，在文本文件中由于要进行转换，计算的位置有时会出错。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C07-typedef-preprocessor</title>
    <link href="/2021/12/C07-typedef-preprocessor/"/>
    <url>/2021/12/C07-typedef-preprocessor/</url>
    
    <content type="html"><![CDATA[<h2 id="C-typedef"><a href="#C-typedef" class="headerlink" title="C typedef"></a>C typedef</h2><p>使用关键字 typedef 可以为类型起一个新的别名。typedef 的用法一般为：<br><code>typedef  oldName  newName;</code></p><p>oldName 是类型原来的名字，newName 是类型新的名字。例如：</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">typedef</span> int INTEGER;<br><span class="hljs-attribute">INTEGER</span> a, b;<br><span class="hljs-attribute">a</span> = <span class="hljs-number">1</span>;<br><span class="hljs-attribute">b</span> = <span class="hljs-number">2</span>;<br></code></pre></div></td></tr></table></figure><p>INTEGER a, b;等效于int a, b;。</p><p>typedef 是赋予现有类型一个新的名字，而不是创建新的类型，按照惯例，定义时会大写字母，并且尽量使用含义明确的标识符，以便提醒用户类型名称是一个象征性的缩写。</p><p>typedef 还可以给数组、指针、结构体等类型定义别名。先来看一个给数组类型定义别名的例子：</p><p><code>typedef char ARRAY20[20];</code></p><p>表示 ARRAY20 是类型char [20]的别名。它是一个长度为 20 的数组类型。接着可以用 ARRAY20 定义数组：<br><code>ARRAY20 a1, a2, s1, s2;</code></p><p>它等价于：<br><code>char a1[20], a2[20], s1[20], s2[20];</code></p><p>注意，数组也是有类型的。例如char a1[20];定义了一个数组 a1，它的类型就是 char [20]。</p><p>又如，为结构体类型定义别名：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span>&#123;</span><br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">char</span> sex;<br>&#125; STU;<br></code></pre></div></td></tr></table></figure><p>STU 是 struct stu 的别名，可以用 STU 定义结构体变量：<br><code>STU body1,body2;</code></p><p>它等价于：<br><code>struct stu body1, body2;</code></p><p>再如，为指针类型定义别名：<br><code>typedef int (*PTR_TO_ARR)[4];</code></p><p>表示 PTR_TO_ARR 是类型int * [4]的别名，它是一个二维数组指针类型。接着可以使用 PTR_TO_ARR 定义二维数组指针：<br><code>PTR_TO_ARR p1, p2;</code></p><p>按照类似的写法，还可以为函数指针类型定义别名：<br><code>typedef int (*PTR_TO_FUNC)(int, int);</code><br><code>PTR_TO_FUNC pfunc;</code></p><h3 id="typedef-与-define-比较"><a href="#typedef-与-define-比较" class="headerlink" title="typedef 与 #define 比较"></a>typedef 与 #define 比较</h3><p>（1）typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如可以定义 1 为 ONE。<br>（2）typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的，只是字面上的替换。</p><p>（3）#define可以使用其他类型说明符对宏类型名进行扩展，但对 typedef 所定义的类型名却不能这样做。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INTERGE int;</span><br><span class="hljs-keyword">unsigned</span> INTERGE n;  <span class="hljs-comment">//没问题</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> INTERGE;<br><span class="hljs-keyword">unsigned</span> INTERGE n;  <span class="hljs-comment">//错误，不能在 INTERGE 前面添加 unsigned</span><br></code></pre></div></td></tr></table></figure><p>（4）在连续定义几个变量的时候，typedef 能够保证定义的所有变量均为同一类型，而 #define 则无法保证。例如：</p><figure class="highlight smali"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs smali"><span class="hljs-comment">#define PTR_INT int *</span><br>PTR_INT p1, p2;        //p1、p2 类型不相同，宏展开后变为int *p1, p2;<br>typedef<span class="hljs-built_in"> int </span>* PTR_INT<br>PTR_INT p1, p2;        //p1、p2 类型相同，它们都是指向<span class="hljs-built_in"> int </span>类型的指针。<br></code></pre></div></td></tr></table></figure><p>经过宏替换以后，第二行变为：<br><code>int *p1, p2;</code></p><p>这使得 p1、p2 成为不同的类型：p1 是指向 int 类型的指针，p2 是 int 类型。</p><p>相反，在下面的代码中：</p><figure class="highlight smali"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs smali">typedef<span class="hljs-built_in"> int </span>* PTR_INT<br>PTR_INT p1, p2;<br></code></pre></div></td></tr></table></figure><p>p1、p2 类型相同，它们都是指向 int 类型的指针。</p><p>typedef 还有一个作用，就是为复杂的声明定义一个新的简单的别名。用在回调函数中特别好用：</p><p>原声明：<code>int *(*a[5])(int, char*);</code></p><p>在这里，变量名为 a，直接用一个新别名 pFun 替换 a 就可以了：</p><p><code>typedef int *(*pFun)(int, char*);</code><br>于是，原声明的最简化版：</p><p><code>pFun a[5];</code></p><p>另外也要注意，typedef 在语法上是一个存储类的关键字（如 auto、extern、mutable、static、register 等一样），虽然它并不真正影响对象的存储特性，如：</p><p><code>typedef static int INT2; // 不可行</code><br>编译将失败，会提示“指定了一个以上的存储类”。</p><h2 id="C预处理"><a href="#C预处理" class="headerlink" title="C预处理"></a>C预处理</h2><p>预处理指令是以#号开头的代码行，# 号必须是该行除了任何空白字符外的第一个字符，为了增强可读性，预处理器指令应从第一列开始。# 后是指令关键字，在关键字和 # 号之间允许存在任意个数的空白字符，整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。</p><p>下面列出了所有重要的预处理器指令：</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>#define</td><td>定义宏（宏定义命令）</td></tr><tr><td>#include</td><td>包含一个源代码文件（文件包含命令）</td></tr><tr><td>#undef</td><td>取消已定义的宏</td></tr><tr><td>#ifdef</td><td>如果宏已经定义，则返回真，编译下面代码</td></tr><tr><td>#ifndef</td><td>如果宏没有定义，则返回真，编译下面代码</td></tr><tr><td>#if</td><td>如果给定条件为真，则编译下面代码</td></tr><tr><td>#else</td><td>#if 的替代方案</td></tr><tr><td>#elif</td><td>如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td></tr><tr><td>#endif</td><td>结束一个 #if……#else 条件编译块</td></tr><tr><td>#error</td><td>当遇到标准错误时，输出错误消息</td></tr><tr><td>#pragma</td><td>使用标准化方法，向编译器发布特殊的命令到编译器中</td></tr></tbody></table><h3 id="预处理器实例"><a href="#预处理器实例" class="headerlink" title="预处理器实例"></a>预处理器实例</h3><p>分析下面的实例来理解不同的指令。</p><p><strong>#define</strong></p><p><code>#define MAX_ARRAY_LENGTH 20</code><br>这个指令告诉 CPP 把所有的 MAX_ARRAY_LENGTH 替换为 20。使用 #define 定义常量来增强可读性。</p><p><strong>#include</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;myheader.h&quot;</span></span><br></code></pre></div></td></tr></table></figure><p>这些指令告诉 CPP 从系统库中获取 stdio.h，并添加文本到当前的源文件中。下一行告诉 CPP 从本地目录中获取 myheader.h，并添加内容到当前的源文件中。</p><p>说明：</p><p>#include 的处理过程很简单，就是将头文件的内容插入到该命令所在的位置，从而把头文件和当前源文件连接成一个源文件，这与复制粘贴的效果相同。</p><p>#include 的用法有两种，如下所示：</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdHeader.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;myHeader.h&quot;</span></span><br></code></pre></div></td></tr></table></figure><p>使用尖括号&lt; &gt;和双引号” “的区别在于头文件的搜索路径不同：</p><ul><li>使用尖括号&lt; &gt;，编译器会到系统路径下查找头文件；</li><li>而使用双引号” “，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找。</li></ul><p>像 stdio.h 和 stdlib.h 都是标准头文件，它们存放于系统路径下，所以使用尖括号和双引号都能够成功引入；而我们自己编写的头文件，一般存放于当前项目的路径下，所以不能使用尖括号，只能使用双引号。通常使用尖括号来引入标准头文件，使用双引号来引入自定义头文件（自己编写的头文件），这样一眼就能看出头文件的区别。</p><p>关于 #include 用法的注意事项：</p><ul><li>一个 #include 命令只能包含一个头文件，多个头文件需要多个 #include 命令。</li><li>同一个头文件可以被多次引入，多次引入的效果和一次引入的效果相同，因为头文件在代码层面有防止重复引入的机制。</li><li>文件包含允许嵌套，也就是说在一个被包含的文件中又可以包含另一个文件。</li></ul><p><strong>#undef</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span>  FILE_SIZE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILE_SIZE 42</span><br></code></pre></div></td></tr></table></figure><p>这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42。</p><p><strong>#ifndef</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> MESSAGE</span><br>   <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MESSAGE <span class="hljs-meta-string">&quot;You wish!&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure><p>这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DEBUG</span><br>   <span class="hljs-comment">/* Your debugging statements here */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure><p>这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 -DDEBUG 开关量，这个指令就非常有用。它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。</p><h3 id="define的用法，C语言宏定义"><a href="#define的用法，C语言宏定义" class="headerlink" title="#define的用法，C语言宏定义"></a>#define的用法，C语言宏定义</h3><p>#define 叫做宏定义命令，它也是C语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。在预处理阶段，对程序中所有出现的“宏名”，预处理器都会用宏定义中的字符串去代换，这称为“宏替换”或“宏展开”。</p><p>宏定义是由源程序中的宏定义命令#define完成的，宏替换是由预处理程序完成的。</p><p>宏定义的一般形式为：<br>#define  宏名  定义内容</p><p>#表示这是一条预处理命令，所有的预处理命令都以 # 开头。宏名是标识符的一种，命名规则和变量相同。定义内容可以是数字、表达式、if 语句、函数等。</p><p>对 #define 用法的几点说明</p><ol><li>宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单粗暴的替换。字符串中可以含任何字符，它可以是常数、表达式、if 语句、函数等，预处理程序对它不作任何检查，如有错误，只能在编译已被宏展开后的源程序时发现。</li><li>宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换。</li><li>宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用#undef命令。</li><li>代码中的宏名如果被引号包围，那么预处理程序不对其作宏代替</li><li>宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换。</li><li>习惯上宏名用大写字母表示，以便于与变量区别。但也允许用小写字母。</li><li>可用宏定义表示数据类型，使书写方便。</li></ol><p><strong>带参数的宏定义</strong></p><p>C语言允许宏带有参数。在宏定义中的参数称为“形式参数”，在宏调用中的参数称为“实际参数”，这点和函数有些类似。对带参数的宏，在展开过程中不仅要进行字符串替换，还要用实参去替换形参。</p><p>带参宏定义的一般形式为：<br>#define 宏名(形参列表) 字符串</p><p>在字符串中可以含有各个形参。</p><p>带参宏调用的一般形式为：<br>宏名(实参列表);</p><p>例如：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">#define <span class="hljs-constructor">M(<span class="hljs-params">y</span>)</span> y*y+<span class="hljs-number">3</span>*y  <span class="hljs-comment">//宏定义</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>k=<span class="hljs-constructor">M(5)</span>;  <span class="hljs-comment">//宏调用</span><br></code></pre></div></td></tr></table></figure><p>在宏展开时，用实参 5 去代替形参 y，经预处理程序展开后的语句为<code>k=5*5+3*5</code>。</p><p><strong>对带参宏定义的说明</strong></p><ol><li>带参宏定义中，形参之间可以出现空格，但是宏名和形参列表之间不能有空格出现。</li></ol><p>例如把：<br><code>#define MAX(a,b) (a&gt;b)?a:b</code><br>写为：<br><code>#define MAX  (a,b)  (a&gt;b)?a:b</code><br>将被认为是无参宏定义，宏名 MAX 代表字符串(a,b) (a&gt;b)?a:b。宏展开时，宏调用语句：<br><code>max = MAX(x,y);</code><br>将变为：<br><code>max = (a,b)(a&gt;b)?a:b(x,y);</code><br>这显然是错误的。</p><ol start="2"><li>在带参宏定义中，不会为形式参数分配内存，因此不必指明数据类型。而在宏调用中，实参包含了具体的数据，要用它们去替换形参，因此实参必须要指明数据类型。</li></ol><p>这一点和函数是不同的：在函数中，形参和实参是两个不同的变量，都有自己的作用域，调用时要把实参的值传递给形参；而在带参数的宏中，只是符号的替换，不存在值传递的问题。</p><ol start="3"><li>在宏定义中，字符串内的形参通常要用括号括起来以避免出错。</li></ol><h3 id="预处理器运算符"><a href="#预处理器运算符" class="headerlink" title="预处理器运算符"></a>预处理器运算符</h3><p>C 预处理器提供了下列的运算符来帮助您创建宏：</p><p><strong>宏延续运算符（\）</strong></p><p>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#define  message_for(a, b)  \</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-comment">#a &quot; and &quot; #b &quot;: We love you!\n&quot;)</span><br></code></pre></div></td></tr></table></figure><p><strong>字符串常量化运算符（#）</strong></p><p>在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  message_for(a, b)  \</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-meta">#a <span class="hljs-meta-string">&quot; and &quot;</span> #b <span class="hljs-meta-string">&quot;: We love you!\n&quot;</span>)</span><br><br><span class="hljs-keyword">int</span> <span class="hljs-built_in">main</span>(<span class="hljs-keyword">void</span>)<br>&#123;<br>   <span class="hljs-built_in">message_for</span>(Carole, Debra);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><p><code>Carole and Debra: We love you!</code></p><p><strong>标记粘贴运算符（##）</strong></p><p>宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> tokenpaster(n) printf (<span class="hljs-meta-string">&quot;token&quot;</span> #n <span class="hljs-meta-string">&quot; = %d&quot;</span>, token##n)</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">int</span> token34 = <span class="hljs-number">40</span>;<br>   <br>   <span class="hljs-built_in">tokenpaster</span>(<span class="hljs-number">34</span>);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><p><code>token34 = 40</code><br>这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：</p><p><code>printf (&quot;token34 = %d&quot;, token34);</code><br>这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了字符串常量化运算符（#）和标记粘贴运算符（##）。</p><p><strong>defined() 运算符</strong></p><p>预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined (MESSAGE)</span><br>   <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MESSAGE <span class="hljs-meta-string">&quot;You wish!&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Here is the message: %s\n&quot;</span>, MESSAGE);  <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><p><code>Here is the message: You wish!</code></p><h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p>ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。</p><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td><strong>DATE</strong></td><td>当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。</td></tr><tr><td><strong>TIME</strong></td><td>当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。</td></tr><tr><td><strong>FILE</strong></td><td>这会包含当前文件名，一个字符串常量。</td></tr><tr><td><strong>LINE</strong></td><td>这会包含当前行号，一个十进制常量。</td></tr><tr><td><strong>STDC</strong></td><td>当编译器以 ANSI 标准编译时，则定义为 1。</td></tr></tbody></table><p>实例：</p><figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>main()<br>&#123;<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;File :%s\n&quot;</span>, __FILE_<span class="hljs-number">_</span> );<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Date :%s\n&quot;</span>, __DATE_<span class="hljs-number">_</span> );<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Time :%s\n&quot;</span>, __TIME_<span class="hljs-number">_</span> );<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Line :%d\n&quot;</span>, __LINE_<span class="hljs-number">_</span> );<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;ANSI :%d\n&quot;</span>, __STDC_<span class="hljs-number">_</span> );<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当上面的代码（在文件 test.c 中）被编译和执行时，它会产生下列结果：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">File</span> :test.c<br><span class="hljs-attribute">Date</span> :Jun <span class="hljs-number">2</span> <span class="hljs-number">2012</span><br><span class="hljs-attribute">Time</span> :<span class="hljs-number">03</span>:<span class="hljs-number">36</span>:<span class="hljs-number">24</span><br><span class="hljs-attribute">Line</span> :<span class="hljs-number">8</span><br><span class="hljs-attribute">ANSI</span> :<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><h3 id="if、-ifdef、-ifndef的用法详解，C语言条件编译详解"><a href="#if、-ifdef、-ifndef的用法详解，C语言条件编译详解" class="headerlink" title="#if、##ifdef、#ifndef的用法详解，C语言条件编译详解"></a>#if、##ifdef、#ifndef的用法详解，C语言条件编译详解</h3><p>能够根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。条件编译是预处理程序的功能，不是编译器的功能。</p><p><strong>#if 的用法</strong></p><p>#if 用法的一般格式为：</p><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta">#if 整型常量表达式1</span><br>    程序段<span class="hljs-number">1</span><br><span class="hljs-meta">#elif 整型常量表达式2</span><br>    程序段<span class="hljs-number">2</span><br><span class="hljs-meta">#elif 整型常量表达式3</span><br>    程序段<span class="hljs-number">3</span><br><span class="hljs-meta">#else</span><br>    程序段<span class="hljs-number">4</span><br><span class="hljs-meta">#endif</span><br></code></pre></div></td></tr></table></figure><p>它的意思是：如常“表达式1”的值为真（非0），就对“程序段1”进行编译，否则就计算“表达式2”，结果为真的话就对“程序段2”进行编译，为假的话就继续往下匹配，直到遇到值为真的表达式，或者遇到 #else。这一点和 if else 非常类似。</p><p>需要注意的是，#if 命令要求判断条件为“整型常量表达式”，也就是说，表达式中不能包含变量，而且结果必须是整数；而 if 后面的表达式没有限制，只要符合语法就行。这是 #if 和 if 的一个重要区别。</p><p><strong>#ifdef 的用法</strong></p><p>#ifdef 用法的一般格式为：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span>  宏名</span><br>    程序段<span class="hljs-number">1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    程序段<span class="hljs-number">2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure><p>它的意思是，如果当前的宏已被定义过，则对“程序段1”进行编译，否则对“程序段2”进行编译。<br>#ifdef 可以认为是 #if defined 的缩写。</p><p><strong>#ifndef 的用法</strong></p><p>#ifndef 用法的一般格式为：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> 宏名</span><br>    程序段<span class="hljs-number">1</span> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span> </span><br>    程序段<span class="hljs-number">2</span> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure><p>与 #ifdef 相比，仅仅是将 #ifdef 改为了 #ifndef。它的意思是，如果当前的宏未被定义，则对“程序段1”进行编译，否则对“程序段2”进行编译，这与 #ifdef 的功能正好相反。</p><p><strong>三者之间的区别</strong></p><p>最后需要注意的是，#if 后面跟的是“整型常量表达式”，而 #ifdef 和 #ifndef 后面跟的只能是一个宏名，不能是其他的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C06-struct-union-bitfield</title>
    <link href="/2021/12/C06-struct-union-bitfield/"/>
    <url>/2021/12/C06-struct-union-bitfield/</url>
    
    <content type="html"><![CDATA[<h2 id="C结构体"><a href="#C结构体" class="headerlink" title="C结构体"></a>C结构体</h2><p>在C语言中，可以使用结构体（Struct）来存放一组不同类型的数据。</p><p>结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都称为结构体的成员（Member）。</p><h3 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h3><p>struct 语句的格式如下：</p><figure class="highlight fsharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fsharp"><span class="hljs-keyword">struct</span> tag &#123; <br>    <span class="hljs-keyword">member</span>-list<br>    <span class="hljs-keyword">member</span>-list <br>    <span class="hljs-keyword">member</span>-list  <br>    ...<br>&#125; variable-list ;<br></code></pre></div></td></tr></table></figure><p>tag 是结构体标签。</p><p>member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。</p><p>variable-list 结构变量，定义在结构的末尾，最后一个分号之前，可以指定一个或多个结构变量。下面是声明 Book 结构的方式：</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">struct Books<br>&#123;<br>   char  title<span class="hljs-selector-attr">[50]</span>;<br>   char  author<span class="hljs-selector-attr">[50]</span>;<br>   char  subject<span class="hljs-selector-attr">[100]</span>;<br>   int   book_id;<br>&#125; book;<br></code></pre></div></td></tr></table></figure><p>可以采取以下3种方法定义结构体类型变量：</p><p>（1）先声明结构体类型再定义变量名<br>（2）在声明类型的同时定义变量<br>（3）直接定义结构类型变量</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//结构体的标签被命名为SIMPLE,没有声明变量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SIMPLE</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">double</span> c;<br>&#125;;<br><span class="hljs-comment">//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SIMPLE</span> <span class="hljs-title">t1</span>, <span class="hljs-title">t2</span>[20], *<span class="hljs-title">t3</span>;</span><br><br><span class="hljs-comment">//结构体的标签被命名为SIMPLE并且声明变量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SIMPLE</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">double</span> c;<br>&#125; s1;<br> <br><span class="hljs-comment">//这个结构体并没有标明其标签</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">double</span> c;<br>&#125; s1;<br> <br></code></pre></div></td></tr></table></figure><p>也可以用typedef创建新类型</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">double</span> c; <br>&#125; Simple2;<br><span class="hljs-comment">//现在可以用Simple2作为类型声明新的结构体变量</span><br>Simple2 u1, u2[<span class="hljs-number">20</span>], *u3;<br></code></pre></div></td></tr></table></figure><p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。</p><p>如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">B</span>;    <span class="hljs-comment">//对结构体B进行不完整声明</span><br> <br><span class="hljs-comment">//结构体A中包含指向结构体B的指针</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">A</span><br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">B</span> *partner;<br>    <span class="hljs-comment">//other members;</span><br>&#125;;<br> <br><span class="hljs-comment">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">B</span><br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">A</span> *partner;<br>    <span class="hljs-comment">//other members;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h3><p>为了访问结构的成员，我们使用成员访问运算符（.）。获取结构体成员的一般格式为：</p><p><code>结构体变量名.成员名;</code> 通过这种方式可以获取成员的值，也可以给成员赋值</p><h3 id="结构体内存大小对齐原则"><a href="#结构体内存大小对齐原则" class="headerlink" title="结构体内存大小对齐原则"></a>结构体内存大小对齐原则</h3><ul><li><p>结构体变量的首地址能够被其最宽基本类型成员的大小所整除。</p></li><li><p>结构体每个成员相对于结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)。即结构体成员的末地址减去结构体首地址(第一个结构体成员的首地址)得到的偏移量都要是对应成员大小的整数倍。</p></li><li><p>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在成员末尾加上填充字节。</p></li></ul><p>结构体中成员变量分配的空间是按照成员变量中占用空间最大的来作为分配单位,同样成员变量的存储空间也是不能跨分配单位的,如果当前的空间不足,则会存储到下一个分配单位中。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> a;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>  b;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> c;<br>&#125; <span class="hljs-keyword">debug_size1_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> a;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>  c;<br>&#125; <span class="hljs-keyword">debug_size2_t</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;debug_size1_t size=%lu,debug_size2_t size=%lu\r\n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">debug_size1_t</span>), <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">debug_size2_t</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译执行输出结果：</p><p><code>debug_size1_t size=12,debug_size2_t size=8</code></p><p>结构体占用存储空间,以32位机为例</p><p> 1.debug_size1_t 存储空间分布为a(1byte)+空闲(3byte)+b(4byte)+c(1byte)+空闲(3byte)=12(byte)。<br> 1.debug_size2_t 存储空间分布为a(1byte)+b(1byte)+空闲(2byte)+c(4byte)=8(byte)。</p><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><p>一个结构体变量中可以存放一组数据（如一个学生的学号，姓名，成绩等数据）。如果有10个学生的数据需要参加运算，显然应该用数组，这就是结构体数组。结构体数组与以前介绍过的数据值型数组不同之处在于每个数组元素都一个结构体类型的数据，它们分别包括各个成员（分量）项。</p><p><strong>定义结构体数组</strong><br>和定义结构体变量的方法相仿，只需说明其为数组即可。</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">struct student<br>&#123;<br>    int num<span class="hljs-comment">;</span><br>    char name[<span class="hljs-number">20</span>]<span class="hljs-comment">;</span><br>    char sex<span class="hljs-comment">;</span><br>    int age<span class="hljs-comment">;</span><br>    float score<span class="hljs-comment">;</span><br>    char addr[<span class="hljs-number">30</span>]<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br>struct student stu[<span class="hljs-number">3</span>]<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>以上定义了一个数组 stu，其元素为 struct student 类型数据，数组有 3 个元素。也可以直接定义一个结构体数组。如：</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">struct student<br>&#123;<br>    int num<span class="hljs-comment">;</span><br>    ....<br><br>&#125;stu[<span class="hljs-number">3</span>]<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>或</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">struct<br>&#123;<br>    int num<span class="hljs-comment">;</span><br>    　...<br>&#125;stu[<span class="hljs-number">3</span>]<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p><strong>结构体数组的初始化</strong></p><p>与其它类型数组一样，对结构体数组可以初始化如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> mum;<br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">char</span> sex;<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">float</span> score;<br>    <span class="hljs-keyword">char</span> addr[<span class="hljs-number">30</span>];<br>&#125;stu[<span class="hljs-number">3</span>] = &#123;&#123;<span class="hljs-number">10101</span>,<span class="hljs-string">&quot;Li Lin&quot;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">87.5</span>, <span class="hljs-string">&quot;103 Beijing Road&quot;</span>&#125;,<br>            &#123;<span class="hljs-number">10101</span>,<span class="hljs-string">&quot;Li Lin&quot;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">87.5</span>, <span class="hljs-string">&quot;103 Beijing Road&quot;</span>&#125;,<br>            &#123;<span class="hljs-number">10101</span>,<span class="hljs-string">&quot;Li Lin&quot;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">87.5</span>, <span class="hljs-string">&quot;103 Beijing Road&quot;</span>&#125;&#125;;<br></code></pre></div></td></tr></table></figure><p>定义数组 stu 时，元素个数可以不指定，即写成以下形式：</p><p><code>stu[] = &#123;&#123;...&#125;,&#123;...&#125;,&#123;...&#125;&#125;;</code></p><p>编译时，系统会根据给出初值的结构体常量的个数来确定数组元素的个数。</p><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>当一个指针变量指向结构体时，我们就称它为结构体指针。C语言结构体指针的定义形式一般为：</p><p><code>struct 结构体名 *变量名;</code></p><p>下面是一个定义结构体指针的实例：</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">//结构体</span><br><span class="hljs-keyword">struct</span> stu&#123;<br>    <span class="hljs-built_in">char</span> *name;  <span class="hljs-comment">//姓名</span><br>    <span class="hljs-built_in">int</span> num;  <span class="hljs-comment">//学号</span><br>    <span class="hljs-built_in">int</span> age;  <span class="hljs-comment">//年龄</span><br>    <span class="hljs-built_in">char</span> <span class="hljs-keyword">group</span>;  <span class="hljs-comment">//所在小组</span><br>    <span class="hljs-built_in">float</span> score;  <span class="hljs-comment">//成绩</span><br>&#125; stu1 = &#123; <span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">136.5</span> &#125;;<br><span class="hljs-comment">//结构体指针</span><br><span class="hljs-keyword">struct</span> stu *pstu = &amp;stu1;<br></code></pre></div></td></tr></table></figure><p>一个完整实例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AGE</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> year;<br>    <span class="hljs-keyword">int</span> month;<br>    <span class="hljs-keyword">int</span> day;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">STUDENT</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];  <span class="hljs-comment">//姓名</span><br>    <span class="hljs-keyword">int</span> num;  <span class="hljs-comment">//学号</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AGE</span> <span class="hljs-title">birthday</span>;</span>  <span class="hljs-comment">//生日</span><br>    <span class="hljs-keyword">float</span> score;  <span class="hljs-comment">//分数</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">STUDENT</span> <span class="hljs-title">student1</span>;</span> <span class="hljs-comment">/*用struct STUDENT结构体类型定义结构体变量student1*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">STUDENT</span> *<span class="hljs-title">p</span> =</span> <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">/*定义一个指向struct STUDENT结构体类型的指针变量p*/</span><br>    p = &amp;student1;  <span class="hljs-comment">/*p指向结构体变量student1的首地址, 即第一个成员的地址*/</span><br>    <span class="hljs-built_in">strcpy</span>((*p).name, <span class="hljs-string">&quot;小明&quot;</span>);  <span class="hljs-comment">//(*p).name等价于student1.name</span><br>    (*p).birthday.year = <span class="hljs-number">1989</span>;<br>    (*p).birthday.month = <span class="hljs-number">3</span>;<br>    (*p).birthday.day = <span class="hljs-number">29</span>;<br>    (*p).num = <span class="hljs-number">1207041</span>;<br>    (*p).score = <span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name : %s\n&quot;</span>, (*p).name);  <span class="hljs-comment">//(*p).name不能写成p</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;birthday : %d-%d-%d\n&quot;</span>, (*p).birthday.year, (*p).birthday.month, (*p).birthday.day);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num : %d\n&quot;</span>, (*p).num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;score : %.1f\n&quot;</span>, (*p).score);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出结果是：<br>name : 小明<br>birthday : 1989-3-29<br>num : 1207041<br>score : 100.0</p><p>从该程序可以看出：因为指针变量 p 指向的是结构体变量 student1 第一个成员的地址，即字符数组 name 的首地址，所以 p 和 (*p).name 是等价的。</p><p>但是，“等价”仅仅是说它们表示的是同一个内存单元的地址，但它们的类型是不同的。指针变量 p 是 <code>struct STUDENT*</code> 型的，而 <code>(*p).name</code> 是 char* 型的。所以在 strcpy 中不能将 <code>(*p).name</code> 改成 p。用 %s 进行输入或输出时，输入参数或输出参数也只能写成 (*p).name 而不能写成 p。</p><p>同样，虽然 &amp;student1 和 student1.name 表示的是同一个内存单元的地址，但它们的类型是不同的。&amp;student1 是 <code>struct STUDENT*</code> 型的，而 student1.name 是 char* 型的，所以在对 p 进行初始化时，“p=&amp;student1”不能写成“p=student1.name”。因为 p 是 struct STUDENT* 型的，所以不能将 char* 型的 student1.name 赋给 p。</p><p><strong>获取结构体成员</strong></p><p>通过结构体指针可以获取结构体成员，一般形式为：</p><p><code>(*pointer).memberName</code><br>或者：<br><code>pointer-&gt;memberName</code></p><p>第一种写法中，.的优先级高于<em>，<code>(*pointer)</code>两边的括号不能少。因为成员运算符“.”的优先级高于指针运算符“</em>”，所以如果 *p 两边的括号省略的话，那么 *p.memberName 就等价于 *(p.memberName)，这样意义就完全不对了。</p><p>第二种写法中，-&gt;是一个新的运算符，称为指向运算符，习惯称它为“箭头”，有了它，可以通过结构体指针直接取得结构体成员；这也是-&gt;在C语言中的唯一用途。</p><p>以下 3 种形式是等价的：(1) 结构体变量.成员名。(2) (*指针变量p).成员名。(3) 指针变量p-&gt;成员名。</p><p>如果定义一个结构体指针变量并把结构体数组的数组名赋给这个指针变量的话，就意味着将结构体数组的第一个元素，即第一个结构体变量的地址，也即第一个结构变量中的第一个成员的地址赋给了这个指针变量.</p><p><strong>分析以下几种运算符:</strong></p><p>p -&gt; n 得到 p 指向的结构体变量中的成员 n 的值<br>p -&gt; n ++ 得到 p 指向的结构体变量中的成员 n 的值，用完值后使它加 1<br>++p -&gt; n 得到 p 指向的结构体变量中的成员 n 的值使之加 1 （先加）</p><h3 id="指向结构体数组的指针"><a href="#指向结构体数组的指针" class="headerlink" title="指向结构体数组的指针"></a>指向结构体数组的指针</h3><p>指向结构体数组的指针的应用。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs //实例">#include &lt;stdio.h&gt;<br>#inlcude &lt;stdlib.h&gt;<br> <br>struct student&#123;<br>    int num;<br>    char name[20];<br>    char sex;<br>    int age;<br>&#125;;<br> <br>struct student stu[3] &#x3D; &#123;&#123;10101, &quot;Li Lin&quot;, &#39;M&#39;, 18&#125;,<br>                        　&#123;10102, &quot;Zhang Fun&quot;, &#39;M&#39;, 19&#125;,<br>                        　&#123;10103, &quot;Wang Min&quot;, &#39;F&#39;, 20&#125;&#125;;<br> <br>int main()&#123;<br>    struct student *p;<br>    printf(&quot;No.    name        sex        age\n&quot;);<br>    for(p&#x3D;stu; p&lt;stu+3;p++)<br>        printf(&quot;%5d %-20s %2c %4d\n&quot;, p-&gt;num, p-&gt;name, p-&gt;sex, p-&gt;age);<br>    system(&quot;pause&quot;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">No</span>.    name        sex        age<br><span class="hljs-attribute">10101</span> Li Lin                M       <span class="hljs-number">18</span><br><span class="hljs-attribute">10102</span> Zhang Fun        M       <span class="hljs-number">19</span><br><span class="hljs-attribute">10103</span> Wang Min          F        <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><p>注意以下两点：</p><p>（1）如果 p 的初值为 stu，即指向第一个元素，则 p + 1 后指向下一个元素的起始地址。例如：</p><p>(++p) -&gt; num 先使 p 自加 1 ，然后得到它指向的元素中的 num 成员的值（即10102）。</p><p>(p++) -&gt;num 先得到 p-&gt;num 的值（即10101），然后使 p 自加 1 ，指向 stu[1]。</p><p>注意以上二者的不同。</p><p>（2）程序已定义了指针 p 为指向 struct student 类型数据的变量，它只能指向一个 struct student 型的数据（p 的值是 stu 数组的一个元素的起始地址），而不能指向 stu 数组元素中的某一成员，（即 p 的地址不能是成员地址）。例如，下面是不对的：</p><p><code>p = &amp;stu[1].name</code>编译时将出错。</p><h3 id="用结构体变量和结构体指针作为函数参数"><a href="#用结构体变量和结构体指针作为函数参数" class="headerlink" title="用结构体变量和结构体指针作为函数参数"></a>用结构体变量和结构体指针作为函数参数</h3><p>结构体变量名代表的是整个集合本身，作为函数参数时传递的整个集合，也就是所有成员，而不是像数组一样被编译器转换成一个指针。如果结构体成员较多，尤其是成员为数组时，传送的时间和空间开销会很大，影响程序的运行效率。所以最好的办法就是使用结构体指针，这时由实参传向形参的只是一个地址，非常快速。</p><p>将一个结构体变量的值传递给另一个函数，有3个方法：</p><p>（1）用结构体变量的成员作参数，例如：用 stu[1].num 或 stu[2].name 作函数实参，将实参值传给形参。用法和用普通变量作实参是一样的，属于 <strong>值传递</strong> 方式。应当注意实参与形参的类型保持一致。</p><p>（2）用结构体变量作参数。老版本的C系统不允许用结构体变量作实参，ANSI C取消了这一限制。但是用结构体变量作实参时，采取的是 <strong>值传递</strong> 的方式，将结构体变量所占的内存单元全部顺序传递给形参。形参也必须是同类型的结构体变量。在函数调用期间形参也要占用内存单元。这种传递方式在空间和时间上开销较大，如果结构体的规模很大时，开销是很可观的，此外由于采用值传递方式，如果在执行被调用函数期间改变了形参（也是结构体变量）的值，该值不能返回主调函数，这往往造成使用上的不便。因此一般较少用这种方法。</p><p>（3）用指向结构体变量（或数组）的指针作实参，将结构体变量（或数组）的地址传给形参。</p><p><strong>实例：指向结构体变量的指针作实参</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FORMAT <span class="hljs-meta-string">&quot;%d\n%s\n%f\n%f\n%f\n&quot;</span></span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>&#123;</span><br>    <span class="hljs-keyword">int</span> num;<br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">float</span> score[<span class="hljs-number">3</span>];<br>&#125;stu = &#123;<span class="hljs-number">12345</span>, <span class="hljs-string">&quot;Li Li&quot;</span>, <span class="hljs-number">67.5</span>, <span class="hljs-number">89</span>, <span class="hljs-number">78.6</span>&#125;;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(struct student *p)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(FORMAT, p-&gt;num, p-&gt;name, p-&gt;score[<span class="hljs-number">0</span>], p-&gt;score[<span class="hljs-number">1</span>], p-&gt;score[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">print</span>(&amp;stu);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C共用体"><a href="#C共用体" class="headerlink" title="C共用体"></a>C共用体</h2><p>共用体是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</p><p><strong>共用体定义</strong></p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima"><span class="hljs-built_in">union</span> [<span class="hljs-built_in">union</span> tag]<br>&#123;<br>    <span class="hljs-comment">/*成员列表*/</span><br>   <span class="hljs-built_in">member</span> definition;<br>   <span class="hljs-built_in">member</span> definition;<br>   ...<br>   <span class="hljs-built_in">member</span> definition;<br>&#125; [one <span class="hljs-keyword">or</span> more <span class="hljs-built_in">union</span> variables];<br></code></pre></div></td></tr></table></figure><p>union tag 共用体名是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，可以指定一个或多个共用体变量，这是可选的。</p><p>一个共用体的实例：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran">union <span class="hljs-keyword">Data</span><br>&#123;<br>   <span class="hljs-built_in">int</span> i;<br>   <span class="hljs-built_in">float</span> f;<br>   <span class="hljs-built_in">char</span>  str[<span class="hljs-number">20</span>];<br>&#125; <span class="hljs-keyword">data</span>;<br></code></pre></div></td></tr></table></figure><p>共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。使用成员访问运算符（.）访问共用体的成员。</p><p>结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</p><p>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p><p>共用体可用于判断大小端机：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> str;<br>    <span class="hljs-keyword">int</span> data;<br>&#125;;<br>data=<span class="hljs-number">0x01020304</span>;<br><span class="hljs-keyword">if</span>(str==<span class="hljs-number">0x01</span>)<br>&#123;<br>    cout&lt;&lt; <span class="hljs-string">&quot;此机器是大端！&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str==<span class="hljs-number">0x04</span>)&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;此机器是小端！&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    cout &lt;&lt;<span class="hljs-string">&quot; 暂无法判断此机器类型！&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注：大端机高位存在低位，小端机反之</p><p>一些概念：</p><p>位：”位(bit)”是电子计算机中最小的数据单位。每一位的状态只能是0或1。<br>字节：8个二进制位构成1个”字节(Byte)”，它是存储空间的基本计量单位。1个字节可以储存1个英文字母或者半个汉字，换句话说，1个汉字占据2个字节的存储空间。<br>字：”字”由若干个字节构成，字的位数叫做字长，不同档次的机器有不同的字长。例如一台8位机，它的1个字就等于1个字节，字长为8位。如果是一台16位机，那么，它的1个字就由2个字节构成，字长为16位。字是计算机进行数据处理和运算的单位。<br>一般的计算机都已经到了64位机  也就是说 一个基本单位就是64位，也就是8字节了。这样再综合上面的分析就不难看出，结构体，共用体，位域的定义中，按顺序分配内存，下一个字段所占大小如果超出了上一个字段占的内存单元剩余部分，那么它会重新申请下一个内存单元，而上一个多出部分将空着。</p><p>字节对齐与对齐原则：</p><p> 【原则1】数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。<br> 【原则2】结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。<br> 【原则3】结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。</p><h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>带有预定义宽度的变量被称为位域。所谓”位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。<br>所以位域就是在结构体定义时，指定某个成员变量所占用的二进制位数（Bit）。</p><p>典型的实例：</p><p>用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。<br>读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。</p><p><strong>位域的定义</strong></p><p>位域定义与结构定义相仿，其形式为：</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> 位域结构名 <br>&#123;<br> 位域列表<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>其中位域列表的形式为：<br><code>type [member_name] : width ;</code></p><p>下面是有关位域中变量元素的描述：</p><p>type：只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。<br>member_name：位域的名称。<br>width：位域中位的数量。宽度必须小于或等于指定类型的位宽度。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bs</span>&#123;</span><br>    <span class="hljs-keyword">unsigned</span> m;<br>    <span class="hljs-keyword">unsigned</span> n: <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ch: <span class="hljs-number">6</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>‘:’后面的数字用来限定成员变量占用的位数。成员 m 没有限制，根据数据类型即可推算出它占用 4 个字节（Byte）的内存。成员 n、ch 被:后面的数字限制，不能再根据数据类型计算长度，它们分别占用 4、6 位（Bit）的内存。</p><p>位域的几点说明：</p><p>一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">struct bs&#123;<br>    unsigned <span class="hljs-selector-tag">a</span>:<span class="hljs-number">4</span>;<br>    unsigned  :<span class="hljs-number">4</span>;    <span class="hljs-comment">/* 空域 */</span><br>    unsigned <span class="hljs-selector-tag">b</span>:<span class="hljs-number">4</span>;    <span class="hljs-comment">/* 从下一单元开始存放 */</span><br>    unsigned c:<span class="hljs-number">4</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。</p><p>位域的宽度不能超过它所依附的数据类型的长度，成员变量都是有类型的，这个类型限制了成员变量的最大长度，’: ‘后面的数字不能超过这个长度。</p><p>位域可以是无名位域，这时它只用来作填充或调整位置。因为没有名称，无名的位域是不能使用的。例如：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">struct k&#123;<br>    int <span class="hljs-selector-tag">a</span>:<span class="hljs-number">1</span>;<br>    int  :<span class="hljs-number">2</span>;    <span class="hljs-comment">/* 该 2 位不能使用 */</span><br>    int <span class="hljs-selector-tag">b</span>:<span class="hljs-number">3</span>;<br>    int c:<span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的。</p><p>位域的具体<strong>存储规则</strong>如下：</p><ol><li><p>当相邻成员的类型相同时，如果它们的位宽之和小于类型的 sizeof 大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；如果它们的位宽之和大于类型的 sizeof 大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。</p></li><li><p>当相邻成员的类型不同时，不同的编译器有不同的实现方案，GCC 会压缩存储，而 VC/VS 不会。</p></li><li><p>如果成员之间穿插着非位域成员，那么不会进行压缩。</p></li></ol><p>（1）结构体内存分配原则：</p><p>原则一：结构体中元素按照定义顺序存放到内存中，但并不是紧密排列。从结构体存储的首地址开始 ，每一个元素存入内存中时，它都会认为内存是以自己的宽度来划分空间的，因此元素存放的位置一定会在自己大小的整数倍上开始。</p><p>原则二： 在原则一的基础上，检查计算出的存储单元是否为所有元素中最宽的元素长度的整数倍。若是，则结束；否则，将其补齐为它的整数倍。</p><p>（2）定义位域时，各个成员的类型最好保持一致，比如都用char，或都用int，不要混合使用，这样才能达到节省内存空间的目的。</p><p><strong>位域的使用</strong><br>位域的使用和结构成员的使用相同，其一般形式为：</p><p><code>位域变量名.位域名 或 位域变量名-&gt;位域名</code></p><p>位域允许用各种格式输出。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C05-function-pointer</title>
    <link href="/2021/12/C05-function-pointer/"/>
    <url>/2021/12/C05-function-pointer/</url>
    
    <content type="html"><![CDATA[<h2 id="C函数"><a href="#C函数" class="headerlink" title="C函数"></a>C函数</h2><p>C语言不允许函数嵌套定义，函数名和参数列表一起构成了函数签名。意味着可以出现参数列表不同但是函数名相同的函数。</p><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>由于程序是从上向下执行，所以函数要先声明，后调用。</p><p>函数声明的格式非常简单，相当于去掉函数定义中的函数体，并在最后加上分号;，如下所示：<br><code>dataType  functionName( dataType1 param1, dataType2 param2 ... );</code></p><p>也可以不写形参，只写数据类型：<br><code>dataType  functionName( dataType1, dataType2 ... );</code></p><p>函数声明给出了函数名、返回值类型、参数列表（重点是参数类型）等与该函数有关的信息，称为函数原型（Function Prototype）。函数原型的作用是告诉编译器与该函数有关的信息，让编译器知道函数的存在，以及存在的形式，即使函数暂时没有定义，编译器也知道如何使用它。</p><p>对于多个文件的程序，通常是将函数定义放到源文件（.c文件）中，将函数的声明放到头文件（.h文件）中，使用函数时引入对应的头文件就可以，编译器会在链接阶段找到函数体。</p><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。</p><p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p><p>当调用函数时，有两种向函数传递参数的方式：</p><table><thead><tr><th>调用类型</th><th>描述</th></tr></thead><tbody><tr><td>传值调用</td><td>该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</td></tr><tr><td>引用调用</td><td>通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</td></tr></tbody></table><p>默认情况下，C 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。</p><ol><li>值传递</li></ol><p>向函数传递参数的传值调用方法，把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</p><p>默认情况下，C 语言使用传值调用方法来传递参数。一般来说，这意味着函数内的代码不会改变用于调用函数的实际参数。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> temp;<br>    temp = x;<br>    x = y;<br>    y = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">swap</span>(a, b); <span class="hljs-comment">//调用交换函数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;交换结果为 a = %d, b = %d\n&quot;</span>,a,b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于值传递是单向传递，传递过程中只是改变了形参的数值，并未改变实参的数值，因此并不会改变a和b原有的值。</p><ol start="2"><li>指针传递</li></ol><p>通过引用传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</p><p>传递指针可以让多个函数访问指针所引用的对象，而不用把对象声明为全局可访问。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x, <span class="hljs-keyword">int</span> *y)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x, <span class="hljs-keyword">int</span> *y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> temp;<br>    temp = *x;<br>    *x = *y;<br>    *y = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">swap</span>(&amp;a, &amp;b); <span class="hljs-comment">//调用交换函数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;交换结果为 a = %d, b = %d\n&quot;</span>,a,b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>指针传递过程中，将a和b的地址分别传递给了x和y，在函数体内部改变了a、b所在地址的值，所以交换了a、b的数值。</p><p>另外还有一种方式是引用传递：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> temp;<br>    temp = x;<br>    x = y;<br>    y = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">swap</span>(a, b); <span class="hljs-comment">//调用交换函数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;交换结果为 a = %d, b = %d\n&quot;</span>,a,b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>引用传递中，在调用swap(a, b);时函数会用a、b分别代替x、y，即x、y分别引用了a、b变量，这样函数体中实际参与运算的其实就是实参a、b本身，因此也能达到交换数值的目的。</p><p>注：严格来说，C语言中是没有引用传递，这是C++中语言特性，因此在.c文件中使用引用传递会导致程序编译出错。</p><p>指针传递和引用传递之所以能改变传递参数变量的值，是因为函数改变的不是传递进来的指针本身，而是指针指向的值。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x, <span class="hljs-keyword">int</span> *y)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x, <span class="hljs-keyword">int</span> *y)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-comment">//这里操作的是指针指向的值 而不是指针</span><br>    temp = *x;<br>    *x = *y;<br>    *y = temp;<br><span class="hljs-comment">//   倘若直接交换指针 a、b的值不会交换</span><br><span class="hljs-comment">//    temp = x;</span><br><span class="hljs-comment">//    x = y;</span><br><span class="hljs-comment">//    y = temp;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[] )</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">swap</span>(&amp;a, &amp;b); <span class="hljs-comment">//调用交换函数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;交换结果为 a = %d, b = %d\n&quot;</span>,a,b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>关于 main 函数的参数</strong></p><p>main() 函数是主函数，它可以调用其它函数，而不允许被其它函数调用。因此，C程序的执行总是从 main() 函数开始，完成对其它函数的调用后再返回到 main() 函数，最后由 main() 函数结束整个程序。</p><p>main() 函数可以带参数也可以不带参数，<br>不带参数形式为：<code>int main()</code></p><p>带参形式如下：<br><code>int main( int argc, char *argv[] )</code><br>上面的代码中 main 函数带了参数。<br>argc 和 argv 是 main 函数的形式参数。变量名称argc和argv是常规的名称，当然也可以换成其他名称。</p><p>这两个形式参数的类型是系统规定的。如果 main 函数要带参数，就是这两个类型的参数；否则main函数就没有参数。</p><p><strong>内部函数和外部函数</strong></p><p>根据函数能否被其他源文件调用，将函数区分为内部函数和外部函数。</p><p>内部函数<br>如果一个函数只能被本文件中其他函数所调用，它称为内部函数。在定义内部函数时，在函数名和函数类型的前面加 static，即</p><p>static 类型名 函数名 （形参表）<br>例如，函数的首行：</p><p>static int max(int a,int b)<br>内部函数又称静态函数。使用内部函数，可以使函数的作用域只局限于所在文件。即使在不同的文件中有同名的内部函数，也互不干扰。提高了程序的可靠性。</p><p>外部函数<br>如果在定义函数时，在函数的首部的最左端加关键字 extern，则此函数是外部函数，可供其它文件调用。</p><p>如函数首部可以为</p><p>extern int max (int a,int b)<br>C 语言规定，如果在定义函数时省略 extern，则默认为外部函数。</p><p>在需要调用此函数的其他文件中，需要对此函数作声明（不要忘记，即使在本文件中调用一个函数，也要用函数原型来声明）。在对此函数作声明时，要加关键字 extern，表示该函数是在其他文件中定义的外部函数。</p><p><strong>可变参数</strong></p><p>要使用可变参数，需要引入 stdarg.h 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：</p><ul><li>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</li><li>在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。</li><li>使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。</li><li>使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。</li><li>使用宏 va_end 来清理赋予 va_list 变量的内存。</li></ul><p>下面是一个实例，一个带有可变数量参数的函数，并返回它们的平均值：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">average</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num,...)</span></span>&#123;<br>    va_list valist;<br>    <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">int</span> i;<br> <br>    <span class="hljs-comment">/* 为 num 个参数初始化 valist */</span><br>    <span class="hljs-built_in">va_start</span>(valist, num);<br> <br>    <span class="hljs-comment">/* 访问所有赋给 valist 的参数 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++)<br>    &#123;<br>       sum += <span class="hljs-built_in">va_arg</span>(valist, <span class="hljs-keyword">int</span>);<br>    &#125;<br>    <span class="hljs-comment">/* 清理为 valist 保留的内存 */</span><br>    <span class="hljs-built_in">va_end</span>(valist);<br> <br>    <span class="hljs-keyword">return</span> sum/num;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Average of 2, 3, 4, 5 = %f\n&quot;</span>, <span class="hljs-built_in">average</span>(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Average of 5, 10, 15 = %f\n&quot;</span>, <span class="hljs-built_in">average</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意，函数 average() 最后一个参数写成省略号，即三个点号（…），省略号之前的那个参数是 int，代表了要传递的可变参数的总数。</p><p>当上面的代码被编译和执行时，它会产生下列结果。应该指出的是，函数 average() 被调用两次，每次第一个参数都是表示被传的可变参数的总数。省略号被用来传递可变数量的参数。</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Average</span> of <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> = <span class="hljs-number">3</span>.<span class="hljs-number">500000</span><br><span class="hljs-attribute">Average</span> of <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span> = <span class="hljs-number">10</span>.<span class="hljs-number">000000</span><br></code></pre></div></td></tr></table></figure><p>参数说明：</p><p>va_list: 用来保存宏va_start、va_arg和va_end所需信息的一种类型。为了访问变长参数列表中的参数，必须声明 va_list 类型的一个对象，定义： typedef char * va_list;</p><p>va_start: 访问变长参数列表中的参数之前使用的宏，它初始化用 va_list 声明的对象，初始化结果供宏 va_arg 和 va_end 使用；</p><p>va_arg: 展开成一个表达式的宏，该表达式具有变长参数列表中下一个参数的值和类型。每次调用 va_arg 都会修改用 va_list 声明的对象，从而使该对象指向参数列表中的下一个参数；</p><p>va_end: 该宏使程序能够从变长参数列表用宏 va_start 引用的函数中正常返回。</p><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>内联函数是指用inline关键字修饰的函数。在类内定义的函数被默认成内联函数。内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质。</p><p>内联扩展是用来消除函数调用时的时间开销。它通常用于频繁执行的函数，对于小内存空间的函数非常受益。</p><p>使用内联函数的时候要注意：</p><p>递归函数不能定义为内联函数<br>内联函数一般适合于不存在while和switch等复杂的结构且只有1~5条语句的小函数上，否则编译系统将该函数视为普通函数。<br>内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数。<br>对内联函数不能进行异常的接口声明。</p><p>示例：一个简单的交换函数</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> t = *a;<br>    *a = *b;<br>    *b = t;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C指针"><a href="#C指针" class="headerlink" title="C指针"></a>C指针</h2><p>定义指针变量时必须带<em>，给指针变量赋值时不能带</em>。</p><p>使用指针是间接获取数据（要先通过地址取得指针本身的值，这个值是指针指向变量的地址，然后再通过这个值取得指向变量的数据），使用变量名是直接获取数据，前者比后者的代价要高。</p><h3 id="关于-和-amp-的谜题"><a href="#关于-和-amp-的谜题" class="headerlink" title="关于 * 和 &amp; 的谜题"></a>关于 * 和 &amp; 的谜题</h3><p>假设有一个 int 类型的变量 a，pa 是指向它的指针，那么<code>*&amp;a</code>和<code>&amp;*pa</code>分别是什么意思呢？</p><p><code>*&amp;a</code>可以理解为<code>*(&amp;a)</code>，&amp;a表示取变量 a 的地址（等价于 pa），<code>*(&amp;a)</code>表示取这个地址上的数据（等价于 <code>*pa</code>），绕来绕去，又回到了原点，<code>*&amp;a</code>仍然等价于 a。</p><p><code>&amp;*pa</code>可以理解为<code>&amp;(*pa)</code>，<code>*pa</code>表示取得 pa 指向的数据（等价于 a），<code>&amp;(*pa)</code>表示数据的地址（等价于 &amp;a），所以<code>&amp;*pa</code>等价于 pa。</p><h3 id="对星号-的总结"><a href="#对星号-的总结" class="headerlink" title="对星号*的总结"></a>对星号*的总结</h3><p>目前星号*主要有三种用途：<br>表示乘法，例如int a = 3, b = 5, c;  c = a * b;，这是最容易理解的。<br>表示定义一个指针变量，以和普通变量区分开，例如int a = 100;  int *p = &a;。<br>表示获取指针指向的数据，是一种间接操作，例如int a, b, *p = &a;  *p = 100;  b = *p;。</p><h3 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a>指针的算术运算</h3><p>指针变量保存的是地址，而地址本质上是一个整数，所以指针变量可以进行部分运算，例如加法、减法、比较等，</p><p>指针的每一次递增，它其实会指向下一个元素的存储单元。<br>指针的每一次递减，它都会指向前一个元素的存储单元。<br>指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。</p><p>当对指针变量进行比较运算时，比较的是指针变量本身的值，也就是数据的地址。如果地址相等，那么两个指针就指向同一份数据，否则就指向不同的数据。</p><p>另外需要说明的是，不能对指针变量进行乘法、除法、取余等其他运算，除了会发生语法错误，也没有实际的含义。</p><h3 id="指针数组与数组指针"><a href="#指针数组与数组指针" class="headerlink" title="指针数组与数组指针"></a>指针数组与数组指针</h3><p><strong>空 （NULL） 指针</strong></p><p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。</p><p>NULL 指针是一个定义在标准库中的值为零的常量。</p><p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</p><p>所有指针在创建时都要初始化，如果不知道他指向什么就将 0 赋值给他。必须初始化指针，没有被初始化的指针被称为失控指针(野指针）。</p><p><strong>指针数组</strong></p><p>指针数组：指针数组可以说成是”指针的数组”，首先这个变量是一个数组。</p><p>其次，”指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型，数组中每个元素都指向一个地址。</p><p>在 32 位系统中，指针占四个字节。数组名是一个指向数组中第一个元素的常量指针。</p><p>例：<code>int *a[3]</code>，[] 的优先级高于 * ，所以这是一个数组，而 * 修饰数组，所以是指针数组，数组的元素是整型的指针。</p><p><strong>数组指针</strong></p><p>数组指针：数组指针可以说成是”数组的指针”，首先这个变量是一个指针。</p><p>如果一个指针指向了数组，我们就称它为数组指针（Array Pointer）。</p><p>其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。</p><p>例：<code>int (*a)[3]</code>，同样的方式，首先括号的优先级最高，所以 *a 是指针，而 [] 修饰 *a ，所以是数组指针，一个指向 3 个元素的一维数组指针。</p><p>根据上面的解释，可以了解到指针数组和数组指针的区别，因为二者根本就是两种类型的变量。</p><p>有了数组指针，就有两种方式访问数组元素，一种是使用下标，另外一种是使用指针。</p><ol><li>使用下标<br>也就是采用 arr[i] 的形式访问数组元素。如果 p 是指向数组 arr 的指针，那么也可以使用 p[i] 来访问数组元素，它等价于 arr[i]。</li><li>使用指针<br>也就是使用 *(p+i) 的形式访问数组元素。另外数组名本身也是指针，也可以使用 *(arr+i) 来访问数组元素，它等价于 *(p+i)。</li></ol><p>不管是数组名还是数组指针，都可以使用上面的两种方式来访问数组元素。不同的是，数组名是常量，它的值不能改变，而数组指针是变量（除非特别指明它是常量），它的值可以任意改变。也就是说，数组名只能指向数组的开头，而数组指针可以先指向数组开头，再指向其他元素。</p><p><strong>关于数组指针的谜题</strong></p><p>假设 p 是指向数组 arr 中第 n 个元素的指针，那么 <em>p++、</em>++p、(*p)++ 分别是什么意思呢？</p><p>*p++ 等价于 *(p++)，表示先取得第 n 个元素的值，再将 p 指向下一个元素，上面已经进行了详细讲解。</p><p>*++p 等价于 *(++p)，会先进行 ++p 运算，使得 p 的值增加，指向下一个元素，整体上相当于 *(p+1)，所以会获得第 n+1 个数组元素的值。</p><p>(*p)++ 就非常简单了，会先取得第 n 个元素的值，再对该元素的值加 1。假设 p 指向第 0  个元素，并且第 0 个元素的值为 99，执行完该语句后，第 0  个元素的值就会变为 100。</p><h3 id="字符串指针"><a href="#字符串指针" class="headerlink" title="字符串指针"></a>字符串指针</h3><p>C语言有两种表示字符串的方法，一种是字符数组，另一种是直接使用一个指针指向字符串，即字符串常量。</p><p>两者最根本的区别是在内存中的存储区域不一样，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限。</p><p>内存权限的不同导致的一个明显结果就是，字符数组在定义后可以读取和修改每个字符，而对于第二种形式的字符串，一旦被定义后就只能读取不能修改，任何对它的赋值都是错误的。</p><h3 id="函数指针（指向函数的指针）"><a href="#函数指针（指向函数的指针）" class="headerlink" title="函数指针（指向函数的指针）"></a>函数指针（指向函数的指针）</h3><p>一个函数在编译之后，会占据一部分内存，而它的函数名，就是这段函数的首地址。</p><p>可以把一个指针声明成为一个指向函数的指针。</p><p>C 语言规定函数名会被转换为指向这个函数的指针，除非这个函数名作为 &amp; 操作符或 sizeof 操作符的操作数(注意：函数名用于 sizeof 的操作数是非法的)。也就是说 f = test; 中 test 被自动转换为 &amp;test，而 f = &test; 中已经显示使用了 &amp;test，所以 test 就不会再发生转换了。因此直接引用函数名等效于在函数名上应用 &amp; 运算符，两种方法都会得到指向该函数的指针。</p><p>指向函数的指针必须初始化，或者具有 0 值，才能在函数调用中使用。</p><p>与数组一样：</p><p>（1）禁止对指向函数的指针进行自增运算++<br>（2）禁止对函数名赋值，函数名也不能用于进行算术运算。</p><h3 id="传递指针给函数"><a href="#传递指针给函数" class="headerlink" title="传递指针给函数"></a>传递指针给函数</h3><p>传递指针给函数，只需要简单地声明函数参数为指针类型即可。<br>通过传递指针给函数，可以直接修改原参数（实参），而不是引用实参到形参。</p><p>下面是一个函数指针形式的传递，实质却是地址传递的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> **b)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> **b)</span></span><br><span class="hljs-function"></span>&#123;<br>   (*a)++;<br>   (*b)++;<span class="hljs-comment">//这里虽然传进来的是指针的形式，但其实是指针c的地址，</span><br>          <span class="hljs-comment">//可以认为这里本质还是值传递，只不过这个值是地址值</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;;<br>    <span class="hljs-keyword">int</span> *b = &amp;a[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> *c = a+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> **d = &amp;c;<br>    <br>    <span class="hljs-built_in">func1</span>(b, d);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[0] = %d   a[1] = %d\n&quot;</span>, a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行结果：a[0] = 11 a[1] = 20</p><p>由上可知，虽然传递参数时，是以指针形式进行的，但有时候会发现其实还是值传递，是地址值的传递，特别是在多维数组进行参数传递的时候，特别容易出现这种情况。</p><h3 id="从函数返回指针"><a href="#从函数返回指针" class="headerlink" title="从函数返回指针"></a>从函数返回指针</h3><p>C语言允许函数的返回值是一个指针（地址），这样的函数称为<strong>指针函数</strong>，用指针作为函数返回值时需要注意的一点是，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据，C语言没有任何机制来保证这些数据会一直有效，它们在后续使用过程中可能会引发运行时错误。</p><p>C 不支持在调用函数时返回局部变量的地址，除非定义局部变量为 static 变量。</p><p>因为局部变量是存储在内存的栈区内，当函数调用结束后，局部变量所占的内存地址便被释放了，因此当其函数执行完毕后，函数内的变量便不再拥有那个内存地址，所以不能返回其指针。</p><p>除非将其变量定义为 static 变量，static 变量的值存放在内存中的静态数据区，不会随着函数执行的结束而被清除，故能返回其地址。</p><h3 id="二级指针-指向指针的指针"><a href="#二级指针-指向指针的指针" class="headerlink" title="二级指针(指向指针的指针)"></a>二级指针(指向指针的指针)</h3><p>如果一个指针指向的是另外一个指针，我们就称它为二级指针，或者指向指针的指针。</p><p>当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。</p><h3 id="二维数组指针（指向二维数组的指针）"><a href="#二维数组指针（指向二维数组的指针）" class="headerlink" title="二维数组指针（指向二维数组的指针）"></a>二维数组指针（指向二维数组的指针）</h3><p>对指针进行加法（减法）运算时，它前进（后退）的步长与它指向的数据类型有关，p 指向的数据类型是int [4]，那么p+1就前进 4×4 = 16 个字节，p-1就后退 16 个字节，这正好是数组 a 所包含的每个一维数组的长度。也就是说，p+1会使得指针指向二维数组的下一行，p-1会使得指针指向数组的上一行。</p><ol><li><p>p指向数组 a 的开头，也即第 0 行；p+1前进一行，指向第 1 行。</p></li><li><p>*(p+1)表示取地址上的数据，也就是整个第 1 行数据。注意是一行数据，是多个数据，不是第 1 行中的第 0 个元素</p></li><li><p>*(p+1)+1表示第 1 行第 1 个元素的地址。</p></li></ol><p>*(p+1)单独使用时表示的是第 1 行数据，放在表达式中会被转换为第 1 行数据的首地址，也就是第 1 行第 0 个元素的地址，因为使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针；就像一维数组的名字，在定义时或者和 sizeof、&amp; 一起使用时才表示整个数组，出现在表达式中就会被转换为指向数组第 0 个元素的指针。</p><ol start="4"><li><em>(</em>(p+1)+1)表示第 1 行第 1 个元素的值。很明显，增加一个 * 表示取地址上的数据。</li></ol><p>根据上面的结论，可以很容易推出以下的等价关系：<br>a+i == p+i<br>a[i] == p[i] == *(a+i) == *(p+i)<br>a[i][j] == p[i][j] == *(a[i]+j) == *(p[i]+j) == <em>(</em>(a+i)+j) == <em>(</em>(p+i)+j)</p><h3 id="指针数组和二维数组指针的区别"><a href="#指针数组和二维数组指针的区别" class="headerlink" title="指针数组和二维数组指针的区别"></a>指针数组和二维数组指针的区别</h3><p>指针数组和二维数组指针在定义时非常相似，只是括号的位置不同：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> *(p<span class="hljs-number">1</span>[<span class="hljs-number">5</span>]);  //指针数组，可以去掉括号直接写作 int *p<span class="hljs-number">1</span>[<span class="hljs-number">5</span>];<br><span class="hljs-attribute">int</span> (*p<span class="hljs-number">2</span>)[<span class="hljs-number">5</span>];  //二维数组指针，不能去掉括号<br></code></pre></div></td></tr></table></figure><p>指针数组和二维数组指针有着本质上的区别：指针数组是一个数组，只是每个元素保存的都是指针，以上面的 p1 为例，在32位环境下它占用 4×5 = 20 个字节的内存。二维数组指针是一个指针，它指向一个二维数组，以上面的 p2 为例，它占用 4 个字节的内存。</p><p>常见指针变量的定义<br>定  义    含  义<br>int *p;    p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组。<br>int **p;    p 为二级指针，指向 int * 类型的数据。<br>int *p[n];    p 为指针数组。[ ] 的优先级高于 *，所以应该理解为 int *(p[n]);<br>int (*p)[n];    p 为二维数组指针。<br>int *p();    p 是一个函数，它的返回值类型为 int *。<br>int (*p)();    p 是一个函数指针，指向原型为 int func() 的函数。</p><ol><li><p>指针变量可以进行加减运算，例如p++、p+i、p-=i。指针变量的加减运算并不是简单的加上或减去一个整数，而是跟指针指向的数据类型有关。</p></li><li><p>给指针变量赋值时，要将一份数据的地址赋给它，不能直接赋给一个整数，例如int *p = 1000;是没有意义的，使用过程中一般会导致程序崩溃。</p></li><li><p>使用指针变量之前一定要初始化，否则就不能确定指针指向哪里，如果它指向的内存没有使用权限，程序就崩溃了。对于暂时没有指向的指针，建议赋值NULL。</p></li><li><p>两个指针变量可以相减。如果两个指针变量指向同一个数组中的某个元素，那么相减的结果就是两个指针之间相差的元素个数。</p></li><li><p>数组也是有类型的，数组名的本意是表示一组类型相同的数据。在定义数组时，或者和 sizeof、&amp; 运算符一起使用时数组名才表示整个数组，表达式中的数组名会被转换为一个指向数组的指针。</p></li></ol><p><a href="https://www.runoob.com/w3cnote/c-pointer-detail.html">https://www.runoob.com/w3cnote/c-pointer-detail.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C04-array-string</title>
    <link href="/2021/12/C04-array-string/"/>
    <url>/2021/12/C04-array-string/</url>
    
    <content type="html"><![CDATA[<h2 id="C数组"><a href="#C数组" class="headerlink" title="C数组"></a>C数组</h2><ol><li><p>数组中每个元素的数据类型必须相同，对于<code>int a[4];</code>，每个元素都必须为 int类型。</p></li><li><p>数组长度 length 最好是整数或者常量表达式，例如 10、20*4 等，这样在所有编译器下都能运行通过</p></li><li><p>访问数组元素时，下标的取值范围为 0 ≤ index &lt; length，过大或过小都会越界，导致数组溢出，发生不可预测的情况</p></li></ol><p>数组内存是连续的。连续的内存为指针操作（通过指针来访问数组元素）和内存处理（整块内存的复制、写入等）提供了便利，这使得数组可以作为缓存（临时存储数据的一块内存）使用。</p><p>在我们没有明确数组的元素个数时，在程序中想知道数组单元个数可以使用 sizeof(a)/sizeof(a[0]), sizeof(a) 是得到数组 a 的大小，sizeof(a[0]) 是得到数组 a 中单个元素的大小（因此可以不必要是a[0],a[i]都行），例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *grgv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">int</span> b;<br>    b=<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a)/<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;数组元素个数为：%d&quot;</span>,b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><p>可以先定义数组再给数组赋值，也可以在定义数组的同时赋值，例如：<br><code>int a[4] = &#123;20, 345, 700, 22&#125;;</code><br>数组元素的值由’{ }’包围，各个值之间以’,’分隔。</p><p>对于数组的初始化需要注意以下几点：</p><ol><li>可以只给部分元素赋值。当{ }中值的个数少于元素个数时，只给前面部分元素赋值。例如：<br><code>int a[10]=&#123;12, 19, 22 , 993, 344&#125;;</code><br>表示只给 a[0]~a[4] 5个元素赋值，而后面 5 个元素自动初始化为 0。</li></ol><p>当赋值的元素少于数组总体元素的时候，剩余的元素自动初始化为 0：<br>对于short、int、long，就是整数 0；<br>对于char，就是字符 ‘\0’；<br>对于float、double，就是小数 0.0。</p><p>我们可以通过下面的形式将数组的所有元素初始化为 0：<br><code>int nums[10] = &#123;0&#125;;</code><br><code>char str[10] = &#123;0&#125;;</code><br><code>float scores[10] = &#123;0.0&#125;;</code><br>由于剩余的元素会自动初始化为 0，所以只需要给第 0 个元素赋值为 0 即可。</p><ol start="2"><li><p>只能给元素逐个赋值，不能给数组整体赋值。例如给 10 个元素全部赋值为 1，只能写作：<br><code>int a[10] = &#123;1, 1, 1, 1, 1, 1, 1, 1, 1, 1&#125;;</code><br>而不能写作：<br><code>int a[10] = 1;</code></p></li><li><p>如给全部元素赋值，那么在定义数组时可以不给出数组长度。例如：<br><code>int a[] = &#123;1, 2, 3, 4, 5&#125;;</code><br>等价于<br><code>int a[5] = &#123;1, 2, 3, 4, 5&#125;;</code></p></li><li><p>如果省略掉数组的大小，数组的大小则为初始化时元素的个数。例如：<br><code>int a[] = &#123;1, 2, 3&#125;;</code>得到一个有三个元素的数组</p></li></ol><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p><strong>对于二维数组的初始化要注意以下几点</strong>：</p><ol><li>可以只对部分元素赋值，未赋值的元素自动取“零”值。例如：<br><code>int a[3][3] = &#123;&#123;1&#125;, &#123;2&#125;, &#123;3&#125;&#125;;</code><br>是对每一行的第一列元素赋值，未赋值的元素的值为 0。赋值后各元素的值为：<br>1  0  0<br>2  0  0<br>3  0  0</li></ol><p>再如：<br><code>int a[3][3] = &#123;&#123;0,1&#125;, &#123;0,0,2&#125;, &#123;3&#125;&#125;;</code><br>赋值后各元素的值为：<br>0  1  0<br>0  0  2<br>3  0  0</p><ol start="2"><li><p>如果对全部元素赋值，那么第一维的长度可以不给出。例如：<br><code>int a[3][3] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;</code><br>可以写为：<br><code>int a[][3] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;</code></p></li><li><p>二维数组可以看作是由一维数组嵌套而成的；如果一个数组的每个元素又是一个数组，那么它就是二维数组。当然，前提是各个元素的类型必须相同。根据这样的分析，一个二维数组也可以分解为多个一维数组，C语言允许这种分解。</p></li></ol><p>例如，二维数组a[3][4]可分解为三个一维数组，它们的数组名分别为 a[0]、a[1]、a[2]。</p><p>这三个一维数组可以直接拿来使用。这三个一维数组都有 4 个元素，比如，一维数组 a[0] 的元素为 a[0][0]、a[0][1]、a[0][2]、a[0][3]。</p><p>二维数组在逻辑上是方阵，由行和列组成。</p><p>但是二维数组在物理上是线性的，按行来依次进行存放，内存是连续的。</p><p>二维数组名即首行的地址，C 语言中的地址一般均是空间首地址。故二维数组名是首行首地址，该数组名加 1 表示跳过一整行，到达第二行的首地址，以此类推。</p><p>二维数组名加 1 表示跳过一个对象（一行）的空间，为下一个对象（下一行）的地址。即跳过一个对象所有属性（一行中所有列元素）对应的空间，到达下一个对象（下一行）的起始位置。</p><h3 id="传递数组给函数"><a href="#传递数组给函数" class="headerlink" title="传递数组给函数"></a>传递数组给函数</h3><p>有三种方式可以向函数传递数组</p><p>方式 1<br>形式参数是一个指针（您可以在下一章中学习到有关指针的知识）：</p><p><code>void myFunction(int *param)&#123;&#125;</code></p><p>方式 2<br>形式参数是一个已定义大小的数组：</p><p><code>void myFunction(int param[10])&#123;...&#125;</code></p><p>方式 3<br>形式参数是一个未定义大小的数组：</p><p><code>void myFunction(int param[])&#123;...&#125;</code></p><p><strong>二维数组传递给函数</strong></p><p>方法1: 第一维的长度可以不指定，但必须指定第二维的长度：</p><p><code>void print_a(int a[][5], int n, int m)</code><br>方法2: 指向一个有5个元素一维数组的指针：</p><p><code>void print_b(int (*a)[5], int n, int m)</code><br>方法3: 利用数组是顺序存储的特性,通过降维来访问原数组!</p><p><code>void print_c(int *a, int n, int m)</code></p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section">#include <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">stdio.h</span>&gt;</span></span></span><br>/<span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-emphasis">*</span><br><span class="hljs-emphasis">*</span> 方法1: 第一维的长度可以不指定<br><span class="hljs-bullet">*</span>        但必须指定第二维的长度<br><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-emphasis">*/ </span><br><span class="hljs-emphasis">void print_a(int a[][5], int n, int m)&#123; </span><br><span class="hljs-emphasis">    int i, j;</span><br><span class="hljs-emphasis">    for(i = 0; i &lt; n; i++) &#123;</span><br><span class="hljs-emphasis">        for(j = 0; j &lt; m; j++) </span><br><span class="hljs-emphasis">            printf(&quot;%d &quot;, a[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]); </span><br><span class="hljs-emphasis">        printf(&quot;\n&quot;); </span><br><span class="hljs-emphasis">    &#125; </span><br><span class="hljs-emphasis">&#125; </span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">/<span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*</span> <br><span class="hljs-bullet">*</span> 方法2: 指向一个有5个元素一维数组的指针<br><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-emphasis">*/ </span><br><span class="hljs-emphasis">void print_b(int (*</span>a)[5], int n, int m) &#123; <br><span class="hljs-code">    int i, j;</span><br><span class="hljs-code">    for(i = 0; i &lt; n; i++) &#123; </span><br><span class="hljs-code">        for(j = 0; j &lt; m; j++) </span><br><span class="hljs-code">            printf(&quot;%d &quot;, a[i][j]);</span><br><span class="hljs-code">        printf(&quot;\n&quot;); </span><br><span class="hljs-code">    &#125; </span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code"></span><br><span class="hljs-code">/*********************************** </span><br><span class="hljs-code">* 方法3: 利用数组是顺序存储的特性, </span><br><span class="hljs-code">*       通过降维来访问原数组!</span><br><span class="hljs-code">***********************************/ </span><br><span class="hljs-code">void print_c(int *a, int n, int m) &#123; </span><br><span class="hljs-code">    int i, j; </span><br><span class="hljs-code">    for(i = 0; i &lt; n; i++) &#123; </span><br><span class="hljs-code">        for(j = 0; j &lt; m; j++) </span><br><span class="hljs-code">            printf(&quot;%d &quot;, *(a + i*m + j));</span><br><span class="hljs-code">        printf(&quot;\n&quot;); </span><br><span class="hljs-code">    &#125; </span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code">int main(void) </span><br><span class="hljs-code">&#123; </span><br><span class="hljs-code">    int a[5][5] = &#123;&#123;1, 2&#125;, &#123;3, 4, 5&#125;, &#123;6&#125;, &#123;7&#125;, &#123;0, 8&#125;&#125;; </span><br><span class="hljs-code"></span><br><span class="hljs-code">    printf(&quot;\n方法1:\n&quot;);   </span><br><span class="hljs-code">    print_a(a, 5, 5); </span><br><span class="hljs-code"></span><br><span class="hljs-code">    printf(&quot;\n方法2:\n&quot;);   </span><br><span class="hljs-code">    print_b(a, 5, 5);   </span><br><span class="hljs-code"></span><br><span class="hljs-code">    printf(&quot;\n方法3:\n&quot;);   </span><br><span class="hljs-code">    print_c(&amp;a[0][0], 5, 5); </span><br><span class="hljs-code"></span><br><span class="hljs-code">//    getch(); </span><br><span class="hljs-code">    return 0; </span><br><span class="hljs-code">&#125; </span><br></code></pre></div></td></tr></table></figure><h3 id="从函数返回数组"><a href="#从函数返回数组" class="headerlink" title="从函数返回数组"></a>从函数返回数组</h3><p>C 语言不允许返回一个完整的数组作为函数的参数。但是可以通过指定不带索引的数组名来返回一个指向数组的指针。<br>如果想要从函数返回一个一维数组，必须先声明一个返回指针的函数，如下：</p><p><code>int * myFunction()&#123;...&#125;</code></p><p>另外，C 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。</p><p>下面的函数，它会生成 10 个随机数，并使用数组来返回它们</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br> <br><span class="hljs-comment">/* 要生成和返回随机数的函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> * <span class="hljs-title">getRandom</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>  r[<span class="hljs-number">10</span>];<br>  <span class="hljs-keyword">int</span> i;<br> <br>  <span class="hljs-comment">/* 设置种子 */</span><br>  <span class="hljs-built_in">srand</span>( (<span class="hljs-keyword">unsigned</span>)<span class="hljs-built_in">time</span>( <span class="hljs-literal">NULL</span> ) );<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>  &#123;<br>     r[i] = <span class="hljs-built_in">rand</span>();<br>     <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;r[%d] = %d\n&quot;</span>, i, r[i]);<br> <br>  &#125;<br> <br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br> <br><span class="hljs-comment">/* 要调用上面定义函数的主函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">/* 一个指向整数的指针 */</span><br>   <span class="hljs-keyword">int</span> *p;<br>   <span class="hljs-keyword">int</span> i;<br> <br>   p = <span class="hljs-built_in">getRandom</span>();<br>   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ )<br>   &#123;<br>       <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;*(p + %d) : %d\n&quot;</span>, i, *(p + i));<br>   &#125;<br> <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>srand((unsigned)time(NULL))是初始化随机函数种子：</p><p> 1、是拿当前系统时间作为种子，由于时间是变化的，种子变化，可以产生不相同的随机数。计算机中的随机数实际上都不是真正的随机数，如果两次给的种子一样，是会生成同样的随机序列的。 所以，一般都会以当前的时间作为种子来生成随机数，这样更加的随机。<br> 2、使用时，参数可以是unsigned型的任意数据，比如srand（10）；<br> 3、如果不使用srand，用rand（）产生的随机数，在多次运行，结果是一样的。</p><h2 id="C字符串"><a href="#C字符串" class="headerlink" title="C字符串"></a>C字符串</h2><p>用来存放字符的数组称为字符数组，例如：</p><p><code>char str[6] = &#123;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;&#125;;</code></p><p>C语言规定，可以将字符串直接赋值给字符数组，例如：</p><p><code>char str[10] = &#123;&quot;Hello&quot;&#125;;</code><br><code>char str[10] = &quot;Hello&quot;; </code></p><p>为了方便，也可以不指定数组长度：</p><p><code>char str[] = &#123;&quot;Hello&quot;&#125;;</code><br><code>char str[] = &quot;Hello&quot;;</code></p><p>在C语言中，字符串总是以’\0’作为结尾，所以’\0’也被称为字符串结束标志，或者字符串结束符。</p><p>‘\0’是 ASCII 码表中的第 0 个字符，英文称为 NUL，中文称为“空字符”。该字符既不能显示，也没有控制功能，输出该字符不会有任何效果，它在C语言中唯一的作用就是作为字符串结束标志。</p><p>用” “包围的字符串会自动在末尾添加’\0’，但逐个字符地给数组赋值并不会自动添加’\0’。</p><p>如果没有在字符数组最后增加 \0 的话输出结果有误：</p><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta"><span class="hljs-comment">// 初始化字符串</span><br><span class="hljs-built_in">char</span> <span class="hljs-built_in">str</span>[<span class="hljs-number">5</span>] = &#123; <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span> &#125;;<br>printf(<span class="hljs-string">&quot;Greeting message: %s\n&quot;</span>, <span class="hljs-built_in">str</span>);<br></code></pre></div></td></tr></table></figure><p>输出结果:</p><p><code>Greeting message: Hello烫烫烫?侵7(?╔?╚╔╔</code></p><p>可以手动在初始化字符串之后加上’\0’，也可以这样做：</p><p><code>char str[30] = &#123;0&#125;;  //将所有元素都初始化为 0，或者说 &#39;\0&#39;</code>，然后再给字符串数组赋值。</p><h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><p>所谓字符串长度，就是字符串包含了多少个字符（不包括最后的结束符’\0’）。例如”abc”的长度是 3，而不是 4。</p><p>sizeof 计算的是变量的大小；strlen 返回的是该字符串的长度，遇到 \0 结束，\0 本身不计算在内；前者不受字符 \0 影响，后者以 \0 作为长度判定依据。</p><p>在C语言中，我们使用string.h头文件中的 strlen() 函数来求字符串的长度，它的用法为：<br><code>length strlen(strname);</code></p><p>strname 是字符串的名字，或者字符数组的名字；length 是使用 strlen() 后得到的字符串长度，是一个整数。</p><p>下面是一个输出str字符串长度的例子</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span>  <span class="hljs-comment">//记得引入该头文件</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">char</span> str[] = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    <span class="hljs-keyword">long</span> len = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The lenth of the string is %ld.\n&quot;</span>, len);<br>   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="字符串的输入和输出"><a href="#字符串的输入和输出" class="headerlink" title="字符串的输入和输出"></a>字符串的输入和输出</h3><p><strong>字符串的输出</strong></p><p>在C语言中，有两个函数可以在控制台上输出字符串，它们分别是：<br>puts()：输出字符串并自动换行，该函数只能输出字符串。<br>printf()：通过格式控制符%s输出字符串，不能自动换行。除了字符串，printf() 还能输出其他类型的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">char</span> str[] = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);  <span class="hljs-comment">//通过字符串名字输出</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;hello world&quot;</span>);  <span class="hljs-comment">//直接输出</span><br>    <span class="hljs-built_in">puts</span>(str);  <span class="hljs-comment">//通过字符串名字输出</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;hello world&quot;</span>);  <span class="hljs-comment">//直接输出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>字符串的输入</strong></p><p>在C语言中，有两个函数可以让用户从键盘上输入字符串，它们分别是：<br>scanf()：通过格式控制符%s输入字符串。除了字符串，scanf() 还能输入其他类型的数据。<br>gets()：直接输入字符串，并且只能输入字符串。</p><p>但是，scanf() 和 gets() 是有区别的：<br>scanf() 读取字符串时以空格为分隔，遇到空格就认为当前字符串结束了，所以无法读取含有空格的字符串。<br>gets() 认为空格也是字符串的一部分，只有遇到回车键时才认为字符串输入结束，所以，不管输入了多少个空格，只要不按下回车键，对 gets() 来说就是一个完整的字符串。换句话说，gets() 用来读取一整行字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">char</span> str1[<span class="hljs-number">30</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">char</span> str2[<span class="hljs-number">30</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">char</span> str3[<span class="hljs-number">30</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">//gets() 用法</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input a string: &quot;</span>);<br>    <span class="hljs-built_in">gets</span>(str1);<br>    <span class="hljs-comment">//scanf() 用法</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input a string: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str2);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str3);<br>   <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nstr1: %s\n&quot;</span>, str1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str2: %s\n&quot;</span>, str2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str3: %s\n&quot;</span>, str3);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="常用的操作字符串函数"><a href="#常用的操作字符串函数" class="headerlink" title="常用的操作字符串函数"></a>常用的操作字符串函数</h3><p>序号    函数 &amp; 目的<br>1    strcpy(s1, s2);<br>复制字符串 s2 到字符串 s1，strcpy() 会把 s2 中的字符串拷贝到 s1 中，字符串结束标志’\0’也一同拷贝，将 s2 复制到 s1 后，s1 中原来的内容就被覆盖了。另外，strcpy() 要求 s1 要有足够的长度，否则不能全部装入所拷贝的字符串。<br>2    strcat(s1, s2);<br>连接字符串 s2 到字符串 s1 的末尾，strcat() 将把 s2 连接到 s1 后面，并删除原来 s1 最后的结束标志’\0’。所以 s1 必须足够长，要能够同时容纳 s1 和 s2，否则会越界（超出范围）。<br>strcat() 的返回值为 s1 的地址。<br>3    strlen(s1);<br>返回字符串 s1 的长度。<br>4    strcmp(s1, s2);<br>返回值：如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。<br>5    strchr(s1, ch);<br>返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。<br>6    strstr(s1, s2);<br>返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C03-input-output-if-for</title>
    <link href="/2021/12/C03-input-output-if-for/"/>
    <url>/2021/12/C03-input-output-if-for/</url>
    
    <content type="html"><![CDATA[<h2 id="C-输入-amp-输出"><a href="#C-输入-amp-输出" class="headerlink" title="C 输入 &amp; 输出"></a>C 输入 &amp; 输出</h2><p><strong>输出函数</strong>：</p><p>puts()：只能输出字符串，并且输出结束后会自动换行。<br>putchar()：只能输出单个字符。<br>printf()：可以输出各种类型的数据。</p><p><strong>输入函数</strong>：</p><p>scanf()：和 printf() 类似，scanf() 可以输入多种类型的数据。<br>getchar()、getche()、getch()：这三个函数都用于输入单个字符。<br>gets()：获取一行数据，并作为字符串处理。</p><h3 id="getchar-amp-putchar-函数"><a href="#getchar-amp-putchar-函数" class="headerlink" title="getchar() &amp; putchar() 函数"></a>getchar() &amp; putchar() 函数</h3><p>int getchar(void) 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。在循环内使用这个方法，可以从屏幕上读取多个字符。</p><p>int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。在循环内使用这个方法，可以在屏幕上输出多个字符。</p><p>实例</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">int</span> c;<br> <br>   <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Enter a value :&quot;</span>);<br>   c = <span class="hljs-built_in">getchar</span>( );<br> <br>   <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;\nYou entered: &quot;</span>);<br>   <span class="hljs-built_in">putchar</span>( c );<br>   <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;\n&quot;</span>);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当输入一个文本并按下回车键时，程序会继续并只会读取一个单一的字符，显示如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">$./<span class="hljs-selector-tag">a</span>.out<br>Enter <span class="hljs-selector-tag">a</span> value :hello<br><br>You entered: h<br></code></pre></div></td></tr></table></figure><p>其他输入单个字符的函数：</p><p>（1）getche()<br>getche() 没有缓冲区，输入一个字符后会立即读取，不用等待用户按下回车键，这是它和 scanf()、getchar() 的最大区别。</p><p>注意，getche() 位于 conio.h 头文件中，而这个头文件是 Windows 特有的，Linux 和 Mac OS 下没有包含该头文件。换句话说，getche() 并不是标准函数，默认只能在 Windows 下使用，不能在 Linux 和 Mac OS 下使用。</p><p>（2）getch()<br>getch() 也没有缓冲区，输入一个字符后会立即读取，不用按下回车键，这一点和 getche() 相同。getch() 的特别之处是它没有回显，看不到输入的字符。所谓回显，就是在控制台上显示出用户输入的字符；没有回显，就不会显示用户输入的字符，就好像根本没有输入一样。（在某些特殊情况下，不希望有回显，比如输入密码时）</p><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> c = <span class="hljs-built_in">getch</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c: %c\n&quot;</span>, c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输入一个字符后，getch() 会立即读取完毕，接着继续执行 printf() 将字符输出。但是由于 getch() 没有回显，看不到输入的字符，所以控制台上最终显示的内容为c: 所输入的字符（如：a）。</p><p>注意，和 getche() 一样，getch() 也位于 conio.h 头文件中，也不是标准函数，默认只能在 Windows 下使用，不能在 Linux 和 Mac OS 下使用。</p><p>三个输入字符函数对比：</p><p>函数    缓冲区    头文件    回显    适用平台<br>getchar()    有    stdio.h    有    Windows、Linux、Mac OS 等所有平台<br>getche()    无    conio.h    有    Windows<br>getch()    无    conio.h    无    Windows</p><h3 id="gets-amp-puts-函数"><a href="#gets-amp-puts-函数" class="headerlink" title="gets() &amp; puts() 函数"></a>gets() &amp; puts() 函数</h3><p>char *gets(char *s) 函数从 stdin（标准输入） 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。</p><p>int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout（标准输出）。</p><p>实例</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">char</span> str[<span class="hljs-number">100</span>];<br> <br>   <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Enter a value :&quot;</span>);<br>   <span class="hljs-built_in">gets</span>( str );<br> <br>   <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;\nYou entered: &quot;</span>);<br>   <span class="hljs-built_in">puts</span>( str );<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当上面的代码被编译和执行时，它会等待用户输入一些文本，当输入一个文本并按下回车键时，程序会继续并读取一整行直到该行结束，显示如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">$./<span class="hljs-selector-tag">a</span>.out<br>Enter <span class="hljs-selector-tag">a</span> value :hello<br><br>You entered: hello<br></code></pre></div></td></tr></table></figure><p>注意：gets函数由于没有指定输入字符大小，所以会无限读取，一旦输入的字符大于数组长度，就会发生内存越界，从而造成程序崩溃或其他数据的错误。</p><p>gets() 是有缓冲区的，每次按下回车键，就代表当前输入结束了，gets() 开始从缓冲区中读取内容，这一点和 scanf() 是一样的。gets() 和 scanf() 的主要区别是：</p><p>scanf() 读取字符串时以空格为分隔，遇到空格就认为当前字符串结束了，所以无法读取含有空格的字符串。<br>gets() 认为空格也是字符串的一部分，只有遇到回车键时才认为字符串输入结束，所以，不管输入了多少个空格，只要不按下回车键，对 gets() 来说就是一个完整的字符串。</p><p>也就是说，gets() 能读取含有空格的字符串，而 scanf() 不能。</p><p>另外在linux系统下不支持 gets 与 puts, 需要用 fgets 和 fputs。</p><p><strong>gets()与fgets()</strong><br><strong>gets()</strong><br>gets函数原型：char<em>gets(char</em>buffer);//读取字符到数组：gets(str);str为数组名。</p><p>gets函数功能：从键盘上输入字符，直至接受到换行符或EOF时停止，并将读取的结果存放在buffer指针所指向的字符数组中。</p><p>读取的换行符被转换为null值，做为字符数组的最后一个字符，来结束字符串。</p><p>注意：gets函数由于没有指定输入字符大小，所以会无限读取，一旦输入的字符大于数组长度，就会发生内存越界，从而造成程序崩溃或其他数据的错误。</p><p><strong>fgets()</strong><br>fgets函数原型：char *fgets(char *s, int n, FILE *stream);//我们平时可以这么使用：fgets(str, sizeof(str), stdin);</p><p>其中str为数组首地址，sizeof(str)为数组大小，stdin表示我们从键盘输入数据。</p><p>fgets函数功能：从文件指针stream中读取字符，存到以s为起始地址的空间里，直到读完N-1个字符，或者读完一行。</p><p>注意：调用fgets函数时，最多只能读入n-1个字符。读入结束后，系统将自动在最后加’\0’，并以str作为函数值返回。</p><h3 id="scanf-和-printf-函数"><a href="#scanf-和-printf-函数" class="headerlink" title="scanf() 和 printf() 函数"></a>scanf() 和 printf() 函数</h3><p>格式控制符：<br>格式控制符    说明<br>%c    输出一个单一的字符<br>%hd、%d、%ld    以十进制、有符号的形式输出 short、int、long 类型的整数<br>%hu、%u、%lu    以十进制、无符号的形式输出 short、int、long 类型的整数<br>%ho、%o、%lo    以八进制、不带前缀、无符号的形式输出 short、int、long 类型的整数<br>%#ho、%#o、%#lo    以八进制、带前缀、无符号的形式输出 short、int、long 类型的整数<br>%hx、%x、%lx<br>%hX、%X、%lX    以十六进制、不带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字也小写；如果 X 大写，那么输出的十六进制数字也大写。<br>%#hx、%#x、%#lx<br>%#hX、%#X、%#lX    以十六进制、带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字和前缀都小写；如果 X 大写，那么输出的十六进制数字和前缀都大写。<br>%f、%lf    以十进制的形式输出 float、double 类型的小数<br>%e、%le<br>%E、%lE    以指数的形式输出 float、double 类型的小数。如果 e 小写，那么输出结果中的 e 也小写；如果 E 大写，那么输出结果中的 E 也大写。<br>%g、%lg<br>%G、%lG    以十进制和指数中较短的形式输出 float、double 类型的小数，并且小数部分的最后不会添加多余的 0。如果 g 小写，那么当以指数形式输出时 e 也小写；如果 G 大写，那么当以指数形式输出时 E 也大写。<br>%s    输出一个字符串</p><p>printf() 格式控制符的完整形式如下：<br>%[flag][width][.precision]type</p><ol><li>type 表示输出类型，比如 %d、%f、%c、%lf，type 就分别对应 d、f、c、lf；再如，%-9d中 type 对应 d。</li></ol><p>type 这一项必须有，这意味着输出时必须要知道是什么类型。</p><ol start="2"><li>width 表示最小输出宽度，也就是至少占用几个字符的位置；例如，%-9d中 width 对应 9，表示输出结果最少占用 9 个字符的宽度。</li></ol><p>当输出结果的宽度不足 width 时，以空格补齐（如果没有指定对齐方式，默认会在左边补齐空格）；当输出结果的宽度超过 width 时，width 不再起作用，按照数据本身的宽度来输出。</p><ol start="3"><li>.precision 表示输出精度，也就是小数的位数。<br>当小数部分的位数大于 precision 时，会按照四舍五入的原则丢掉多余的数字；<br>当小数部分的位数小于 precision 时，会在后面补 0。</li></ol><p>另外，.precision 也可以用于整数和字符串，但是功能却是相反的：<br>用于整数时，.precision 表示最小输出宽度。与 width 不同的是，整数的宽度不足时会在左边补 0，而不是补空格。<br>用于字符串时，.precision 表示最大输出宽度，或者说截取字符串。当字符串的长度大于 precision 时，会截掉多余的字符；当字符串的长度小于 precision 时，.precision 就不再起作用。</p><ol start="4"><li>flag 是标志字符。例如，%#x中 flag 对应 #，%-9d中 flags 对应-。下表列出了 printf() 可以用的 flag：<br>标志字符    含  义</li></ol><ul><li>   -表示左对齐。如果没有，就按照默认的对齐方式，默认一般为右对齐。</li></ul><ul><li> 用于整数或者小数，表示输出符号（正负号）。如果没有，那么只有负数才会输出符号。<br>空格    用于整数或者小数，输出值为正时冠以空格，为负时冠以负号。<br>‘#’<br>对于八进制（%o）和十六进制（%x / %X）整数，# 表示在输出时添加前缀；八进制的前缀是 0，十六进制的前缀是 0x / 0X。<br>对于小数（%f / %e / %g），# 表示强迫输出小数点。如果没有小数部分，默认是不输出小数点的，加上 # 以后，即使没有小数部分也会带上小数点。</li></ul><p>scanf() 读取字符串时以空格为分隔，遇到空格就认为当前字符串结束了，所以无法读取含有空格的字符串</p><p>scanf() 格式控制符汇总<br>格式控制符    说明<br>%c    读取一个单一的字符<br>%hd、%d、%ld    读取一个十进制整数，并分别赋值给 short、int、long 类型<br>%ho、%o、%lo    读取一个八进制整数（可带前缀也可不带），并分别赋值给 short、int、long 类型<br>%hx、%x、%lx    读取一个十六进制整数（可带前缀也可不带），并分别赋值给 short、int、long 类型<br>%hu、%u、%lu    读取一个无符号整数，并分别赋值给 unsigned short、unsigned int、unsigned long 类型<br>%f、%lf    读取一个十进制形式的小数，并分别赋值给 float、double 类型<br>%e、%le    读取一个指数形式的小数，并分别赋值给 float、double 类型<br>%g、%lg    既可以读取一个十进制形式的小数，也可以读取一个指数形式的小数，并分别赋值给 float、double 类型<br>%s    读取一个字符串（以空白符为结束）</p><p>Windows、Unix、Mac不同操作系统的换行问题 回车符\r和换行符\n<br>一、概念：</p><p>换行符‘\n’和回车符‘\r’</p><p>（1）换行符就是另起一行  — ‘\n’ 10 换行（newline）</p><p>（2）回车符就是回到一行的开头 — ‘\r’ 13 回车（return）</p><p>所以我们平时编写文件的回车符应该确切来说叫做回车换行符  </p><p>CR: 回车(Carriage Return) \rLF: 换行(Line Feed) \n</p><p>二、应用：</p><p>（1）在微软的MS-DOS和Windows中，使用“回车CR(‘\r’)”和“换行LF(‘\n’)”两个字符作为换行符;</p><p>（2）Windows系统里面，每行结尾是 回车+换行(CR+LF)，即“\r\n”；</p><p>（3）Unix系统里，每行结尾只有 换行LF，即“\n”；</p><p>（4）Mac系统里，每行结尾是 回车CR 即’\r’。</p><p>Mac OS 9 以及之前的系统的换行符是 CR，从 Mac OS X （后来改名为“OS X”）开始的换行符是 LF即‘\n’，和Unix/Linux统一了。</p><p>三、影响：</p><p>（1）一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；</p><p>（2）而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。</p><p>（3）Linux保存的文件在windows上用记事本看的话会出现黑点。</p><p>四、可以相互转换：</p><p>在linux下，命令unix2dos 是把linux文件格式转换成windows文件格式，命令dos2unix 是把windows格式转换成linux文件格式。</p><p>在不同平台间使用FTP软件传送文件时, 在ascii文本模式传输模式下, 一些FTP客户端程序会自动对换行格式进行转换. 经过这种传输的文件字节数可能会发生变化.</p><p> 如果你不想ftp修改原文件, 可以使用bin模式(二进制模式)传输文本。</p><p>一个程序在windows上运行就生成CR/LF换行格式的文本文件，而在Linux上运行就生成LF格式换行的文本文件。</p><h2 id="C判断-amp-循环"><a href="#C判断-amp-循环" class="headerlink" title="C判断 &amp; 循环"></a>C判断 &amp; 循环</h2><p>switch 语句注意点：</p><p>switch 语句中的 expression 是一个常量表达式，必须是一个整型或枚举类型。</p><p>在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。</p><p>case 后要比较的值 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。</p><p>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，即会执行该分支以及后面所有分支的语句，直到遇到 break 语句为止。当遇到 break 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行，也就是说，整个 switch 执行结束了，接着会执行整个 switch 后面的代码。</p><p>不是每一个 case 都需要包含 break。如果 case 语句不包含 break，控制流将会 继续 后续的 case，直到遇到 break 为止。</p><p>一个 switch 语句可以有一个可选的 default case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。当没有 default 时，如果所有 case 都匹配失败，那么就什么都不执行。由于 default 是最后一个分支，匹配后不会再执行其他分支，所以default中的 break 语句不是必需的。</p><h3 id="循环类型"><a href="#循环类型" class="headerlink" title="循环类型"></a>循环类型</h3><p>循环类型    描述<br>while 循环    当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。<br>for 循环    多次执行一个语句序列，简化管理循环变量的代码。<br>do…while 循环    除了它是在循环主体结尾测试条件外，其他与 while 语句类似。<br>嵌套循环    您可以在 while、for 或 do..while 循环内使用一个或多个循环。</p><p>C语言for循环中的三个表达式<br>for 循环中的“表达式1（初始化条件）”、“表达式2(循环条件)”和“表达式3（自增或自减）”都是可选项，都可以省略（但分号;必须保留）。</p><ol><li>省略了“表达式2(循环条件)”，如果不做其它处理就会成为死循环。</li><li>省略了“表达式3(自增或自减)”，就不会修改“表达式2(循环条件)”中的变量，这时可在循环体中加入修改变量的语句。</li><li>省略了“表达式1(初始化语句)”和“表达式3(自增或自减)” 例如：</li></ol><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">for</span>( ; i&lt;=<span class="hljs-number">100</span> ; )&#123;<br>    <span class="hljs-keyword">sum</span>=<span class="hljs-keyword">sum</span>+i;<br>    i++;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>相当于：</p><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">while</span>(i&lt;=<span class="hljs-number">100</span>)&#123;<br>    <span class="hljs-keyword">sum</span>=<span class="hljs-keyword">sum</span>+i;<br>    i++;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="4"><li>3个表达式可以同时省略。例如：<br><code>for( ; ; )</code>  语句 相当于： <code>while(1)</code>  语句</li><li>“表达式1”可以是初始化语句，也可以是其他语句。例如：<br><code>for( sum=0; i&lt;=100; i++ )  sum=sum+i;</code></li><li>“表达式2”一般是关系表达式或逻辑表达式，但也可是数值或字符，只要其值非零，就执行循环体。例如：<br><code>for( i=0; (c=getchar())!=&#39;\n&#39;; i+=c );</code></li></ol><p>do…while 循环</p><p>不像 for 和 while 循环，它们是在循环头部测试循环条件。在 C 语言中，do…while 循环是在循环的尾部检查它的条件。<br>do…while 循环与 while 循环类似，但是 do…while 循环会确保至少执行一次循环。</p><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><p>控制语句    描述<br>break 语句    终止循环或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。<br>continue 语句    告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。<br>goto 语句    将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</p><p>C 语言中 break 语句有以下两种用法：<br>当 break 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。<br>它也可用于终止 switch 语句中的一个 case。<br>另外如果使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码，即在多层循环中，一个 break 语句只向外跳一层。</p><p>continue 语句的作用是跳过循环体中剩余的语句而强制进入下一次循环。<br>对于 for 循环，continue 语句执行后自增语句仍然会执行。对于 while 和 do…while 循环，continue 语句重新执行条件判断语句。</p><p>C 语言中的 goto 语句允许把控制无条件转移到同一函数内的被标记的语句。但不建议使用 goto 语句。因为它使得程序的控制流难以跟踪，使程序难以理解和难以修改。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C02-datatype-operators</title>
    <link href="/2021/12/C02-datatype-operators/"/>
    <url>/2021/12/C02-datatype-operators/</url>
    
    <content type="html"><![CDATA[<h2 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C 数据类型"></a>C 数据类型</h2><p>C 中的类型可分为以下几种：</p><table><thead><tr><th>序号</th><th>类型与描述</th></tr></thead><tbody><tr><td>1</td><td>基本类型：它们是算术类型，包括两种类型：整数类型和浮点类型。</td></tr><tr><td>2</td><td>枚举类型：它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</td></tr><tr><td>3</td><td>void 类型：类型说明符 void 表明没有可用的值。</td></tr><tr><td>4</td><td>派生类型：它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</td></tr></tbody></table><p>数组类型和结构类型统称为聚合类型。函数的类型指的是函数返回值的类型。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>数据长度（Length），是指数据占用多少个字节。占用的字节越多，能存储的数据就越多，对于数字来说，值就会更大，反之能存储的数据就有限。</p><p>说  明    字符型    短整型    整型    长整型    单精度浮点型    双精度浮点型    无类型<br>数据类型    char    short    int    long    float    double    void<br>长  度    1    2    4    4    4    8</p><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p><table><thead><tr><th>序号</th><th>类型与描述</th></tr></thead></table><p>| 1 |函数返回为空<br>C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);|<br>| 2 |函数参数为空<br>C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);|<br>| 3 |指针指向 void<br>类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。|</p><p>1、数据类型转换：C 语言中如果一个表达式中含有不同类型的常量和变量，在计算时，会将它们自动转换为同一种类型；在 C 语言中也可以对数据类型进行强制转换；</p><p>2、自动转换规则：<br> a）浮点数赋给整型，该浮点数小数被舍去；<br> b）整数赋给浮点型，数值不变，但是被存储到相应的浮点型变量中；</p><p>3、强制类型转换形式: (类型说明符)(表达式)</p><h3 id="整型的长度"><a href="#整型的长度" class="headerlink" title="整型的长度"></a>整型的长度</h3><p>在 16 位环境下，short 的长度为 2 个字节，int 也为 2 个字节，long 为 4 个字节。16 位环境多用于单片机和低级嵌入式系统，在PC和服务器上已经见不到了。</p><p>对于 32 位的 Windows、Linux 和 Mac OS，short 的长度为 2 个字节，int 为 4 个字节，long 也为 4 个字节。PC和服务器上的 32 位系统占有率也在慢慢下降，嵌入式系统使用 32 位越来越多。</p><p>在 64 位环境下，不同的操作系统会有不同的结果，如下所示：</p><table><thead><tr><th>操作系统</th><th>short</th><th>int</th><th>long</th></tr></thead><tbody><tr><td>Win64（64位 Windows）</td><td>2</td><td>4</td><td>4</td></tr><tr><td>类Unix系统（包括 Unix、Linux、Mac OS、BSD、Solaris 等）</td><td>2</td><td>4</td><td>8</td></tr></tbody></table><p>除了C语言，Java、C++、C#等在定义变量时也必须指明数据类型，这样的编程语言称为强类型语言。而PHP、JavaScript等在定义变量时不必指明数据类型，编译系统会自动推演，这样的编程语言称为弱类型语言。</p><p>强类型语言一旦确定了数据类型，就不能再赋给其他类型的数据，除非对数据类型进行转换。弱类型语言没有这种限制，一个变量，可以先赋给一个整数，然后再赋给一个字符串。</p><p>C中二进制数、八进制数和十六进制数的表示</p><p>（1） 二进制<br>二进制由 0 和 1 两个数字组成，使用时必须以0b或0B（不区分大小写）开头<br>标准的C语言并不支持上面的二进制写法，只是有些编译器自己进行了扩展，才支持二进制数字。换句话说，并不是所有的编译器都支持二进制数字，只有一部分编译器支持，并且跟编译器的版本有关系。</p><p>（2） 八进制<br>八进制由 0~7 八个数字组成，使用时必须以0开头（注意是数字 0，不是字母 o）</p><p>（3） 十六进制<br>十六进制由数字 0<del>9、字母 A</del>F 或 a~f（不区分大小写）组成，使用时必须以0x或0X（不区分大小写）开头</p><p>二进制数、八进制数和十六进制数的输出</p><div class="hljs code-wrapper"><pre><code> short    int    long    unsigned short    unsigned int    unsigned long</code></pre></div><p>八进制    –    –    –    %ho    %o    %lo<br>十进制    %hd    %d    %ld    %hu    %u    %lu<br>十六进制    –    –    –    %hx 或者 %hX    %x 或者 %X    %lx 或者 %lX</p><p>十六进制数字的表示用到了英文字母，有大小写之分，要在格式控制符中体现出来：<br>%hx、%x 和 %lx 中的x小写，表明以小写字母的形式输出十六进制数；<br>%hX、%X 和 %lX 中的X大写，表明以大写字母的形式输出十六进制数。</p><p>当以有符号数的形式输出时，printf 会读取数字所占用的内存，并把最高位作为符号位，把剩下的内存作为数值位；<br>当以无符号数的形式输出时，printf 也会读取数字所占用的内存，并把所有的内存都作为数值位对待。</p><h3 id="小数的输出"><a href="#小数的输出" class="headerlink" title="小数的输出"></a>小数的输出</h3><p>%f 以十进制形式输出 float 类型；<br>%lf 以十进制形式输出 double 类型；<br>%e 以指数形式输出 float 类型，输出结果中的 e 小写；<br>%E 以指数形式输出 float 类型，输出结果中的 E 大写；<br>%le 以指数形式输出 double 类型，输出结果中的 e 小写；<br>%lE 以指数形式输出 double 类型，输出结果中的 E 大写。<br>%g 会对比小数的十进制形式和指数形式，以最短的方式来输出小数，让输出结果更加简练。<br>%g 默认最多保留六位有效数字，包括整数部分和小数部分；%f 和 %e 默认保留六位小数，只包括小数部分。<br>%g 不会在最后强加 0 来凑够有效数字的位数，而 %f 和 %e 会在最后强加 0 来凑够小数部分的位数。<br>除了 %g，还有 %lg、%G、%lG：<br>%g 和 %lg 分别用来输出 float 类型和 double 类型，并且当以指数形式输出时，e小写。<br>%G 和 %lG 也分别用来输出 float 类型和 double 类型，只是当以指数形式输出时，E大写。</p><p>在C中，一个数字是有默认类型的：对于整数，默认是 int 类型；对于小数，默认是 double 类型。<br>如果不想让数字使用默认的类型，那么可以给数字加上后缀，手动指明类型：<br>在整数后面紧跟 l 或者 L（不区分大小写）表明该数字是 long 类型；<br>在小数后面紧跟 f 或者 F（不区分大小写）表明该数字是 float 类型。</p><p>在C语言中，整数和小数之间可以相互赋值：<br>将一个整数赋值给小数类型，在小数点后面加 0 就可以，加几个都无所谓。<br>将一个小数赋值给整数类型，就得把小数部分丢掉，只能取整数部分，这会改变数字本来的值。注意是直接丢掉小数部分，而不是按照四舍五入取近似值。</p><h3 id="enum-枚举"><a href="#enum-枚举" class="headerlink" title="enum(枚举)"></a>enum(枚举)</h3><p>枚举是 C 语言中的一种基本数据类型。</p><p>枚举语法定义格式为：</p><p><code>enum　枚举名　&#123;枚举元素1,枚举元素2,……&#125;;</code></p><p>注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。</p><p>可以在定义枚举类型时改变枚举元素的值：</p><p><code>enum season &#123;spring, summer=3, autumn, winter&#125;;</code></p><p>没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5</p><p><strong>枚举变量的定义</strong></p><p>可以通过以下三种方式来定义枚举变量</p><p>1、先定义枚举类型，再定义枚举变量</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DAY</span></span><br><span class="hljs-class"></span>&#123;<br>      MON=<span class="hljs-number">1</span>, TUE, WED, THU, FRI, SAT, SUN<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DAY</span> <span class="hljs-title">day</span></span>;<br></code></pre></div></td></tr></table></figure><p>2、定义枚举类型的同时定义枚举变量</p><figure class="highlight capnproto"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs capnproto"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DAY</span></span><br><span class="hljs-class"></span>&#123;<br>      MON=<span class="hljs-number">1</span>, TUE, WED, THU, FRI, SAT, SUN<br>&#125; day;<br></code></pre></div></td></tr></table></figure><p>3、省略枚举名称，直接定义枚举变量</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class"></span>&#123;<br>      MON=<span class="hljs-number">1</span>, TUE, WED, THU, FRI, SAT, SUN<br>&#125; day;<br></code></pre></div></td></tr></table></figure><p>需要注意的两点是：</p><ol><li><p>枚举列表中的 Mon、Tue、Wed 这些标识符的作用范围是全局的（严格来说是 main() 函数内部），不能再定义与它们名字相同的变量。</p></li><li><p>Mon、Tue、Wed 等都是常量，不能对它们赋值，只能将它们的值赋给其他的变量。</p></li></ol><p>枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可以将枚举理解为编译阶段的宏。</p><p>在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。</p><p>不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。</p><p>以下实例使用 for 来遍历枚举的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DAY</span></span><br><span class="hljs-class">&#123;</span><br>      MON=<span class="hljs-number">1</span>, TUE, WED, THU, FRI, SAT, SUN<br>&#125; day;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 遍历枚举元素</span><br>    <span class="hljs-keyword">for</span> (day = MON; day &lt;= SUN; day++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;枚举元素：%d \n&quot;</span>, day);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>以上实例输出结果为：</p><p>枚举元素：1<br>枚举元素：2<br>枚举元素：3<br>枚举元素：4<br>枚举元素：5<br>枚举元素：6<br>枚举元素：7</p><p>以下枚举类型不连续，这种枚举无法遍历。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class"></span>&#123;<br>    ENUM_0,<br>    ENUM_10 = <span class="hljs-number">10</span>,<br>    ENUM_11<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="C语言的字符类型"><a href="#C语言的字符类型" class="headerlink" title="C语言的字符类型"></a>C语言的字符类型</h2><p>字符类型由单引号’ ‘包围，字符串由双引号” “包围。</p><p>输出 char 类型的字符有两种方法，分别是：<br>使用专门的字符输出函数 putchar，每次只能输出一个字符，输出多个字符需要调用多次。<br>使用通用的格式化输出函数 printf，char 对应的格式控制符是%c。</p><p>在 C 语言中没有专门的字符串类型，因此双引号内的字符串会被存储到一个数组中，这个字符串代表指向这个数组起始字符的指针；</p><p>而单引号中的内容是一个 char 类型，是一个字符，这个字符对应的是 ASCII 表中的序列值。</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>转义字符以\或者\x开头，以\开头表示后跟八进制形式的编码值，以\x开头表示后跟十六进制形式的编码值。</p><p>转义字符的初衷是用于 ASCII 编码，所以它的取值范围有限：<br>八进制形式的转义字符最多后跟三个数字，也即\ddd，最大取值是\177；<br>十六进制形式的转义字符最多后跟两个数字，也即\xdd，最大取值是\x7f。</p><p>转义字符    意义    ASCII码值（十进制）<br>\a    响铃(BEL)    007<br>\b    退格(BS) ，将当前位置移到前一列    008<br>\f    换页(FF)，将当前位置移到下页开头    012<br>\n    换行(LF) ，将当前位置移到下一行开头    010<br>\r    回车(CR) ，将当前位置移到本行开头    013<br>\t    水平制表(HT)     009<br>\v    垂直制表(VT)    011<br>&#39;    单引号    039<br>&quot;    双引号    034<br>\    反斜杠    092</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><strong>自动类型转换</strong></p><ol><li>将一种类型的数据赋值给另外一种类型的变量时就会发生自动类型转换，例如：<br>float f = 100;</li></ol><p>100 是 int 类型的数据，需要先转换为 float 类型才能赋值给变量 f。再如：<br>int n = f;</p><p>f 是 float 类型的数据，需要先转换为 int 类型才能赋值给变量 n。</p><p>在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型转换为左边变量的类型，这可能会导致数据失真，或者精度降低；所以说，自动类型转换并不一定是安全的。对于不安全的类型转换，编译器一般会给出警告。</p><ol start="2"><li>在不同类型的混合运算中，编译器也会自动地转换数据类型，将参与运算的所有数据先转换为同一种类型，然后再进行计算。转换的规则如下：<br>转换按数据长度增加的方向进行，以保证数值不失真，或者精度不降低。例如，int 和 long 参与运算时，先把 int 类型的数据转成 long 类型后再进行运算。<br>所有的浮点运算都是以双精度进行的，即使运算中只有 float 类型，也要先转换为 double 类型，才能进行运算。<br>char 和 short 参与运算时，必须先转换成 int 类型。</li></ol><p><strong>强制类型转换</strong></p><p>强制类型转换的格式为：<br>(type_name) expression<br>type_name为新类型名称，expression为表达式。例如：</p><p>(float) a;  //将变量 a 转换为 float 类型<br>(int)(x+y);  //把表达式 x+y 的结果转换为 int 整型<br>(float) 100;  //将数值 100（默认为int类型）转换为 float 类型</p><p><strong>整数提升</strong><br>整数提升是指把小于 int 或 unsigned int 的整数类型转换为 int 或 unsigned int 的过程。</p><p><strong>常用的算术转换</strong><br>常用的算术转换是隐式地把值强制转换为相同的类型。编译器首先执行整数提升，如果操作数类型不同，则它们会被转换为下列层次中出现的最高层次的类型：<br><img src="https://www.runoob.com/wp-content/uploads/2014/08/usual_arithmetic_conversion.png" srcset="/img/loading.gif" lazyload alt="类型转换"></p><p><strong>类型转换只是临时性的</strong><br>无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换，转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值。</p><h2 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C 存储类"></a>C 存储类</h2><p>存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：</p><ul><li>auto</li><li>register</li><li>static</li><li>extern</li></ul><h3 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h3><p>auto 存储类是所有局部变量默认的存储类，auto 只能用在函数内，即 auto 只能修饰局部变量，因可以省略, 几乎没人使用。<br>    {<br>    int mount;<br>    auto int month;<br>    }<br>上面的实例定义了两个带有相同存储类的变量，即类型前不带修饰符默认为auto存储类。</p><h3 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h3><p>register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p><p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p><h3 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h3><p>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p><p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p><p>所有未加 static 前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。如果加了 static，就会对其它源文件隐藏。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。</p><p>全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。</p><p>（1）在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。</p><p>（2）static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。</p><p>（3）static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。在静态数据区，内存中所有的字节默认值都是 0x00。</p><p>（4）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。</p><p>（5）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。</p><p>以下实例演示了 static 修饰全局变量和局部变量的应用：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">/* 函数声明 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count=<span class="hljs-number">10</span>;        <span class="hljs-comment">/* 全局变量 - static 是默认的 */</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">while</span> (count--) &#123;<br>    <span class="hljs-built_in">func1</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br><span class="hljs-comment">/* &#x27;thingy&#x27; 是 &#x27;func1&#x27; 的局部变量 - 只初始化一次</span><br><span class="hljs-comment">* 每次调用函数 &#x27;func1&#x27; &#x27;thingy&#x27; 值不会被重置。</span><br><span class="hljs-comment">*/</span>                <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> thingy=<span class="hljs-number">5</span>;<br>thingy++;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; thingy 为 %d ， count 为 %d\n&quot;</span>, thingy, count);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置。<br>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">6</span> ， count 为 <span class="hljs-number">9</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">7</span> ， count 为 <span class="hljs-number">8</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">8</span> ， count 为 <span class="hljs-number">7</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">9</span> ， count 为 <span class="hljs-number">6</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">10</span> ， count 为 <span class="hljs-number">5</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">11</span> ， count 为 <span class="hljs-number">4</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">12</span> ， count 为 <span class="hljs-number">3</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">13</span> ， count 为 <span class="hljs-number">2</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">14</span> ， count 为 <span class="hljs-number">1</span><br><span class="hljs-attribute">thingy</span> 为 <span class="hljs-number">15</span> ， count 为 <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h3 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h3><p>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p><p>在有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。</p><p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p><p>第一个文件：main.c</p><p>实例</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-keyword">int</span> count ;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write_extern</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>count = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">write_extern</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第二个文件：support.c</p><p>实例</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> count;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write_extern</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;count is %d\n&quot;</span>, count);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.c 中定义的 count。现在 ，编译这两个文件，如下所示：</p><p> $ gcc main.c support.c<br>这会产生 a.out 可执行程序，当程序被执行时，它会产生下列结果：</p><div class="hljs code-wrapper"><pre><code>count is 5</code></pre></div><p><strong>静态全局变量与普通全局变量的区别：</strong></p><p>全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。</p><p>全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式，这两者在存储方式上并无不同。</p><p>这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。</p><p><strong>C 语言中全局变量、局部变量、静态全局变量、静态局部变量的区别</strong><br><strong>从作用域看：</strong></p><p>1、全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。</p><p>2、静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。</p><p>3、局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</p><p>4、静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</p><p><strong>从分配内存空间看：</strong></p><p>1、全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间</p><p>2、全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。</p><p> 1)静态变量会被放在程序的静态数据存储区(全局可见)中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。<br> 2)变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。<br>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>算术运算符<br>关系运算符<br>逻辑运算符<br>位运算符<br>赋值运算符<br>其他运算符</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>下表显示了 C 语言支持的所有算术运算符。假设变量 A 的值为 10，变量 B 的值为 20，则：</p><p>运算符    描述    实例</p><ul><li>   把两个操作数相加    A + B 将得到 30</li></ul><ul><li>   从第一个操作数中减去第二个操作数    A - B 将得到 -10</li></ul><ul><li> 把两个操作数相乘    A * B 将得到 200<br>/    分子除以分母    B / A 将得到 2<br>%    取模运算符，整除后的余数    B % A 将得到 0</li></ul><p>  ++    自增运算符，整数值增加 1    A++ 将得到 11<br>  –    自减运算符，整数值减少 1    A– 将得到 9</p><p>对除法的补充</p><p>当除数和被除数都是整数时，运算结果也是整数；如果不能整除，那么就直接丢掉小数部分，只保留整数部分，这跟将小数赋值给整数类型是一个道理。<br>一旦除数和被除数中有一个是小数，那么运算结果也是小数，并且是 double 类型的小数。</p><p>对取余的补充</p><p>C语言中的取余运算只能针对整数，也就是说，% 的两边都必须是整数，不能出现小数，否则编译器会报错。</p><p>另外，余数可以是正数也可以是负数，由 % 左边的整数决定：<br>如果 % 左边是正数，那么余数也是正数；<br>如果 % 左边是负数，那么余数也是负数。</p><p>自增/自减补充</p><p>a++ 与 ++a 区别在于一个后加，一个先加。</p><p>a++ 输出 a 的值再自加，缓存 a 自加后的结果，用于下次进行与 a 相关的计算，即先进行其他操作，再进行自增运算。</p><p>++a 则相当于 a+1，即先进行自增运算，再进行其他操作。</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>假设变量 A 的值为 10，变量 B 的值为 20，则：</p><p>运算符    描述    实例<br>==    检查两个操作数的值是否相等，如果相等则条件为真。    (A == B) 为假。<br>!=    检查两个操作数的值是否相等，如果不相等则条件为真。    (A != B) 为真。</p><blockquote><div class="hljs code-wrapper"><pre><code>   检查左操作数的值是否大于右操作数的值，如果是则条件为真。    (A &gt; B) 为假。</code></pre></div><p>   &lt;    检查左操作数的值是否小于右操作数的值，如果是则条件为真。    (A &lt; B) 为真。<br>   =    检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。    (A &gt;= B) 为假。<br>   &lt;=    检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。    (A &lt;= B) 为真。</p></blockquote><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>假设变量 A 的值为 1，变量 B 的值为 0，则：</p><p>运算符    描述    实例<br>&amp;&amp;    称为逻辑与运算符。如果两个操作数都非零，则条件为真。    (A &amp;&amp; B) 为假。<br>||    称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。    (A || B) 为真。<br>!    称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。    !(A &amp;&amp; B) 为真。</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p><p>p    q    p &amp; q    p | q    p ^ q<br>0    0    0    0    0<br>0    1    0    1    1<br>1    1    1    1    0<br>1    0    0    1    1</p><p>运算符    描述    实例<br>&amp;<br>按位与操作，按二进制位进行”与”运算。运算规则：</p><p>0&amp;0=0;<br>0&amp;1=0;<br>1&amp;0=0;<br>1&amp;1=1;    (A &amp; B) 将得到 12，即为 0000 1100<br>|<br>按位或运算符，按二进制位进行”或”运算。运算规则：</p><p>0|0=0;<br>0|1=1;<br>1|0=1;<br>1|1=1;    (A | B) 将得到 61，即为 0011 1101<br>^<br>异或运算符，按二进制位进行”异或”运算。运算规则：</p><p>0^0=0;<br>0^1=1;<br>1^0=1;<br>1^1=0;    (A ^ B) 将得到 49，即为 0011 0001<br>~<br>取反运算符，按二进制位进行”取反”运算。运算规则：</p><p><del>1=-2;<br>~0=-1;    (</del>A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。<br>&lt;&lt;    二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。    A &lt;&lt; 2 将得到 240，即为 1111 0000</p><blockquote><blockquote><div class="hljs code-wrapper"><pre><code>   二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。A &gt;&gt; 2 将得到 15，即为 0000 1111</code></pre></div></blockquote></blockquote><p>下面的实例包含 C 语言中所有可用的位运算符：</p><p>实例：</p><figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br> <br><span class="hljs-keyword">int</span> main()<br>&#123;<br> <br>   unsigned <span class="hljs-keyword">int</span> a = <span class="hljs-number">60</span>;    <span class="hljs-regexp">/* 60 = 0011 1100 */</span>  <br>   unsigned <span class="hljs-keyword">int</span> b = <span class="hljs-number">13</span>;    <span class="hljs-regexp">/* 13 = 0000 1101 */</span><br>   <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;           <br> <br>   c = a &amp; b;       <span class="hljs-regexp">/* 12 = 0000 1100 */</span> <br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Line 1 - c 的值是 %d\n&quot;</span>, c );<br> <br>   c = a | b;       <span class="hljs-regexp">/* 61 = 0011 1101 */</span><br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Line 2 - c 的值是 %d\n&quot;</span>, c );<br> <br>   c = a ^ b;       <span class="hljs-regexp">/* 49 = 0011 0001 */</span><br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Line 3 - c 的值是 %d\n&quot;</span>, c );<br> <br>   c = ~a;          <span class="hljs-regexp">/*-61 = 1100 0011 */</span><br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Line 4 - c 的值是 %d\n&quot;</span>, c );<br> <br>   c = a &lt;&lt; <span class="hljs-number">2</span>;     <span class="hljs-regexp">/* 240 = 1111 0000 */</span><br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Line 5 - c 的值是 %d\n&quot;</span>, c );<br> <br>   c = a &gt;&gt; <span class="hljs-number">2</span>;     <span class="hljs-regexp">/* 15 = 0000 1111 */</span><br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Line 6 - c 的值是 %d\n&quot;</span>, c );<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><p>Line 1 - c 的值是 12<br>Line 2 - c 的值是 61<br>Line 3 - c 的值是 49<br>Line 4 - c 的值是 -61<br>Line 5 - c 的值是 240<br>Line 6 - c 的值是 15</p><p><strong>位运算的一些应用：</strong></p><p>利用异或 ^ 来交换两个数的值，而且不引入其他变量。</p><p>unsigned int a=60;  //0011 1100<br>unsigned int b=13;  //0000 1101<br>a=a^b;              //a=a^b=0011 0001<br>b=a^b;              //b=a^b=0011 1100  相当于b1=(a^b)^b<br>a=a^b;              //a=a^b=0000 1101  相当于a1=(a^b)^((a^b)^b)</p><p>实例</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> a=<span class="hljs-number">60</span>;         <span class="hljs-comment">//0011 1100</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> b=<span class="hljs-number">13</span>;         <span class="hljs-comment">//0000 1101</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d,b=%d&quot;</span>,a,b);   <span class="hljs-comment">//输出a，b的值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    a=a^b;                     <span class="hljs-comment">//a=a^b=0011 0001</span><br>    b=a^b;                     <span class="hljs-comment">//b=a^b=0011 1100</span><br>    a=a^b;                     <span class="hljs-comment">//a=a^b=0000 1101</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d,b=%d&quot;</span>,a,b);   <span class="hljs-comment">//输出a，b的值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>结果：</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">a</span>=<span class="hljs-number">60</span>，b=<span class="hljs-number">13</span>；<br><span class="hljs-attr">a</span>=<span class="hljs-number">13</span>，b=<span class="hljs-number">60</span><span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>仅用一行代码实现的方法：<code>a^=b^=a^=b;</code> 其等价于：</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">a</span>=a^b<span class="hljs-comment">;</span><br><span class="hljs-attr">b</span>=a^b<span class="hljs-comment">;</span><br><span class="hljs-attr">a</span>=a^b<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>当然，这种利用位运算的交换方法只适用于整型变量，不能用于浮点型变量</p><p>利用位与 &amp; 运算，判断一个整数是否是2的整数次幂。</p><p>二进制数的位权是以2为底的幂，如果一个整数 m 是 2 的 n 次幂，那么转换为二进制之后只有最高位为 1，其余位置为 0，再观察 m-1 转换为二进制后的形式以及 m&amp;(m-1) 的结果，例如：</p><p>2 –&gt; 0000 0010        1 –&gt; 0000 0001        2&amp;1 –&gt; 0000 0010 &amp; 0000 0001 = 0<br>4 –&gt; 0000 0100        3 –&gt; 0000 0011        4&amp;3 –&gt; 0000 0100 &amp; 0000 0011 = 0<br>8 –&gt; 0000 1000        7 –&gt; 0000 0111        8&amp;7 –&gt; 0000 1000 &amp; 0000 0111 = 0<br>可以看出所有的 1 完美的错过了，根据位与的特点可知 m&amp;(m-1) 的结果为 0。</p><p>如果整数 m 不是 2 的 n 次幂，结果会怎样呢？例如 m=9 时：</p><p>9 –&gt; 0000 1001        8 –&gt; 0000 1000        9&amp;8 –&gt; 0000 1001 &amp; 0000 1000 != 0<br>利用这一特点，即可判断一个整数是否是2的整数次幂。</p><p>示例：</p><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart">#include &lt;stdio.h&gt;<br><br><span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>;<br><span class="hljs-built_in">int</span> func(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">num</span>&gt;<span class="hljs-number">0</span>)&amp;&amp;(<span class="hljs-built_in">num</span>&amp;(<span class="hljs-built_in">num</span><span class="hljs-number">-1</span>))==<span class="hljs-number">0</span>)<br>    &#123;<br>        printf(<span class="hljs-string">&quot;%d是2的整数次幂&quot;</span>,<span class="hljs-built_in">num</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        printf(<span class="hljs-string">&quot;%d不是2的整数次幂&quot;</span>,<span class="hljs-built_in">num</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>((<span class="hljs-built_in">num</span>&gt;<span class="hljs-number">0</span>)&amp;&amp;(<span class="hljs-built_in">num</span>&amp;(<span class="hljs-built_in">num</span><span class="hljs-number">-1</span>))==<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-built_in">int</span> main()<br>&#123;<br>    printf(<span class="hljs-string">&quot;请输入要查询的数\n&quot;</span>);<br>    scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;<span class="hljs-built_in">num</span>);<br>    func(<span class="hljs-built_in">num</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>返回值为 1，则输入的正整数为 2 的整数次幂，返回值为 0 则不是。</p><p>不同长度的数据进行位运算</p><p>如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。</p><p>以“与”运算为例说明如下：我们知道在 C 语言中 long 型占 4 个字节，int 型占 2 个字节，如果一个 long 型数据与一个 int 型数据进行“与”运算，右端对齐后，左边不足的位依下面三种情况补足:</p><p> （1）如果整型数据为正数，左边补 16 个 0。<br> （2）如果整型数据为负数，左边补 16 个 1。<br> （3）如果整形数据为无符号数，左边也补 16 个 0。</p><p>在计算机中，负数以其正值的补码形式表达</p><p>原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。</p><p>反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。</p><p>补码：反码加1称为补码。</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>=    简单的赋值运算符，把右边操作数的值赋给左边操作数    C = A + B 将把 A + B 的值赋给 C<br>+=    加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数    C += A 相当于 C = C + A<br>-=    减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数    C -= A 相当于 C = C - A<br>*=    乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数    C *= A 相当于 C = C * A<br>/=    除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数    C /= A 相当于 C = C / A<br>%=    求模且赋值运算符，求两个操作数的模赋值给左边操作数    C %= A 相当于 C = C % A<br>&lt;&lt;=    左移且赋值运算符    C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</p><blockquote><blockquote><p>=    右移且赋值运算符    C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2<br>&amp;=    按位与且赋值运算符    C &amp;= 2 等同于 C = C &amp; 2<br>^=    按位异或且赋值运算符    C ^= 2 等同于 C = C ^ 2<br>|=    按位或且赋值运算符    C |= 2 等同于 C = C | 2</p></blockquote></blockquote><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><p>运算符    描述    实例<br>sizeof()    返回变量的大小。    sizeof(a) 将返回 4，其中 a 是整数。<br>&amp;    返回变量的地址。    &a; 将给出变量的实际地址。</p><ul><li> 指向一个变量。    *a; 将指向一个变量。<br>? :    条件表达式（C中唯一一个三目运算符）    如果条件为真 ? 则值为 X : 否则值为 Y</li></ul><h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><p>c语言中运算符优先级的总结：</p><p>初等运算符&gt;单目运算符&gt;算术运算符&gt;关系运算符&gt;逻辑运算符&gt;条件运算符&gt;赋值运算符</p><p>初等运算符有：（）、[ ]、-&gt;、.  (后两者均为结构体成员运算符)；<br>单目运算符有：！、~、++、–、sizeof、&amp;、<em>；<br>算术运算符有：</em>、/、+、-、&lt;&lt;、&gt;&gt;;<br>关系运算符有：&lt;、&lt;=、&gt;、&gt;=、==、!=、&amp;、^、|；(此栏排列仍有优先级顺序哦);<br>逻辑运算符有：&amp;&amp;、||；<br>条件运算符有：？：（即三目运算符）;<br>赋值运算符有：=、+=、-=、*=、/=、%=、&gt;&gt;=、&lt;&lt;=；等<br>另外，单目运算符的优先级都高于双目运算符。</p><p>C语言中大多数运算符的结合性都是从左往右，只有三个运算符是从右往左的。一个是单目运算符，另一个是三目运算符，还有一个就是双目运算符中的赋值运算符=。双目运算符中只有赋值运算符的结合性是从右往左的，其他的都是从左往右</p><p><a href="http://c.biancheng.net/view/161.html">http://c.biancheng.net/view/161.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C01</title>
    <link href="/2021/12/C01/"/>
    <url>/2021/12/C01/</url>
    
    <content type="html"><![CDATA[<h2 id="二进制、八进制、十进制、十六进制"><a href="#二进制、八进制、十进制、十六进制" class="headerlink" title="二进制、八进制、十进制、十六进制"></a>二进制、八进制、十进制、十六进制</h2><h3 id="将二进制、八进制、十六进制转换为十进制"><a href="#将二进制、八进制、十六进制转换为十进制" class="headerlink" title="将二进制、八进制、十六进制转换为十进制"></a>将二进制、八进制、十六进制转换为十进制</h3><p>二进制、八进制和十六进制向十进制转换的方法是“按权相加”。所谓“权”，也即“位权”。</p><p>假设当前数字是 N 进制，那么：<br>对于<strong>整数部分</strong>，从右往左看，第 i 位的位权等于Ni-1<br>对于<strong>小数部分</strong>，恰好相反，要从左往右看，第 j 位的位权为N-j。</p><p>更加通俗的理解是，假设一个多位数（由多个数字组成的数）某位上的数字它所表示的数值大小就是该位的位权。</p><p>（1）整数部分</p><p>例如，将八进制数字 53627 转换成十进制：<br>53627 = 5×84 + 3×83 + 6×82 + 2×81 + 7×80 = 22423（十进制）</p><p>从右往左看，第1位的位权为 80=1，第2位的位权为 81=8，第3位的位权为 82=64，第4位的位权为 83=512，第5位的位权为 84=4096 …… 第n位的位权就为 8n-1。将各个位的数字乘以位权，然后再相加，就得到了十进制形式。<br>注意，这里我们需要以十进制形式来表示位权。<br>再如，将十六进制数字 9FA8C 转换成十进制：<br>9FA8C = 9×164 + 15×163 + 10×162 + 8×161 + 12×160 = 653964（十进制）</p><p>从右往左看，第1位的位权为 160=1，第2位的位权为 161=16，第3位的位权为 162=256，第4位的位权为 163=4096，第5位的位权为 164=65536 …… 第n位的位权就为 16n-1。将各个位的数字乘以位权，然后再相加，就得到了十进制形式。</p><p>将二进制数字转换成十进制也是类似的道理：<br>11010 = 1×24 + 1×23 + 0×22 + 1×21 + 0×20 = 26（十进制）</p><p>从右往左看，第1位的位权为 20=1，第2位的位权为 21=2，第3位的位权为 22=4，第4位的位权为 23=8，第5位的位权为 24=16 …… 第n位的位权就为 2n-1。将各个位的数字乘以位权，然后再相加，就得到了十进制形式。</p><p>（2）小数部分</p><p>例如，将八进制数字 423.5176 转换成十进制：<br>423.5176 = 4×82 + 2×81 + 3×80 + 5×8-1 + 1×8-2 + 7×8-3 + 6×8-4 = 275.65576171875（十进制）</p><p>小数部分和整数部分相反，要从左往右看，第1位的位权为 8-1=1/8，第2位的位权为 8-2=1/64，第3位的位权为 8-3=1/512，第4位的位权为 8-4=1/4096 …… 第m位的位权就为 8-m。</p><p>再如，将二进制数字 1010.1101 转换成十进制：<br>1010.1101 = 1×23 + 0×22 + 1×21 + 0×20 + 1×2-1 + 1×2-2 + 0×2-3 + 1×2-4 = 10.8125（十进制）</p><p>小数部分和整数部分相反，要从左往右看，第1位的位权为 2-1=1/2，第2位的位权为 2-2=1/4，第3位的位权为 2-3=1/8，第4位的位权为 2-4=1/16 …… 第m位的位权就为 2-m。</p><p>更多转换成十进制的例子：</p><ul><li>二进制：1001 = 1×23 + 0×22 + 0×21 + 1×20 = 8 + 0 + 0 + 1 = 9（十进制）</li><li>二进制：101.1001 = 1×22 + 0×21 + 1×20 + 1×2-1 + 0×2-2 + 0×2-3 + 1×2-4 = 4 + 0 + 1 + 0.5 + 0 + 0 + 0.0625 = 5.5625（十进制）</li><li>八进制：302 = 3×82 + 0×81 + 2×80 = 192 + 0 + 2 = 194（十进制）</li><li>八进制：302.46 = 3×82 + 0×81 + 2×80 + 4×8-1 + 6×8-2 = 192 + 0 + 2 + 0.5 + 0.09375= 194.59375（十进制）</li><li>十六进制：EA7 = 14×162 + 10×161 + 7×160 = 3751（十进制）</li></ul><h3 id="将二进制、八进制、十六进制转换为十进制-1"><a href="#将二进制、八进制、十六进制转换为十进制-1" class="headerlink" title="将二进制、八进制、十六进制转换为十进制"></a>将二进制、八进制、十六进制转换为十进制</h3><p>（1）整数部分</p><p>十进制整数转换为 N 进制整数采用“除 N 取余，逆序排列”法。具体做法是：</p><ul><li>将 N 作为除数，用十进制整数除以 N，可以得到一个商和余数；</li><li>保留余数，用商继续除以 N，又得到一个新的商和余数；</li><li>仍然保留余数，用商继续除以 N，还会得到一个新的商和余数；</li><li>……</li><li>如此反复进行，每次都保留余数，用商接着除以 N，直到商为 0 时为止。</li></ul><p>把先得到的余数作为 N 进制数的低位数字，后得到的余数作为 N 进制数的高位数字，依次排列起来，就得到了 N 进制数字。<br>（2）小数部分</p><p>十进制小数转换成 N 进制小数采用“乘 N 取整，顺序排列”法。具体做法是：</p><ul><li>用 N 乘以十进制小数，可以得到一个积，这个积包含了整数部分和小数部分；</li><li>将积的整数部分取出，再用 N 乘以余下的小数部分，又得到一个新的积；</li><li>再将积的整数部分取出，继续用 N 乘以余下的小数部分；</li><li>……<br>如此反复进行，每次都取出整数部分，用 N 接着乘以小数部分，直到积中的小数部分为 0，或者达到所要求的精度为止。</li></ul><p>把取出的整数部分按顺序排列起来，先取出的整数作为 N 进制小数的高位数字，后取出的整数作为低位数字，这样就得到了 N 进制小数。</p><p>下表列出了前 17 个十进制整数与二进制、八进制、十六进制的对应关系：</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>十进制</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td></tr><tr><td>二进制</td><td>0</td><td>1</td><td>10</td><td>11</td><td>100</td><td>101</td><td>110</td><td>111</td><td>1000</td><td>1001</td><td>1010</td><td>1011</td><td>1100</td><td>1101</td><td>1110</td><td>1111</td><td>10000</td></tr><tr><td>八进制</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td><td>20</td></tr><tr><td>十六进制</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>10</td></tr></tbody></table><p>注意，十进制小数转换成其他进制小数时，结果有可能是一个无限位的小数。请看下面的例子：<br>十进制 0.51 对应的二进制为 0.100000101000111101011100001010001111010111…，是一个循环小数；<br>十进制 0.72 对应的二进制为 0.1011100001010001111010111000010100011110…，是一个循环小数；<br>十进制 0.625 对应的二进制为 0.101，是一个有限小数。</p><h3 id="二进制和八进制、十六进制的转换"><a href="#二进制和八进制、十六进制的转换" class="headerlink" title="二进制和八进制、十六进制的转换"></a>二进制和八进制、十六进制的转换</h3><p>（1）二进制整数和八进制整数之间的转换</p><p>二进制整数转换为八进制整数时，每三位二进制数字转换为一位八进制数字，运算的顺序是从低位向高位依次进行，高位不足三位用零补齐。</p><p>八进制整数转换为二进制整数时，思路是相反的，每一位八进制数字转换为三位二进制数字，运算的顺序也是从低位向高位依次进行。</p><p>（2）二进制整数和十六进制整数之间的转换</p><p>二进制整数转换为十六进制整数时，每四位二进制数字转换为一位十六进制数字，运算的顺序是从低位向高位依次进行，高位不足四位用零补齐。</p><p>十六进制整数转换为二进制整数时，思路是相反的，每一位十六进制数字转换为四位二进制数字，运算的顺序也是从低位向高位依次进行。</p><p>单位换算：</p><ul><li>1Byte = 8 Bit</li><li>1KB = 1024Byte = 210Byte</li><li>1MB = 1024KB = 220Byte</li><li>1GB = 1024MB = 230Byte</li><li>1TB = 1024GB = 240Byte</li><li>1PB = 1024TB = 250Byte</li><li>1EB = 1024PB = 260Byte</li></ul><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span>  </span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这一句话是必须要的格式</span><br><span class="hljs-comment">stdio 表示系统文件库, 也可以声明其它的</span><br><span class="hljs-comment">.h  表示头文件,因为这些文件都是放在程序各文件的开头</span><br><span class="hljs-comment">#include 告诉预处理器将指定头文件的内容插入到预处理器命令的相应位  导入头文件的预编译指令</span><br><span class="hljs-comment">&lt;&gt; 表示系统自带的库</span><br><span class="hljs-comment">也可以写成&quot; &quot; 表示用户自定义的库</span><br><span class="hljs-comment">如果写成&quot; &quot;并且自定义的库里面没有这个文件系统会自动查找自带的库,如果还是没有报错</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-comment">// 程序的入口</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">//程序从这里开始运行</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">int 表示数字格式,返回一个数字</span><br><span class="hljs-comment">main()主函数 表示程序的入口  一个程序有且只能有一个main函数的存在</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello C&quot;</span>); <span class="hljs-comment">//打印一个hello C</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//返回一个整数0,因为它是int类型,所以只能返回整数</span><br>&#125;  <span class="hljs-comment">//程序从这里结束</span><br><br></code></pre></div></td></tr></table></figure><p><strong>标识符</strong></p><p>标识符：在编程语言中，标识符是用户编程时使用的名字，变量、常量、函数、语句块都有名字。是用来标识某个实体的一个符号，是对变量名、函数名、标号和其他各种用户定义的对象命名。</p><p>C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p><p>C 标识符内不允许出现标点字符，比如 @、$ 和 %。<strong>C 是区分大小写的编程语言</strong>。</p><p>C语言中标识符的命名规范：</p><p> 1.标识符由字母、数字、下划线组成，并且首字母不能是数字。<br> 2.不能把C的关键字作为用户的标识符，例如：if、for、while等。（注：标识符不能和C语言的关键字相同，也不能和用户自定义的函数或C语言库函数同名）<br> 3.标识符长度是由机器上的编译系统决定的，一般的限制为8字符，(注：8字符长度限制是C89标准，C99标准已经扩充长度，其实大部分工业标准都更长)。<br> 4.标识符对大小写敏感，即严格区分大小写。一般对变量名用小写，符号常量命名用大写。（注：C语言中字母是区分大小写的，因此score、Score、SCORE分别代表三个不同的标识符）<br> 5.标识符命名应做到”见名知意”，例如，长度（外语：length），求和、总计（外语：sum），圆周率（外语：pi）</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>定义在函数内部的变量称为局部变量（Local Variable），它的作用域仅限于函数内部， 离开该函数后就是无效的，再使用就会报错。</p><p>几点说明：</p><ol><li><p>在 main 函数中定义的变量也是局部变量，只能在 main 函数中使用；同时，main 函数中也不能使用其它函数中定义的变量。main 函数也是一个函数，与其它函数地位平等。</p></li><li><p>形参变量、在函数体内定义的变量都是局部变量。实参给形参传值的过程也就是给局部变量赋值的过程。</p></li><li><p>可以在不同的函数中使用相同的变量名，它们表示不同的数据，分配不同的内存，互不干扰，也不会发生混淆。</p></li><li><p>在语句块中也可定义变量，它的作用域只限于当前语句块。</p></li></ol><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在所有函数外部定义的变量称为全局变量（Global Variable），它的作用域默认是整个程序，也就是所有的源文件，包括 .c 和 .h 文件。</p><p>当全局变量和局部变量同名时，在局部范围内全局变量被“屏蔽”，不再起作用。或者说，变量的使用遵循就近原则，如果在当前作用域中存在同名变量，就不会向更大的作用域中去寻找变量。</p><p>由{ }包围的代码块也拥有独立的作用域。</p><p>C语言规定，只能从小的作用域向大的作用域中去寻找变量，而不能反过来，使用更小的作用域中的变量。</p><h3 id="全局变量和局部变量在内存中的区别"><a href="#全局变量和局部变量在内存中的区别" class="headerlink" title="全局变量和局部变量在内存中的区别"></a>全局变量和局部变量在内存中的区别</h3><p>全局变量保存在内存的全局存储区中，占用静态的存储单元；局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</p><p>C语言经过编译之后将内存分为以下几个区域：</p><p>（1）栈（stack）：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。</p><p>（2）堆（heap）：用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则程序结束时系统自动回收。注意：这里的“堆”并不是数据结构中的“堆”。</p><p>（3）全局（静态）存储区：分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和静态变量；BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。</p><p>（4）文字常量区：存放常量字符串。程序结束后由系统释放。</p><p>（5）程序代码区：存放程序的二进制代码。<br>显然，C语言中的全局变量和局部变量在内存中是有区别的。C语言中的全局变量包括外部变量和静态变量，均是保存在全局存储区中，占用永久性的存储单元；局部变量，即自动变量，保存在栈中，只有在所在函数被调用时才由系统动态在栈中分配临时性的存储单元。</p><h3 id="静态全局变量与静态局部变量"><a href="#静态全局变量与静态局部变量" class="headerlink" title="静态全局变量与静态局部变量"></a>静态全局变量与静态局部变量</h3><p><strong>静态全局变量有以下特点：</strong></p><p>（1）静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量;<br>（2）未经初始化的静态全局变量会被程序自动初始化为0（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为 0）；<br>（3）静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。<br>优点：静态全局变量不能被其它文件所用；其它文件中可以定义相同名字的变量，不会发生冲突。</p><p><strong>全局变量和全局静态变量的区别</strong></p><p>1）全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。<br>2）全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。</p><p><strong>静态局部变量有以下特点：</strong><br>（1）该变量在全局数据区分配内存；<br>（2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；<br>（3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0；<br>（4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。</p><h3 id="变量的作用域规则"><a href="#变量的作用域规则" class="headerlink" title="变量的作用域规则"></a>变量的作用域规则</h3><p>C 语言中有三个地方可以声明变量：</p><p>在函数或块内部的局部变量<br>在所有函数外部的全局变量<br>在形式参数的函数参数定义中</p><p>局部变量<br>在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。函数的形参也是局部变量，也只能在函数内部使用。<br>对局部变量的两点说明：<br>main() 也是一个函数，在 main() 内部定义的变量也是局部变量，只能在 main() 函数内部使用。<br>形参也是局部变量，将实参传递给形参的过程，就是用实参给局部变量赋值的过程，它和a=b; sum=m+n;这样的赋值没有什么区别，如果与全局变量同名它们会优先使用。</p><p>全局变量<br>全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量，也就是所有的代码文件，包括源文件（.c文件）和头文件（.h文件）。如果给全局变量加上 static 关键字，它的作用域就变成了当前文件，在其它文件中就无效了。</p><p>全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用。</p><p>在一个函数内部修改全局变量的值会影响其它函数，全局变量的值在函数内部被修改后并不会自动恢复，它会一直保留该值，直到下次被修改。</p><h3 id="初始化局部变量和全局变量"><a href="#初始化局部变量和全局变量" class="headerlink" title="初始化局部变量和全局变量"></a>初始化局部变量和全局变量</h3><p>当局部变量被定义时，系统不会对其初始化，必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：</p><table><thead><tr><th>数据类型</th><th>初始化默认值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>char</td><td>‘\0’</td></tr><tr><td>float</td><td>0</td></tr><tr><td>double</td><td>0</td></tr><tr><td>pointer</td><td>NULL</td></tr></tbody></table><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>在 C 中，有两种简单的定义常量的方式：</p><h3 id="使用-define-预处理器"><a href="#使用-define-预处理器" class="headerlink" title="使用 #define 预处理器"></a>使用 #define 预处理器</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LENGTH 10   </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WIDTH  5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NEWLINE <span class="hljs-meta-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">int</span> area;  <br><br>area = LENGTH * WIDTH;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;value of area : %d&quot;</span>, area);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, NEWLINE);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="使用-const-关键字"><a href="#使用-const-关键字" class="headerlink" title="使用 const 关键字"></a>使用 const 关键字</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>  LENGTH = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>  WIDTH  = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> NEWLINE = <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">int</span> area;  <br><br>area = LENGTH * WIDTH;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;value of area : %d&quot;</span>, area);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, NEWLINE);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p> #define 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，只进行简单的字符替换，在预编译的时候起作用，不存在类型检查。const是去改变一个变量的存储类，把该变量所占的内存变为只读，也就是这个变量的值不允许改变，是常变量，带有类型。编译运行的时候起作用存在类型检查。</p><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p>(1) 编译器处理方式不同</p><p> #define 宏是在预处理阶段展开。<br> const 常量是编译运行阶段使用。</p><p>(2) 类型和安全检查不同</p><p> #define 宏没有类型，不做任何类型检查，仅仅是展开。<br> const 常量有具体的类型，在编译阶段会执行类型检查。</p><p>(3) 存储方式不同</p><p> #define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）<br>const常量会在内存中分配(可以是堆中也可以是栈中)。</p><p>(4) const 可以节省空间，避免不必要的内存分配。 例如：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUM 3.14159 <span class="hljs-comment">//常量宏</span></span><br><span class="hljs-keyword">const</span> doulbe Num = <span class="hljs-number">3.14159</span>; <span class="hljs-comment">//此时并未将Pi放入ROM中 ......</span><br><span class="hljs-keyword">double</span> i = Num; <span class="hljs-comment">//此时为Pi分配内存，以后不再分配！</span><br><span class="hljs-keyword">double</span> I= NUM; <span class="hljs-comment">//编译期间进行宏替换，分配内存</span><br><span class="hljs-keyword">double</span> j = Num; <span class="hljs-comment">//没有内存分配</span><br><span class="hljs-keyword">double</span> J = NUM; <span class="hljs-comment">//再进行宏替换，又一次分配内存！</span><br></code></pre></div></td></tr></table></figure><p>const 定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象 #define 一样给出的是立即数，所以，const 定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define 定义的常量在内存中有若干个拷贝。</p><p>(5) 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。</p><p>(6) 宏替换只作替换，不做计算，不做表达式求解;宏预编译时就替换了，程序运行时，并不分配内存。</p><p><strong>补充：使用define时要注意边缘效应</strong><br>例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 2+3, N 的值是 5。</span><br><span class="hljs-keyword">double</span> a;<br>a = (<span class="hljs-keyword">float</span>)N/(<span class="hljs-keyword">float</span>)<span class="hljs-number">2</span>;<br></code></pre></div></td></tr></table></figure><p>在编译时我们预想 a=2.5，实际打印结果是 3.5 原因是在预处理阶段，编译器将 a=N/2 处理成 a=2+3/2，这就是 define 宏的边缘效应，所以我们应该写成 #define N (2+3)。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 2+3</span><br><span class="hljs-comment">//正确写法 #define N (2+3)</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;   <br>    <span class="hljs-keyword">double</span> a ;<br>    a = (<span class="hljs-keyword">float</span>)N/(<span class="hljs-keyword">float</span>)<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a 的值为 : %.2f&quot;</span>, a);   <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="const-补充"><a href="#const-补充" class="headerlink" title="const 补充"></a>const 补充</h3><p><strong>const 和指针</strong></p><p>const 也可以和指针变量一起使用，这样可以限制指针变量本身，也可以限制指针指向的数据。const 和指针一起使用会有几种不同的顺序，如下所示：</p><figure class="highlight smali"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs smali">const<span class="hljs-built_in"> int </span>*p1;<br>int<span class="hljs-built_in"> const </span>*p2;<br>int *<span class="hljs-built_in"> const </span>p3;<br></code></pre></div></td></tr></table></figure><p>在最后一种情况下，指针是只读的，也就是 p3 本身的值不能被修改；在前面两种情况下，指针所指向的数据是只读的，也就是 p1、p2 本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。</p><p>当然，指针本身和它指向的数据都有可能是只读的，下面的两种写法能够做到这一点：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> * <span class="hljs-keyword">const</span> p4;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> p5;<br></code></pre></div></td></tr></table></figure><p>记忆方法：const 离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针指向的数据，如果近的和远的都有，那么就同时修饰指针变量以及它指向的数据。</p><p><strong>const 和函数形参</strong></p><p>在C语言中，单独定义 const 变量没有明显的优势，完全可以使用#define命令代替。const 通常用在函数形参中，如果形参是一个指针，为了防止在函数内部修改指针指向的数据，就可以用 const 来限制。</p><p>例如查找字符串中某个字符出现的次数：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strnchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> ch)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i, n = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<br>        <span class="hljs-keyword">if</span>(str[i] == ch)&#123;<br>            n++;<br>        &#125;<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">char</span> *str = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    <span class="hljs-keyword">char</span> ch = <span class="hljs-string">&#x27;o&#x27;</span>;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strnchr</span>(str, ch);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：2</p><p><strong>const 和非 const 类型转换</strong></p><p>当一个指针变量 str1 被 const 限制时，并且类似const char *str1这种形式，说明指针指向的数据不能被修改；如果将 str1 赋值给另外一个未被 const 修饰的指针变量 str2，就有可能发生危险。因为通过 str1 不能修改数据，而赋值后通过 str2 能够修改数据了，意义发生了转变，所以编译器不提倡这种行为，会给出错误或警告。</p><p>也就是说，const char *和char *是不同的类型，不能将const char *类型的数据赋值给char *类型的变量。但反过来是可以的，编译器允许将char *类型的数据赋值给const char *类型的变量。</p><p>这种限制很容易理解，char *指向的数据有读取和写入权限，而const char *指向的数据只有读取权限，降低数据的权限不会带来任何问题，但提升数据的权限就有可能发生危险。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>lqbz</title>
    <link href="/2021/07/lqbz/"/>
    <url>/2021/07/lqbz/</url>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><br>                <span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/.+?(省|市|自治区|自治州|行政区|区|镇|盟|县|旗)/g</span>;<br>                <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;福建省厦门市湖里区XX街XX号&quot;</span>.match(reg))<br>                <br>                <span class="hljs-comment">// 结果： [&quot;福建省&quot;, &quot;厦门市&quot;, &quot;湖里区&quot;]</span><br>                <br><br> <span class="hljs-comment">// var address = &quot;辽宁省沈阳市和平区&quot;; // 以这个地址为例</span><br>      <span class="hljs-comment">// const address = msg.detail;</span><br>      <span class="hljs-comment">// const proExp = &quot;.+[省]&quot;,cityExp = &quot;.+[市]&quot;,disExp = &quot;.+[区]&quot;;</span><br>      <span class="hljs-comment">// const province = address.match(new RegExp(proExp)); // 省</span><br>      <span class="hljs-comment">// const city = address.match(new RegExp(cityExp))[0].replace(province, &quot;&quot;); // 市</span><br>      <span class="hljs-comment">// const district = address.match(new RegExp(disExp))[0].replace(province, &quot;&quot;).replace(city, &quot;&quot;); // 区</span><br><br><br>      <span class="hljs-keyword">let</span> regex = <span class="hljs-string">&quot;(?&lt;province&gt;[^省]+省|[^市]+市|[^行政区]+行政区|.+自治区)(?&lt;city&gt;[^自治州]+自治州|[^市]+市|[^盟]+盟|[^地区]+地区|[^城区]+城区|[^林区]+林区|[^自治县]+自治县|.+区划)(?&lt;county&gt;[^市]+市|[^县]+县|[^旗]+旗|.+区)?(?&lt;town&gt;[^区]+区|.+镇)?(?&lt;village&gt;.*)&quot;</span>;<br>      <span class="hljs-keyword">let</span> address = <span class="hljs-string">&quot;上海市上海城区闵行区东方红东方红&quot;</span>;<br>      <span class="hljs-built_in">console</span>.log(address.match(regex));<br><br><span class="hljs-keyword">var</span> str=<span class="hljs-string">&#x27;&#x27;</span><br>      <span class="hljs-keyword">if</span>(str.indexOf(<span class="hljs-string">&quot;省&quot;</span>) != -<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">var</span> sheng=str.split(<span class="hljs-string">&#x27;省&#x27;</span>)[<span class="hljs-number">0</span>]+<span class="hljs-string">&#x27;省&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(str.indexOf(<span class="hljs-string">&quot;市&quot;</span>) != -<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">var</span> shi=str.split(<span class="hljs-string">&#x27;市&#x27;</span>)[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27;省&#x27;</span>)[<span class="hljs-number">1</span>]+<span class="hljs-string">&#x27;市&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(str.indexOf(<span class="hljs-string">&quot;区&quot;</span>) != -<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">var</span> qu=str.split(<span class="hljs-string">&#x27;区&#x27;</span>)[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27;市&#x27;</span>)[<span class="hljs-number">1</span>]+<span class="hljs-string">&#x27;区&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">var</span> add =sheng+shi+qu<br>    <span class="hljs-built_in">console</span>.log(add);<br></code></pre></div></td></tr></table></figure><table><thead><tr><th><a href="https://www.cnblogs.com/cjw-blogs/p/11981222.html">https://www.cnblogs.com/cjw-blogs/p/11981222.html</a></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><a href="https://blog.csdn.net/Fxhani/article/details/108605160">https://blog.csdn.net/Fxhani/article/details/108605160</a></th></tr></thead><tbody><tr><td></td></tr></tbody></table><table><thead><tr><th><a href="https://blog.csdn.net/Fxhani/article/details/108605160">https://blog.csdn.net/Fxhani/article/details/108605160</a></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p><a href="https://blog.csdn.net/qq_40542728/article/details/95490634">https://blog.csdn.net/qq_40542728/article/details/95490634</a></p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>CSS3+SVG评星效果<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span> <br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br>* &#123;<br><span class="css">  <span class="hljs-attribute">box-sizing</span>: border-box;</span><br>&#125;<br><span class="css"><span class="hljs-selector-tag">body</span>&#123;</span><br><span class="css"><span class="hljs-attribute">background-color</span>: <span class="hljs-number">#232323</span>;</span><br>&#125;<br>.container &#123;<br><span class="css"><span class="hljs-attribute">display</span>: flex;</span><br><span class="css"><span class="hljs-attribute">flex-wrap</span>: wrap;</span><br><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;</span><br><span class="css"><span class="hljs-attribute">align-items</span>: center;</span><br><span class="css"><span class="hljs-attribute">justify-content</span>: center;</span><br><span class="css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">20px</span>;</span><br>&#125;<br><br>.rating &#123;<br><span class="css">  <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">  <span class="hljs-attribute">justify-content</span>: center;</span><br><span class="css">  <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="css">  <span class="hljs-attribute">flex-direction</span>: row-reverse;</span><br><span class="css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;</span><br><span class="css">  <span class="hljs-attribute">position</span>: relative;</span><br>&#125;<br><br>.rating-0 &#123;<br><span class="css">  -webkit-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);</span><br><span class="css">          <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);</span><br>&#125;<br><br><span class="css"><span class="hljs-selector-class">.rating</span> &gt; <span class="hljs-selector-tag">input</span> &#123;</span><br><span class="css">  <span class="hljs-attribute">display</span>: none;</span><br>&#125;<br><br><span class="css"><span class="hljs-selector-class">.rating</span> &gt; <span class="hljs-selector-tag">label</span> &#123;</span><br><span class="css">  <span class="hljs-attribute">cursor</span>: pointer;</span><br><span class="css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">40px</span>;</span><br><span class="css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;</span><br><span class="css">  <span class="hljs-attribute">margin-top</span>: auto;</span><br><span class="css">  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;data:image/svg+xml;charset=UTF-8,%3csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; width=&#x27;126.729&#x27; height=&#x27;126.73&#x27;%3e%3cpath fill=&#x27;%23e3e3e3&#x27; d=&#x27;M121.215 44.212l-34.899-3.3c-2.2-.2-4.101-1.6-5-3.7l-12.5-30.3c-2-5-9.101-5-11.101 0l-12.4 30.3c-.8 2.1-2.8 3.5-5 3.7l-34.9 3.3c-5.2.5-7.3 7-3.4 10.5l26.3 23.1c1.7 1.5 2.4 3.7 1.9 5.9l-7.9 32.399c-1.2 5.101 4.3 9.3 8.9 6.601l29.1-17.101c1.9-1.1 4.2-1.1 6.1 0l29.101 17.101c4.6 2.699 10.1-1.4 8.899-6.601l-7.8-32.399c-.5-2.2.2-4.4 1.9-5.9l26.3-23.1c3.8-3.5 1.6-10-3.6-10.5z&#x27;/%3e%3c/svg%3e&quot;</span>);</span><br><span class="css">  <span class="hljs-attribute">background-repeat</span>: no-repeat;</span><br><span class="css">  <span class="hljs-attribute">background-position</span>: center;</span><br><span class="css">  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">76%</span>;</span><br><span class="css">  <span class="hljs-attribute">transition</span>: .<span class="hljs-number">3s</span>;</span><br>&#125;<br><br><span class="css"><span class="hljs-selector-class">.rating</span> &gt; <span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-tag">label</span>,</span><br><span class="css"><span class="hljs-selector-class">.rating</span> &gt; <span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-tag">label</span> ~ <span class="hljs-selector-tag">label</span> &#123;</span><br><span class="css">  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;data:image/svg+xml;charset=UTF-8,%3csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; width=&#x27;126.729&#x27; height=&#x27;126.73&#x27;%3e%3cpath fill=&#x27;%23fcd93a&#x27; d=&#x27;M121.215 44.212l-34.899-3.3c-2.2-.2-4.101-1.6-5-3.7l-12.5-30.3c-2-5-9.101-5-11.101 0l-12.4 30.3c-.8 2.1-2.8 3.5-5 3.7l-34.9 3.3c-5.2.5-7.3 7-3.4 10.5l26.3 23.1c1.7 1.5 2.4 3.7 1.9 5.9l-7.9 32.399c-1.2 5.101 4.3 9.3 8.9 6.601l29.1-17.101c1.9-1.1 4.2-1.1 6.1 0l29.101 17.101c4.6 2.699 10.1-1.4 8.899-6.601l-7.8-32.399c-.5-2.2.2-4.4 1.9-5.9l26.3-23.1c3.8-3.5 1.6-10-3.6-10.5z&#x27;/%3e%3c/svg%3e&quot;</span>);</span><br>&#125;<br><br><span class="css"><span class="hljs-selector-class">.rating</span> &gt; <span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-pseudo">:checked</span>) ~ <span class="hljs-selector-tag">label</span><span class="hljs-selector-pseudo">:hover</span>,</span><br><span class="css"><span class="hljs-selector-class">.rating</span> &gt; <span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-pseudo">:checked</span>) ~ <span class="hljs-selector-tag">label</span><span class="hljs-selector-pseudo">:hover</span> ~ <span class="hljs-selector-tag">label</span> &#123;</span><br><span class="css">  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;data:image/svg+xml;charset=UTF-8,%3csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; width=&#x27;126.729&#x27; height=&#x27;126.73&#x27;%3e%3cpath fill=&#x27;%23d8b11e&#x27; d=&#x27;M121.215 44.212l-34.899-3.3c-2.2-.2-4.101-1.6-5-3.7l-12.5-30.3c-2-5-9.101-5-11.101 0l-12.4 30.3c-.8 2.1-2.8 3.5-5 3.7l-34.9 3.3c-5.2.5-7.3 7-3.4 10.5l26.3 23.1c1.7 1.5 2.4 3.7 1.9 5.9l-7.9 32.399c-1.2 5.101 4.3 9.3 8.9 6.601l29.1-17.101c1.9-1.1 4.2-1.1 6.1 0l29.101 17.101c4.6 2.699 10.1-1.4 8.899-6.601l-7.8-32.399c-.5-2.2.2-4.4 1.9-5.9l26.3-23.1c3.8-3.5 1.6-10-3.6-10.5z&#x27;/%3e%3c/svg%3e&quot;</span>);</span><br>&#125;<br><br>.emoji-wrapper &#123;<br><span class="css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">  <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">  <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="css">  <span class="hljs-attribute">position</span>: absolute;</span><br><span class="css">  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="css">  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br>&#125;<br><br>.emoji-wrapper:before,<br>.emoji-wrapper:after &#123;<br><span class="css">  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">15px</span>;</span><br><span class="css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">  <span class="hljs-attribute">position</span>: absolute;</span><br><span class="css">  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="css">  <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>;</span><br>&#125;<br><br>.emoji-wrapper:before &#123;<br><span class="css">  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="css">  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to bottom, white <span class="hljs-number">0%</span>, white <span class="hljs-number">35%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>) <span class="hljs-number">100%</span>);</span><br>&#125;<br><br>.emoji-wrapper:after &#123;<br><span class="css">  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br><span class="css">  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to top, white <span class="hljs-number">0%</span>, white <span class="hljs-number">35%</span>, <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>) <span class="hljs-number">100%</span>);</span><br>&#125;<br><br>.emoji &#123;<br><span class="css">  <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">  <span class="hljs-attribute">flex-direction</span>: column;</span><br><span class="css">  <span class="hljs-attribute">align-items</span>: center;</span><br><span class="css">  <span class="hljs-attribute">transition</span>: .<span class="hljs-number">3s</span>;</span><br>&#125;<br><br>.emoji &gt; svg &#123;<br><span class="css">  <span class="hljs-attribute">margin</span>: <span class="hljs-number">15px</span> <span class="hljs-number">0</span>;</span><br><span class="css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">70px</span>;</span><br><span class="css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">70px</span>;</span><br><span class="css">  <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">0</span>;</span><br>&#125;<br><br><span class="css"><span class="hljs-selector-id">#rating-1</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.emoji-wrapper</span> &gt; <span class="hljs-selector-class">.emoji</span> &#123;</span><br><span class="css">  -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">100px</span>);</span><br><span class="css">          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">100px</span>);</span><br>&#125;<br><br><span class="css"><span class="hljs-selector-id">#rating-2</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.emoji-wrapper</span> &gt; <span class="hljs-selector-class">.emoji</span> &#123;</span><br><span class="css">  -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">200px</span>);</span><br><span class="css">          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">200px</span>);</span><br>&#125;<br><br><span class="css"><span class="hljs-selector-id">#rating-3</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.emoji-wrapper</span> &gt; <span class="hljs-selector-class">.emoji</span> &#123;</span><br><span class="css">  -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">300px</span>);</span><br><span class="css">          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">300px</span>);</span><br>&#125;<br><br><span class="css"><span class="hljs-selector-id">#rating-4</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.emoji-wrapper</span> &gt; <span class="hljs-selector-class">.emoji</span> &#123;</span><br><span class="css">  -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">400px</span>);</span><br><span class="css">          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">400px</span>);</span><br>&#125;<br><br><span class="css"><span class="hljs-selector-id">#rating-5</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.emoji-wrapper</span> &gt; <span class="hljs-selector-class">.emoji</span> &#123;</span><br><span class="css">  -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">500px</span>);</span><br><span class="css">          <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">500px</span>);</span><br>&#125;<br><br>.feedback &#123;<br><span class="css">  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">360px</span>;</span><br><span class="css">  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">  <span class="hljs-attribute">padding</span>: <span class="hljs-number">30px</span>;</span><br><span class="css">  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;</span><br><span class="css">  <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">  <span class="hljs-attribute">flex-direction</span>: column;</span><br><span class="css">  <span class="hljs-attribute">flex-wrap</span>: wrap;</span><br><span class="css">  <span class="hljs-attribute">align-items</span>: center;</span><br><span class="css">  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">4px</span> <span class="hljs-number">30px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.05</span>);</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>  <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 900px;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;feedback&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rating&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rating&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rating-5&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;rating-5&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rating&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rating-4&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;rating-4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rating&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rating-3&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;rating-3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rating&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rating-2&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;rating-2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rating&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rating-1&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;rating-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;emoji-wrapper&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;emoji&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rating-0&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&quot;0 0 512 512&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#ffd93b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M512 256c0 141.44-114.64 256-256 256-80.48 0-152.32-37.12-199.28-95.28 43.92 35.52 99.84 56.72 160.72 56.72 141.36 0 256-114.56 256-256 0-60.88-21.2-116.8-56.72-160.72C474.8 103.68 512 175.52 512 256z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#f4c534&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&quot;scale(-1) rotate(31.21 715.433 -595.455)&quot;</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;166.318&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;199.829&quot;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&quot;56.146&quot;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&quot;56.13&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#fff&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ellipse</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&quot;rotate(-148.804 180.87 175.82)&quot;</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;180.871&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;175.822&quot;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&quot;28.048&quot;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&quot;28.08&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#3e4347&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ellipse</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&quot;rotate(-113.778 194.434 165.995)&quot;</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;194.433&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;165.993&quot;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&quot;8.016&quot;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&quot;5.296&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#5a5f63&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ellipse</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&quot;scale(-1) rotate(31.21 715.397 -1237.664)&quot;</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;345.695&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;199.819&quot;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&quot;56.146&quot;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&quot;56.13&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#fff&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ellipse</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&quot;rotate(-148.804 360.25 175.837)&quot;</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;360.252&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;175.84&quot;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&quot;28.048&quot;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&quot;28.08&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#3e4347&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ellipse</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&quot;scale(-1) rotate(66.227 254.508 -573.138)&quot;</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;373.794&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;165.987&quot;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&quot;8.016&quot;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&quot;5.296&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#5a5f63&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ellipse</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M370.56 344.4c0 7.696-6.224 13.92-13.92 13.92H155.36c-7.616 0-13.92-6.224-13.92-13.92s6.304-13.92 13.92-13.92h201.296c7.696.016 13.904 6.224 13.904 13.92z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#3e4347&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rating-1&quot;</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&quot;0 0 512 512&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#ffd93b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M512 256A256 256 0 0 1 56.7 416.7a256 256 0 0 0 360-360c58.1 47 95.3 118.8 95.3 199.3z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#f4c534&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M328.4 428a92.8 92.8 0 0 0-145-.1 6.8 6.8 0 0 1-12-5.8 86.6 86.6 0 0 1 84.5-69 86.6 86.6 0 0 1 84.7 69.8c1.3 6.9-7.7 10.6-12.2 5.1z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#3e4347&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M269.2 222.3c5.3 62.8 52 113.9 104.8 113.9 52.3 0 90.8-51.1 85.6-113.9-2-25-10.8-47.9-23.7-66.7-4.1-6.1-12.2-8-18.5-4.2a111.8 111.8 0 0 1-60.1 16.2c-22.8 0-42.1-5.6-57.8-14.8-6.8-4-15.4-1.5-18.9 5.4-9 18.2-13.2 40.3-11.4 64.1z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#f4c534&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M357 189.5c25.8 0 47-7.1 63.7-18.7 10 14.6 17 32.1 18.7 51.6 4 49.6-26.1 89.7-67.5 89.7-41.6 0-78.4-40.1-82.5-89.7A95 95 0 0 1 298 174c16 9.7 35.6 15.5 59 15.5z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#fff&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M396.2 246.1a38.5 38.5 0 0 1-38.7 38.6 38.5 38.5 0 0 1-38.6-38.6 38.6 38.6 0 1 1 77.3 0z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#3e4347&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M380.4 241.1c-3.2 3.2-9.9 1.7-14.9-3.2-4.8-4.8-6.2-11.5-3-14.7 3.3-3.4 10-2 14.9 2.9 4.9 5 6.4 11.7 3 15z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#fff&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M242.8 222.3c-5.3 62.8-52 113.9-104.8 113.9-52.3 0-90.8-51.1-85.6-113.9 2-25 10.8-47.9 23.7-66.7 4.1-6.1 12.2-8 18.5-4.2 16.2 10.1 36.2 16.2 60.1 16.2 22.8 0 42.1-5.6 57.8-14.8 6.8-4 15.4-1.5 18.9 5.4 9 18.2 13.2 40.3 11.4 64.1z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#f4c534&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M155 189.5c-25.8 0-47-7.1-63.7-18.7-10 14.6-17 32.1-18.7 51.6-4 49.6 26.1 89.7 67.5 89.7 41.6 0 78.4-40.1 82.5-89.7A95 95 0 0 0 214 174c-16 9.7-35.6 15.5-59 15.5z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#fff&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M115.8 246.1a38.5 38.5 0 0 0 38.7 38.6 38.5 38.5 0 0 0 38.6-38.6 38.6 38.6 0 1 0-77.3 0z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#3e4347&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M131.6 241.1c3.2 3.2 9.9 1.7 14.9-3.2 4.8-4.8 6.2-11.5 3-14.7-3.3-3.4-10-2-14.9 2.9-4.9 5-6.4 11.7-3 15z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#fff&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rating-2&quot;</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&quot;0 0 512 512&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#ffd93b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M512 256A256 256 0 0 1 56.7 416.7a256 256 0 0 0 360-360c58.1 47 95.3 118.8 95.3 199.3z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#f4c534&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M336.6 403.2c-6.5 8-16 10-25.5 5.2a117.6 117.6 0 0 0-110.2 0c-9.4 4.9-19 3.3-25.6-4.6-6.5-7.7-4.7-21.1 8.4-28 45.1-24 99.5-24 144.6 0 13 7 14.8 19.7 8.3 27.4z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#3e4347&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M276.6 244.3a79.3 79.3 0 1 1 158.8 0 79.5 79.5 0 1 1-158.8 0z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#fff&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;340&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;260.4&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;36.2&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#3e4347&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#fff&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&quot;rotate(-135 326.4 246.6)&quot;</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;326.4&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;246.6&quot;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&quot;6.5&quot;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ellipse</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M231.9 244.3a79.3 79.3 0 1 0-158.8 0 79.5 79.5 0 1 0 158.8 0z&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;168.5&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;260.4&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;36.2&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#3e4347&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&quot;rotate(-135 182.1 246.7)&quot;</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;182.1&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;246.7&quot;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&quot;6.5&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#fff&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ellipse</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rating-3&quot;</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&quot;0 0 512 512&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#ffd93b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M407.7 352.8a163.9 163.9 0 0 1-303.5 0c-2.3-5.5 1.5-12 7.5-13.2a780.8 780.8 0 0 1 288.4 0c6 1.2 9.9 7.7 7.6 13.2z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#3e4347&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M512 256A256 256 0 0 1 56.7 416.7a256 256 0 0 0 360-360c58.1 47 95.3 118.8 95.3 199.3z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#f4c534&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#fff&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M115.3 339c18.2 29.6 75.1 32.8 143.1 32.8 67.1 0 124.2-3.2 143.2-31.6l-1.5-.6a780.6 780.6 0 0 0-284.8-.6z&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;356.4&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;205.3&quot;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&quot;81.1&quot;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&quot;81&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ellipse</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;356.4&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;205.3&quot;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&quot;44.2&quot;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&quot;44.2&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#3e4347&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ellipse</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#fff&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&quot;scale(-1) rotate(45 454 -906)&quot;</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;375.3&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;188.1&quot;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&quot;12&quot;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&quot;8.1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ellipse</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;155.6&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;205.3&quot;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&quot;81.1&quot;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&quot;81&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ellipse</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;155.6&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;205.3&quot;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&quot;44.2&quot;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&quot;44.2&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#3e4347&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ellipse</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ellipse</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&quot;scale(-1) rotate(45 454 -421.3)&quot;</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;174.5&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;188&quot;</span> <span class="hljs-attr">rx</span>=<span class="hljs-string">&quot;12&quot;</span> <span class="hljs-attr">ry</span>=<span class="hljs-string">&quot;8.1&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#fff&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ellipse</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rating-4&quot;</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&quot;0 0 512 512&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#ffd93b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M512 256A256 256 0 0 1 56.7 416.7a256 256 0 0 0 360-360c58.1 47 95.3 118.8 95.3 199.3z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#f4c534&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M232.3 201.3c0 49.2-74.3 94.2-74.3 94.2s-74.4-45-74.4-94.2a38 38 0 0 1 74.4-11.1 38 38 0 0 1 74.3 11.1z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#e24b4b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M96.1 173.3a37.7 37.7 0 0 0-12.4 28c0 49.2 74.3 94.2 74.3 94.2C80.2 229.8 95.6 175.2 96 173.3z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#d03f3f&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M215.2 200c-3.6 3-9.8 1-13.8-4.1-4.2-5.2-4.6-11.5-1.2-14.1 3.6-2.8 9.7-.7 13.9 4.4 4 5.2 4.6 11.4 1.1 13.8z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#fff&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M428.4 201.3c0 49.2-74.4 94.2-74.4 94.2s-74.3-45-74.3-94.2a38 38 0 0 1 74.4-11.1 38 38 0 0 1 74.3 11.1z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#e24b4b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M292.2 173.3a37.7 37.7 0 0 0-12.4 28c0 49.2 74.3 94.2 74.3 94.2-77.8-65.7-62.4-120.3-61.9-122.2z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#d03f3f&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M411.3 200c-3.6 3-9.8 1-13.8-4.1-4.2-5.2-4.6-11.5-1.2-14.1 3.6-2.8 9.7-.7 13.9 4.4 4 5.2 4.6 11.4 1.1 13.8z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#fff&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M381.7 374.1c-30.2 35.9-75.3 64.4-125.7 64.4s-95.4-28.5-125.8-64.2a17.6 17.6 0 0 1 16.5-28.7 627.7 627.7 0 0 0 218.7-.1c16.2-2.7 27 16.1 16.3 28.6z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#3e4347&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M256 438.5c25.7 0 50-7.5 71.7-19.5-9-33.7-40.7-43.3-62.6-31.7-29.7 15.8-62.8-4.7-75.6 34.3 20.3 10.4 42.8 17 66.5 17z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#e24b4b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rating-5&quot;</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&quot;0 0 512 512&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#ffd93b&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;256&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;256&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circle</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M512 256A256 256 0 0 1 56.8 416.7a256 256 0 0 0 360-360c58 47 95.2 118.8 95.2 199.3z&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M512 99.4v165.1c0 11-8.9 19.9-19.7 19.9h-187c-13 0-23.5-10.5-23.5-23.5v-21.3c0-12.9-8.9-24.8-21.6-26.7-16.2-2.5-30 10-30 25.5V261c0 13-10.5 23.5-23.5 23.5h-187A19.7 19.7 0 0 1 0 264.7V99.4c0-10.9 8.8-19.7 19.7-19.7h472.6c10.8 0 19.7 8.7 19.7 19.7z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#e9eff4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M204.6 138v88.2a23 23 0 0 1-23 23H58.2a23 23 0 0 1-23-23v-88.3a23 23 0 0 1 23-23h123.4a23 23 0 0 1 23 23z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#45cbea&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M476.9 138v88.2a23 23 0 0 1-23 23H330.3a23 23 0 0 1-23-23v-88.3a23 23 0 0 1 23-23h123.4a23 23 0 0 1 23 23z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#e84d88&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#38c0dc&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M95.2 114.9l-60 60v15.2l75.2-75.2zM123.3 114.9L35.1 203v23.2c0 1.8.3 3.7.7 5.4l116.8-116.7h-29.3z&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#d23f77&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M373.3 114.9l-66 66V196l81.3-81.2zM401.5 114.9l-94.1 94v17.3c0 3.5.8 6.8 2.2 9.8l121.1-121.1h-29.2z&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M329.5 395.2c0 44.7-33 81-73.4 81-40.7 0-73.5-36.3-73.5-81s32.8-81 73.5-81c40.5 0 73.4 36.3 73.4 81z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#3e4347&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M256 476.2a70 70 0 0 0 53.3-25.5 34.6 34.6 0 0 0-58-25 34.4 34.4 0 0 0-47.8 26 69.9 69.9 0 0 0 52.6 24.5z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#e24b4b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M290.3 434.8c-1 3.4-5.8 5.2-11 3.9s-8.4-5.1-7.4-8.7c.8-3.3 5.7-5 10.7-3.8 5.1 1.4 8.5 5.3 7.7 8.6z&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#fff&quot;</span> <span class="hljs-attr">opacity</span>=<span class="hljs-string">&quot;.2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><a href="https://github.com/sma11black/hexo-action">https://github.com/sma11black/hexo-action</a> <a href="https://blog.csdn.net/qq_41426117/article/details/108703295">https://blog.csdn.net/qq_41426117/article/details/108703295</a> <a href="https://blog.csdn.net/u012208219/article/details/106883054?ops_request_misc=%7B%22request_id%22:%22160061139819195188346686%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=160061139819195188346686&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v3~pc_rank_v3-1-106883054.pc_ecpm_v3_pc_rank_v3&utm_term=github+action+%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo&spm=1018.2118.3001.4187">https://blog.csdn.net/u012208219/article/details/106883054?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160061139819195188346686%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160061139819195188346686&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>first_rank_ecpm_v3~pc_rank_v3-1-106883054.pc_ecpm_v3_pc_rank_v3&amp;utm_term=github+action+%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo&amp;spm=1018.2118.3001.4187</a> <a href="https://www.cnblogs.com/deppwang/p/12326906.html">https://www.cnblogs.com/deppwang/p/12326906.html</a> <a href="https://www.antmoe.com/posts/6081157f/index.html#%E6%B7%BB%E5%8A%A0actions">https://www.antmoe.com/posts/6081157f/index.html#%E6%B7%BB%E5%8A%A0actions</a> <a href="https://www.jianshu.com/p/7dbbe8b1a866">https://www.jianshu.com/p/7dbbe8b1a866</a> <a href="https://segmentfault.com/a/1190000022360769">https://segmentfault.com/a/1190000022360769</a> <a href="https://zhuanlan.zhihu.com/p/137867759">https://zhuanlan.zhihu.com/p/137867759</a></p><p><a href="https://github.com/actions/cache">https://github.com/actions/cache</a></p><p><a href="https://github.com/actions/checkout">https://github.com/actions/checkout</a></p><p><a href="https://github.com/actions/setup-node">https://github.com/actions/setup-node</a></p><p><a href="https://github.com/actions/cache/blob/main/examples.md#node---npm">https://github.com/actions/cache/blob/main/examples.md#node---npm</a></p><p><a href="https://docs.github.com/cn/actions/guides/caching-dependencies-to-speed-up-workflows">https://docs.github.com/cn/actions/guides/caching-dependencies-to-speed-up-workflows</a></p><p><a href="https://github.com/ElpsyCN/el-bot-api/blob/8aa3c64fe7cb715349c14b363ef4c43996c5ef8a/data/setu.json">https://github.com/ElpsyCN/el-bot-api/blob/8aa3c64fe7cb715349c14b363ef4c43996c5ef8a/data/setu.json</a></p><p>let regex =  “(?[^省]+省|[^市]+市|[^行政区]+行政区|.+自治区)(?[^自治州]+自治州|[^市]+市|[^盟]+盟|[^地区]+地区|[^城区]+城区|[^林区]+林区|[^自治县]+自治县|.+区划)(?[^市]+市|[^县]+县|[^旗]+旗|.+区)?(?[^区]+区|.+镇)?(?.*)”;</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【转】Git/SVN提交代码规范</title>
    <link href="/2020/07/commit-standard/"/>
    <url>/2020/07/commit-standard/</url>
    
    <content type="html"><![CDATA[<figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit">feat - 新功能 feature<br>fix - 修复 bug<br>docs - 文档注释<br>style - 代码格式(不影响代码运行的变动)<br>refactor - 重构、优化(既不增加新功能，也不是修复bug)<br>perf - 性能优化<br><span class="hljs-keyword">test </span>- 增加测试<br>chore - 构建过程或辅助工具的变动<br>revert - 回退<br>build - 打包<br></code></pre></div></td></tr></table></figure><p>示例：</p><p><img src="" srcset="/img/loading.gif" lazyload></p><p><strong>原文链接：</strong><a href="https://www.cnblogs.com/PeunZhang/p/11507454.html">Git/SVN提交代码规范</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>富文本编辑器 Summernote 从入门到放弃（实例篇）</title>
    <link href="/2020/07/summernote-example/"/>
    <url>/2020/07/summernote-example/</url>
    
    <content type="html"><![CDATA[<p>前篇把Summernote的用法和配置基本都介绍了一遍，本篇就来实现一个完整的富文本编辑器吧。</p><h2 id="需要引入的文件"><a href="#需要引入的文件" class="headerlink" title="需要引入的文件"></a>需要引入的文件</h2><p>CSS</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/bootstrap.min.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/summernote.min.css&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>JavaScript</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/jquery-1.11.0.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/bootstrap.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/summernote.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;lang/summernote-zh-CN.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/summernote-cleaner.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="初始化富文本编辑器"><a href="#初始化富文本编辑器" class="headerlink" title="初始化富文本编辑器"></a>初始化富文本编辑器</h2><p>HTML</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;summernote&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>JavaScript</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> $summernote = $(<span class="hljs-string">&#x27;#summernote&#x27;</span>).summernote(&#123;<br>    height: <span class="hljs-number">350</span>,<br>    lang: <span class="hljs-string">&#x27;zh-CN&#x27;</span>,<br>    disableDragAndDrop: <span class="hljs-literal">true</span>,<br>    toolbar: [<br>        [<span class="hljs-string">&#x27;style&#x27;</span>, [<span class="hljs-string">&#x27;style&#x27;</span>]],<br>        [<span class="hljs-string">&#x27;font&#x27;</span>, [<span class="hljs-string">&#x27;bold&#x27;</span>, <span class="hljs-string">&#x27;underline&#x27;</span>, <span class="hljs-string">&#x27;clear&#x27;</span>]],<br>        [<span class="hljs-string">&#x27;fontname&#x27;</span>, [<span class="hljs-string">&#x27;fontname&#x27;</span>]],<br>        [<span class="hljs-string">&#x27;color&#x27;</span>, [<span class="hljs-string">&#x27;color&#x27;</span>]],<br>        [<span class="hljs-string">&#x27;para&#x27;</span>, [<span class="hljs-string">&#x27;ul&#x27;</span>, <span class="hljs-string">&#x27;ol&#x27;</span>, <span class="hljs-string">&#x27;paragraph&#x27;</span>]],<br>        [<span class="hljs-string">&#x27;table&#x27;</span>, [<span class="hljs-string">&#x27;table&#x27;</span>]],<br>        [<span class="hljs-string">&#x27;insert&#x27;</span>, [<span class="hljs-string">&#x27;link&#x27;</span>, <span class="hljs-string">&#x27;picture&#x27;</span>]],<br>        [<span class="hljs-string">&#x27;view&#x27;</span>, [<span class="hljs-string">&#x27;fullscreen&#x27;</span>,<span class="hljs-string">&#x27;undo&#x27;</span>,<span class="hljs-string">&#x27;redo&#x27;</span>]]<br>      ],<br>    styleTags: [<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-string">&#x27;h2&#x27;</span>, <span class="hljs-string">&#x27;h3&#x27;</span>, <span class="hljs-string">&#x27;h4&#x27;</span>, <span class="hljs-string">&#x27;h5&#x27;</span>, <span class="hljs-string">&#x27;h6&#x27;</span>],<br>    fontNames: [<span class="hljs-string">&#x27;微软雅黑&#x27;</span>,<span class="hljs-string">&#x27;宋体&#x27;</span>,<span class="hljs-string">&#x27;Arial&#x27;</span>, <span class="hljs-string">&#x27;Arial Black&#x27;</span>, <br>    <span class="hljs-string">&#x27;Comic Sans MS&#x27;</span>, <span class="hljs-string">&#x27;Courier New&#x27;</span>, <span class="hljs-string">&#x27;Merriweather&#x27;</span>,<span class="hljs-string">&#x27;Tahoma&#x27;</span>,<span class="hljs-string">&#x27;Verdana&#x27;</span>]<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>这样一个完整的富文本编辑器就出现了：</p><p><img src="" srcset="/img/loading.gif" lazyload></p><p>接下来根据需要加点别的功能：</p><h2 id="设置行高"><a href="#设置行高" class="headerlink" title="设置行高"></a>设置行高</h2><p>在初始化的js中添加下面两段的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript">$(<span class="hljs-string">&#x27;#summernote&#x27;</span>).summernote(&#123;<br>  toolbar: [<br>    [<span class="hljs-string">&#x27;height&#x27;</span>, [<span class="hljs-string">&#x27;height&#x27;</span>]],<span class="hljs-comment">//行高(自定义行高时一定不要忘记写这个)</span><br>  ],<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>下面的代码如果添加到最后一项后面的话，需要给最后一项后面加上逗号再添加。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript">$(<span class="hljs-string">&#x27;#summernote&#x27;</span>).summernote(&#123;<br> lineHeights: [<span class="hljs-string">&#x27;0.5&#x27;</span>,<span class="hljs-string">&#x27;1.0&#x27;</span>, <span class="hljs-string">&#x27;1.2&#x27;</span>, <span class="hljs-string">&#x27;1.4&#x27;</span>, <span class="hljs-string">&#x27;1.5&#x27;</span>, <span class="hljs-string">&#x27;1.6&#x27;</span>, <span class="hljs-string">&#x27;1.8&#x27;</span>, <span class="hljs-string">&#x27;2.0&#x27;</span>, <span class="hljs-string">&#x27;9.0&#x27;</span>],<br>&#125;);<br></code></pre></div></td></tr></table></figure><p><img src="" srcset="/img/loading.gif" lazyload></p><h2 id="清除复制文本的格式"><a href="#清除复制文本的格式" class="headerlink" title="清除复制文本的格式"></a>清除复制文本的格式</h2><p>清除格式的功能需要引入插件来实现，到<a href="https://github.com/DiemenDesign/summernote-cleaner">这里</a>下载需要的JS文件，然后引入文件，在初始化编辑器的JS中添加下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript">$(<span class="hljs-string">&#x27;#summernote&#x27;</span>).summernote(&#123;<br>  cleaner:&#123;<br>    action: <span class="hljs-string">&#x27;both&#x27;</span>, <span class="hljs-comment">// both|button|paste &#x27;button&#x27; only cleans via toolbar button, &#x27;paste&#x27; only clean when pasting content, both does both options.</span><br>    <span class="hljs-comment">// newline: &#x27;&lt;br&gt;&#x27;, // Summernote&#x27;s default is to use &#x27;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&#x27;</span><br>    notStyle: <span class="hljs-string">&#x27;position:absolute;top:0;left:0;right:0&#x27;</span>, <span class="hljs-comment">// Position of Notification</span><br>    <span class="hljs-comment">// icon: &#x27;&lt;i class=&quot;note-icon&quot;&gt;[Your Button]&lt;/i&gt;&#x27;, //按钮图标</span><br>    keepHtml: <span class="hljs-literal">false</span>, <span class="hljs-comment">// Remove all Html formats</span><br>    keepOnlyTags: [<span class="hljs-string">&#x27;&lt;p&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;ul&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;li&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;b&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;strong&gt;&#x27;</span>,<span class="hljs-string">&#x27;&lt;i&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;a&gt;&#x27;</span>], <span class="hljs-comment">// If keepHtml is true, remove all tags except these</span><br>    keepClasses: <span class="hljs-literal">false</span>, <span class="hljs-comment">// Remove Classes</span><br>    badTags: [<span class="hljs-string">&#x27;style&#x27;</span>, <span class="hljs-string">&#x27;script&#x27;</span>, <span class="hljs-string">&#x27;applet&#x27;</span>, <span class="hljs-string">&#x27;embed&#x27;</span>, <span class="hljs-string">&#x27;noframes&#x27;</span>, <span class="hljs-string">&#x27;noscript&#x27;</span>, <span class="hljs-string">&#x27;html&#x27;</span>], <span class="hljs-comment">// Remove full tags with contents</span><br>    badAttributes: [<span class="hljs-string">&#x27;style&#x27;</span>, <span class="hljs-string">&#x27;start&#x27;</span>], <span class="hljs-comment">// Remove attributes from remaining tags</span><br>    limitChars: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 0/false|# 0/false disables option</span><br>    limitDisplay: <span class="hljs-string">&#x27;text&#x27;</span>, <span class="hljs-comment">// text|html|both</span><br>    limitStop: <span class="hljs-literal">false</span> <span class="hljs-comment">// true/false</span><br>  &#125;,<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>因为这个插件是英文的，并不支持中文，所以插件里的提示信息也是英文，我们可以在插件里添加上中文的翻译，这样就能显示中文的提示信息了。</p><p>打开<code>summernote-cleaner.js</code>，将</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript">$.extend(<span class="hljs-literal">true</span>, $.summernote.lang, &#123;<br>  <span class="hljs-string">&#x27;en-US&#x27;</span>: &#123;<br>    cleaner: &#123;<br>      tooltip: <span class="hljs-string">&#x27;Cleaner&#x27;</span>,<br>      not: <span class="hljs-string">&#x27;Text has been Cleaned!!!&#x27;</span>,<br>      limitText: <span class="hljs-string">&#x27;Text&#x27;</span>,<br>      limitHTML: <span class="hljs-string">&#x27;HTML&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>修改为</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript">$.extend(<span class="hljs-literal">true</span>, $.summernote.lang, &#123;<br>  <span class="hljs-string">&#x27;en-US&#x27;</span>: &#123;<br>    cleaner: &#123;<br>      tooltip: <span class="hljs-string">&#x27;Cleaner&#x27;</span>,<br>      not: <span class="hljs-string">&#x27;Text has been Cleaned!!!&#x27;</span>,<br>      limitText: <span class="hljs-string">&#x27;Text&#x27;</span>,<br>      limitHTML: <span class="hljs-string">&#x27;HTML&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-string">&#x27;zh-CN&#x27;</span>: &#123;<br>    cleaner: &#123;<br>      tooltip: <span class="hljs-string">&#x27;Cleaner&#x27;</span>,<br>      not: <span class="hljs-string">&#x27;文本格式已被清除&#x27;</span>,<br>      limitText: <span class="hljs-string">&#x27;字数&#x27;</span>,<br>      limitHTML: <span class="hljs-string">&#x27;HTML&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>这样提示信息就可以显示为中文了。</p><h2 id="图片上传和删除"><a href="#图片上传和删除" class="headerlink" title="图片上传和删除"></a>图片上传和删除</h2><h3 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h3><p>在初始化JS中添加回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript">$(<span class="hljs-string">&#x27;#summernote&#x27;</span>).summernote(&#123;<br>  callbacks: &#123;<br>    onImageUpload: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">files</span>) </span>&#123;<br>      uploadSummerPic($summernote1, files[<span class="hljs-number">0</span>]);<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uploadSummerPic</span>(<span class="hljs-params">$summernote, file</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> imgFile = <span class="hljs-keyword">new</span> FileReader();<br>    imgFile.readAsDataURL(file);<br>    <span class="hljs-keyword">var</span> base64 = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (file) &#123;<br>        imgFile.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) </span>&#123;<br>            base64 = evt.target.result;<br>            <span class="hljs-comment">// base64 = base64.substring(base64.indexOf(&#x27;,&#x27;)+1);</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(base64);<br>        <span class="hljs-keyword">var</span> sj = &#123;<span class="hljs-attr">base64</span>:base64&#125;;<br>        <span class="hljs-keyword">var</span> sj = <span class="hljs-built_in">JSON</span>.stringify(sj);<br>        $summernote.summernote(<span class="hljs-string">&#x27;insertImage&#x27;</span>,<span class="hljs-string">&#x27;http://127.0.0.1:5500/tianjia.jpg&#x27;</span>);<br>    <span class="hljs-comment">// $.ajax(&#123;</span><br>    <span class="hljs-comment">//     type:&quot;POST&quot;,</span><br>    <span class="hljs-comment">//     url:&quot;/addimage&quot;,</span><br>    <span class="hljs-comment">//     data: sj,</span><br>    <span class="hljs-comment">//     // cache: false,</span><br>    <span class="hljs-comment">//     // contentType: false,</span><br>    <span class="hljs-comment">//     // processData: false,</span><br>    <span class="hljs-comment">//     success: function (res) &#123;</span><br>    <span class="hljs-comment">//         if (res.result == &quot;OK&quot;) &#123;</span><br>                <span class="hljs-comment">// var url = &#x27;https://mgr.ytdfzyjt.com/getimage?imgid=&#x27;+res.img;</span><br>                <span class="hljs-comment">//     $summernote.summernote(&#x27;insertImage&#x27;,url);</span><br>                <span class="hljs-comment">// &#125;else&#123;&#125;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;);</span><br>    &#125;,<span class="hljs-number">100</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="图片删除"><a href="#图片删除" class="headerlink" title="图片删除"></a>图片删除</h3><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://summernote.org/">Summernote</a></p><p><a href="https://github.com/summernote/awesome-summernote">awesome-summernote（包含插件主题等）</a></p><p><a href="https://blog.csdn.net/sincy09/article/details/82853547">summernote 上传图片、删除图片</a></p><p><a href="https://blog.csdn.net/weixin_42881256/article/details/82863204">summernote富文本编辑器实现图片添加上传和删除图片</a></p><p><a href="https://blog.csdn.net/xiaotudeluobo/article/details/90637351">summernote中关于上传图片的问题（解决）</a></p><p><a href="https://blog.csdn.net/zero_295813128/article/details/52670128">summernote处理上传图片到自己的服务器</a></p><p><a href="https://blog.csdn.net/sky_sunshine_x/article/details/80985097">富文本编辑器summernote的基本使用（自定义行高字体属性）</a></p><p><a href="https://www.xuexiareas.com/index/Articles/details/num/13.html">富文本编辑器之图片上传删除问题</a></p>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>HTML</tag>
      
      <tag>JS</tag>
      
      <tag>富文本编辑器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VScode插件</title>
    <link href="/2020/06/vscode-plugins/"/>
    <url>/2020/06/vscode-plugins/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>live2d点击下载没反应解决办法</title>
    <link href="/2020/06/live2d-download/"/>
    <url>/2020/06/live2d-download/</url>
    
    <content type="html"><![CDATA[<p>在Live2D官网下载Live2D Cublsm的时候，发现点击下载按钮没有反应的情况。不管点“アップデートをダウンロードする” （“Download updates”）还是“初めてダウンロードする” （“Download for the first time”），都没有反应。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>在打开控制台查看源代码后发现Live2D官网通过谷歌的CDN （ajax.googleapis.com）引用jquery，而按钮被点击时的行为是通过jquery的函数定义的。由于众所周知的原因，我们没法直接访问谷歌CDN。这就导致按钮失效，我们无法通过点击按钮获取下载链接。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>在浏览器中按F12或者鼠标右键检查，打开控制台，点击“console”一项，然后在下面输入以下代码：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">genFileURL</span><span class="hljs-params">(LATEST_VERSION_WIN, <span class="hljs-string">&quot;zh&quot;</span>, <span class="hljs-string">&quot;exe&quot;</span>)</span></span><br></code></pre></div></td></tr></table></figure><p>如果是Mac用户，把<code>LATEST_VERSION_WIN</code>改成<code>LATEST_VERSION_MAC</code>，把<code>exe</code>改成<code>pkg</code>；</p><p>如果想用日文版、英文版，把zh改成jp或者en然后回车，把返回的链接放到浏览器地址栏里就能下载最新的Live2D安装包。</p><p>如果要下载以前版本的安装包，只要把上面的<code>LATEST_VERSION_XXX</code>改成<code>OLDER_VERSIONS_XXX</code>，然后在后面加一个英文的点，控制台就会列出之前可下载的版本，然后移动方向键选择，按回车键确认。</p><p>最后完整命令看起来像是这样：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">genFileURL</span>(OLDER_VERSIONS_WIN.v<span class="hljs-number">4</span>_<span class="hljs-number">00</span>_<span class="hljs-number">02</span>,<span class="hljs-string">&quot;zh&quot;</span>,<span class="hljs-string">&quot;exe&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>再按一次回车就可以看到下载链接了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>add-live2d</title>
    <link href="/2020/06/add-live2d/"/>
    <url>/2020/06/add-live2d/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【转】用markdown画图（流程图、序列图等等）</title>
    <link href="/2020/06/markdown-diagrams/"/>
    <url>/2020/06/markdown-diagrams/</url>
    
    <content type="html"><![CDATA[<h3 id="1、横向流程图源码格式："><a href="#1、横向流程图源码格式：" class="headerlink" title="1、横向流程图源码格式："></a>1、横向流程图源码格式：</h3><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">mermaid<br>graph LR<br>A[方形] --&gt;B(圆角)<br>    B --&gt; C&#123;条件a&#125;<br>    C --&gt;|<span class="hljs-type">a</span>=<span class="hljs-number">1</span>| <span class="hljs-type">D</span>[结果<span class="hljs-number">1</span>]<br>    C --&gt;|<span class="hljs-type">a</span>=<span class="hljs-number">2</span>| <span class="hljs-type">E</span>[结果<span class="hljs-number">2</span>]<br>    F[横向流程图]<br></code></pre></div></td></tr></table></figure><p><strong>效果图：</strong></p><pre><code class=" mermaid">graph LRA[方形] --&gt;B(圆角)    B --&gt; C&#123;条件a&#125;    C --&gt;|a&#x3D;1| D[结果1]    C --&gt;|a&#x3D;2| E[结果2]    F[横向流程图]</code></pre><h3 id="2、竖向流程图源码格式："><a href="#2、竖向流程图源码格式：" class="headerlink" title="2、竖向流程图源码格式："></a>2、竖向流程图源码格式：</h3><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">mermaid<br>graph TD<br>A[方形] --&gt; B(圆角)<br>    B --&gt; C&#123;条件a&#125;<br>    C --&gt; |<span class="hljs-type">a</span>=<span class="hljs-number">1</span>| <span class="hljs-type">D</span>[结果<span class="hljs-number">1</span>]<br>    C --&gt; |<span class="hljs-type">a</span>=<span class="hljs-number">2</span>| <span class="hljs-type">E</span>[结果<span class="hljs-number">2</span>]<br>    F[竖向流程图]<br></code></pre></div></td></tr></table></figure><p><strong>效果图：</strong></p><pre><code class=" mermaid">graph TDA[方形] --&gt; B(圆角)    B --&gt; C&#123;条件a&#125;    C --&gt; |a&#x3D;1| D[结果1]    C --&gt; |a&#x3D;2| E[结果2]    F[竖向流程图]</code></pre><h3 id="3、标准流程图源码格式："><a href="#3、标准流程图源码格式：" class="headerlink" title="3、标准流程图源码格式："></a>3、标准流程图源码格式：</h3><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">flow<br>st=&gt;start: 开始框<br>op=&gt;operation: 处理框<br>cond=&gt;condition: 判断框(是或否?)<br>sub1=&gt;subroutine: 子流程<br>io=&gt;inputoutput: 输入输出框<br>e=&gt;end: 结束框<br>st-&gt;op-&gt;cond<br>cond<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">yes</span>)</span>-&gt;</span>io-&gt;e<br>cond<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">no</span>)</span>-&gt;</span>sub1<span class="hljs-function"><span class="hljs-params">(right)</span>-&gt;</span>op<br></code></pre></div></td></tr></table></figure><p><strong>效果图：</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs flow">st&#x3D;&gt;start: 开始框<br>op&#x3D;&gt;operation: 处理框<br>cond&#x3D;&gt;condition: 判断框(是或否?)<br>sub1&#x3D;&gt;subroutine: 子流程<br>io&#x3D;&gt;inputoutput: 输入输出框<br>e&#x3D;&gt;end: 结束框<br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;io-&gt;e<br>cond(no)-&gt;sub1(right)-&gt;op<br></code></pre></div></td></tr></table></figure><h3 id="4、标准流程图源码格式（横向）："><a href="#4、标准流程图源码格式（横向）：" class="headerlink" title="4、标准流程图源码格式（横向）："></a>4、标准流程图源码格式（横向）：</h3><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">flow<br>st=&gt;start: 开始框<br>op=&gt;operation: 处理框<br>cond=&gt;condition: 判断框(是或否?)<br>sub1=&gt;subroutine: 子流程<br>io=&gt;inputoutput: 输入输出框<br>e=&gt;end: 结束框<br>st<span class="hljs-function"><span class="hljs-params">(right)</span>-&gt;</span>op<span class="hljs-function"><span class="hljs-params">(right)</span>-&gt;</span>cond<br>cond<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">yes</span>)</span>-&gt;</span>io<span class="hljs-function"><span class="hljs-params">(bottom)</span>-&gt;</span>e<br>cond<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">no</span>)</span>-&gt;</span>sub1<span class="hljs-function"><span class="hljs-params">(right)</span>-&gt;</span>op<br></code></pre></div></td></tr></table></figure><p><strong>效果图：</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs flow">st&#x3D;&gt;start: 开始框<br>op&#x3D;&gt;operation: 处理框<br>cond&#x3D;&gt;condition: 判断框(是或否?)<br>sub1&#x3D;&gt;subroutine: 子流程<br>io&#x3D;&gt;inputoutput: 输入输出框<br>e&#x3D;&gt;end: 结束框<br>st(right)-&gt;op(right)-&gt;cond<br>cond(yes)-&gt;io(bottom)-&gt;e<br>cond(no)-&gt;sub1(right)-&gt;op<br></code></pre></div></td></tr></table></figure><h3 id="5、UML时序图源码样例："><a href="#5、UML时序图源码样例：" class="headerlink" title="5、UML时序图源码样例："></a>5、UML时序图源码样例：</h3><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">sequence</span><br>对象<span class="hljs-selector-tag">A</span><span class="hljs-selector-tag">-</span>&gt;对象<span class="hljs-selector-tag">B</span>: 对象<span class="hljs-selector-tag">B</span>你好吗?（请求）<br><span class="hljs-selector-tag">Note</span> <span class="hljs-selector-tag">right</span> <span class="hljs-selector-tag">of</span> 对象<span class="hljs-selector-tag">B</span>: 对象<span class="hljs-selector-tag">B</span>的描述<br><span class="hljs-selector-tag">Note</span> <span class="hljs-selector-tag">left</span> <span class="hljs-selector-tag">of</span> 对象<span class="hljs-selector-tag">A</span>: 对象<span class="hljs-selector-tag">A</span>的描述(提示)<br>对象<span class="hljs-selector-tag">B</span><span class="hljs-selector-tag">--</span>&gt;对象<span class="hljs-selector-tag">A</span>: 我很好(响应)<br>对象<span class="hljs-selector-tag">A</span><span class="hljs-selector-tag">-</span>&gt;对象<span class="hljs-selector-tag">B</span>: 你真的好吗？<br></code></pre></div></td></tr></table></figure><p><strong>效果图：</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sequence">对象A-&gt;对象B: 对象B你好吗?（请求）<br>Note right of 对象B: 对象B的描述<br>Note left of 对象A: 对象A的描述(提示)<br>对象B--&gt;对象A: 我很好(响应)<br>对象A-&gt;对象B: 你真的好吗？<br></code></pre></div></td></tr></table></figure><h3 id="6、UML时序图源码复杂样例："><a href="#6、UML时序图源码复杂样例：" class="headerlink" title="6、UML时序图源码复杂样例："></a>6、UML时序图源码复杂样例：</h3><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">sequence</span><br><span class="hljs-selector-tag">Title</span>: 标题：复杂使用<br>对象<span class="hljs-selector-tag">A</span><span class="hljs-selector-tag">-</span>&gt;对象<span class="hljs-selector-tag">B</span>: 对象<span class="hljs-selector-tag">B</span>你好吗?（请求）<br><span class="hljs-selector-tag">Note</span> <span class="hljs-selector-tag">right</span> <span class="hljs-selector-tag">of</span> 对象<span class="hljs-selector-tag">B</span>: 对象<span class="hljs-selector-tag">B</span>的描述<br><span class="hljs-selector-tag">Note</span> <span class="hljs-selector-tag">left</span> <span class="hljs-selector-tag">of</span> 对象<span class="hljs-selector-tag">A</span>: 对象<span class="hljs-selector-tag">A</span>的描述(提示)<br>对象<span class="hljs-selector-tag">B</span><span class="hljs-selector-tag">--</span>&gt;对象<span class="hljs-selector-tag">A</span>: 我很好(响应)<br>对象<span class="hljs-selector-tag">B</span><span class="hljs-selector-tag">-</span>&gt;小三: 你好吗<br>小三<span class="hljs-selector-tag">--</span>&gt;&gt;对象<span class="hljs-selector-tag">A</span>: 对象<span class="hljs-selector-tag">B</span>找我了<br>对象<span class="hljs-selector-tag">A</span><span class="hljs-selector-tag">-</span>&gt;对象<span class="hljs-selector-tag">B</span>: 你真的好吗？<br><span class="hljs-selector-tag">Note</span> <span class="hljs-selector-tag">over</span> 小三,对象<span class="hljs-selector-tag">B</span>: 我们是朋友<br><span class="hljs-selector-tag">participant</span> <span class="hljs-selector-tag">C</span><br><span class="hljs-selector-tag">Note</span> <span class="hljs-selector-tag">right</span> <span class="hljs-selector-tag">of</span> <span class="hljs-selector-tag">C</span>: 没人陪我玩<br></code></pre></div></td></tr></table></figure><p><strong>效果图：</strong></p><pre><code class=" mermaid">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头  sequenceDiagram    participant 张三    participant 李四    张三-&gt;王五: 王五你好吗？    loop 健康检查        王五-&gt;王五: 与疾病战斗    end    Note right of 王五: 合理 食物 &lt;br&#x2F;&gt;看医生...    李四--&gt;&gt;张三: 很好!    王五-&gt;李四: 你怎么样?    李四--&gt;王五: 很好!</code></pre><h3 id="7、UML标准时序图样例："><a href="#7、UML标准时序图样例：" class="headerlink" title="7、UML标准时序图样例："></a>7、UML标准时序图样例：</h3><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">mermaid<br>%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头<br>  sequenceDiagram<br>    participant 张三<br>    participant 李四<br>    张三-&gt;王五: 王五你好吗？<br>    loop 健康检查<br>        王五-&gt;王五: 与疾病战斗<br>    <span class="hljs-keyword">end</span><br>    Note <span class="hljs-built_in">right</span> of 王五: 合理 食物 &lt;br/&gt;看医生...<br>    李四--&gt;&gt;张三: 很好!<br>    王五-&gt;李四: 你怎么样?<br>    李四--&gt;王五: 很好!<br></code></pre></div></td></tr></table></figure><p><strong>效果图：</strong></p><pre><code class=" mermaid">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头  sequenceDiagram    participant 张三    participant 李四    张三-&gt;王五: 王五你好吗？    loop 健康检查        王五-&gt;王五: 与疾病战斗    end    Note right of 王五: 合理 食物 &lt;br&#x2F;&gt;看医生...    李四--&gt;&gt;张三: 很好!    王五-&gt;李四: 你怎么样?    李四--&gt;王五: 很好!</code></pre><h3 id="8、甘特图样例："><a href="#8、甘特图样例：" class="headerlink" title="8、甘特图样例："></a>8、甘特图样例：</h3><figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm">mermaid<br>%% 语法示例<br>        gantt<br>        dateFormat  YYYY-MM-<span class="hljs-built_in">DD</span><br>        title 软件开发甘特图<br>        <span class="hljs-meta">section</span> 设计<br>        需求                      :done,    des1, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span>,<span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">08</span><br>        原型                      :active,  des2, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">09</span>, <span class="hljs-number">3d</span><br>        UI设计                     :         des3, after des2, <span class="hljs-number">5d</span><br>    未来任务                     :         des4, after des3, <span class="hljs-number">5d</span><br>        <span class="hljs-meta">section</span> 开发<br>        学习准备理解需求                      :crit, done, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span>,<span class="hljs-number">24h</span><br>        设计框架                             :crit, done, after des2, <span class="hljs-number">2d</span><br>        开发                                 :crit, active, <span class="hljs-number">3d</span><br>        未来任务                              :crit, <span class="hljs-number">5d</span><br>        耍                                   :<span class="hljs-number">2d</span><br>        <span class="hljs-meta">section</span> 测试<br>        功能测试                              :active, a1, after des3, <span class="hljs-number">3d</span><br>        压力测试                               :after a1  , <span class="hljs-number">20h</span><br>        测试报告                               : <span class="hljs-number">48h</span><br></code></pre></div></td></tr></table></figure><p><strong>效果图：</strong></p><pre><code class=" mermaid">%% 语法示例        gantt        dateFormat  YYYY-MM-DD        title 软件开发甘特图        section 设计        需求                      :done,    des1, 2014-01-06,2014-01-08        原型                      :active,  des2, 2014-01-09, 3d        UI设计                     :         des3, after des2, 5d    未来任务                     :         des4, after des3, 5d        section 开发        学习准备理解需求                      :crit, done, 2014-01-06,24h        设计框架                             :crit, done, after des2, 2d        开发                                 :crit, active, 3d        未来任务                              :crit, 5d        耍                                   :2d        section 测试        功能测试                              :active, a1, after des3, 3d        压力测试                               :after a1  , 20h        测试报告                               : 48h</code></pre><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><p><a href="https://www.runoob.com/markdown/md-advance.html">Markdown 高级技巧-笔记</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网页自动播放问题</title>
    <link href="/2020/06/media-autoplay/"/>
    <url>/2020/06/media-autoplay/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【转】JS工厂模式</title>
    <link href="/2020/06/js-factory/"/>
    <url>/2020/06/js-factory/</url>
    
    <content type="html"><![CDATA[<p>本节书摘来自异步社区《JavaScript设计模式》一书中的第9章，第9.10节， 作者： 【美】Addy Osmani 译者： 徐涛 更多章节内容可以访问云栖社区“异步社区”公众号查看。</p><h2 id="9-10-Factory（工厂）模式"><a href="#9-10-Factory（工厂）模式" class="headerlink" title="9.10 Factory（工厂）模式"></a>9.10 Factory（工厂）模式</h2><p>Factory模式是另一种创建型模式，涉及创建对象的概念。其分类不同于其他模式的地方在于它不显式地要求使用一个构造函数。而Factory可以提供一个通用的接口来创建对象，我们可以指定我们所希望创建的工厂对象的类型（见图9-9）。<br><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="图9-9 JS工厂模式"></p><p>假设有一个UI工厂，我们要创建一个UI组件的类型。不需要直接使用new运算符或者通过另一个创建型构造函数创建这个组件，而是要求Factory对象创建一个新的组件。我们通知Factory需要什么类型的对象（如“按钮”、“面板”），它会进行实例化，然后将它返回给我们使用。</p><p>如果对象创建过程相对比较复杂，这种方法特别有用，例如，如果它强烈依赖于动态因素或应用程序配置的话。</p><p>可以在ExtJS等UI库中找到此模式的示例，其中创建对象或组件的方法也有可能被归入子类了。</p><p>下面这个示例构建在之前的代码片段之上，使用Constructor模式逻辑来定义汽车。它展示了如何使用Factory模式来实现vehicle工厂：</p><p>// Types.js –本例构造函数的存放文件<br>// 定义Car构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span>(<span class="hljs-params">options</span>) </span>&#123;<br>  <span class="hljs-comment">// 默认值</span><br>  <span class="hljs-built_in">this</span>.doors = options.doors || <span class="hljs-number">4</span>;<br>  <span class="hljs-built_in">this</span>.state = options.state || <span class="hljs-string">&quot;brand new&quot;</span>;<br>  <span class="hljs-built_in">this</span>.color = options.color || <span class="hljs-string">&quot;silver&quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>// 定义Truck构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Truck</span>(<span class="hljs-params">options</span>) </span>&#123;<br>   <span class="hljs-built_in">this</span>.state = options.state || <span class="hljs-string">&quot;used&quot;</span>;<br>   <span class="hljs-built_in">this</span>.wheelSize = options.wheelSize || <span class="hljs-string">&quot;large&quot;</span>;<br>   <span class="hljs-built_in">this</span>.color = options.color || <span class="hljs-string">&quot;blue&quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>// FactoryExample.js<br>// 定义vehicle工厂的大体代码</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">VehicleFactory</span>(<span class="hljs-params"></span>) </span>&#123; &#125;<br></code></pre></div></td></tr></table></figure><p>// 定义该工厂factory的原型和试用工具，默认的vehicleClass是Car</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">VehicleFactory.prototype.vehicleClass = Car;<br></code></pre></div></td></tr></table></figure><p>// 创建新Vehicle实例的工厂方法</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">VehicleFactory.prototype.createVehicle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>&#123;<br>   <span class="hljs-keyword">if</span> (options.vehicleType === <span class="hljs-string">&quot;car&quot;</span>) &#123;<br>       <span class="hljs-built_in">this</span>.vehicleClass = Car;<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-built_in">this</span>.vehicleClass = Truck;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">this</span>.vehicleClass(options);<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>// 创建生成汽车的工厂实例</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> carFactory = <span class="hljs-keyword">new</span> VehicleFactory();<br><span class="hljs-keyword">var</span> car = carFactory.createVehicle(&#123;<br>               vehicleType: <span class="hljs-string">&quot;car&quot;</span>,<br>               color: <span class="hljs-string">&quot;yellow&quot;</span>,<br>               doors: <span class="hljs-number">6</span>&#125;);<br></code></pre></div></td></tr></table></figure><p>// 测试汽车是由vehicleClass的原型prototype里的Car创建的<br>// 输出: true</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(car <span class="hljs-keyword">instanceof</span> Car);<br></code></pre></div></td></tr></table></figure><p>// 输出: Car对象，color: “yellow”, doors: 6,state:”brand new”</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(car);<br></code></pre></div></td></tr></table></figure><p>在方法 1 中，我们修改了VehicleFactory实例来使用Truck类：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> movingTruck = carFactory.createVehicle(&#123;<br>                      vehicleType: <span class="hljs-string">&quot;truck&quot;</span>,<br>                      state: <span class="hljs-string">&quot;like new&quot;</span>,<br>                      color: <span class="hljs-string">&quot;red&quot;</span>,<br>                      wheelSize: <span class="hljs-string">&quot;small&quot;</span>&#125;);<br></code></pre></div></td></tr></table></figure><p>// 测试卡车是由vehicleClass的原型prototype里的Truck创建的<br>// 输出: true</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(movingTruck <span class="hljs-keyword">instanceof</span> Truck);<br></code></pre></div></td></tr></table></figure><p>// 输出: Truck对象，color ：”red”, state：”like new” ，wheelSize：”small”</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(movingTruck);<br></code></pre></div></td></tr></table></figure><p>在方法2中，我们把VehicleFactory归入子类来创建一个构建Truck的工厂类：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TruckFactory</span>(<span class="hljs-params"></span>) </span>&#123; &#125;<br>TruckFactory.prototype = <span class="hljs-keyword">new</span> VehicleFactory();<br>TruckFactory.prototype.vehicleClass = Truck;<br><span class="hljs-keyword">var</span> truckFactory = <span class="hljs-keyword">new</span> TruckFactory();<br><span class="hljs-keyword">var</span> myBigTruck = truckFactory.createVehicle(&#123;<br>                      state: <span class="hljs-string">&quot;omg..so bad.&quot;</span>,<br>                      color: <span class="hljs-string">&quot;pink&quot;</span>,<br>                      wheelSize: <span class="hljs-string">&quot;so big&quot;</span>&#125;);<br></code></pre></div></td></tr></table></figure><p>// 确认myBigTruck是由原型Truck创建的<br>// 输出: true</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(myBigTruck <span class="hljs-keyword">instanceof</span> Truck);<br></code></pre></div></td></tr></table></figure><p>// 输出：Truck对象，color: pink”, wheelSize: “so big”, state: “omg. so bad”</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(myBigTruck);<br></code></pre></div></td></tr></table></figure><h3 id="9-10-1-何时使用Factory模式"><a href="#9-10-1-何时使用Factory模式" class="headerlink" title="9.10.1 何时使用Factory模式"></a>9.10.1 何时使用Factory模式</h3><p>Factory模式应用于如下场景时是特别有用的：</p><p>当对象或组件设置涉及高复杂性时<br>当需要根据所在的不同环境轻松生成对象的不同实例时<br>当处理很多共享相同属性的小型对象或组件时<br>在编写只需要满足一个API契约（亦称鸭子类型）的其他对象的实例对象时。对于解耦是很有用的。</p><h3 id="9-10-2-何时不应使用Factory模式"><a href="#9-10-2-何时不应使用Factory模式" class="headerlink" title="9.10.2 何时不应使用Factory模式"></a>9.10.2 何时不应使用Factory模式</h3><p>如果应用错误，这种模式会为应用程序带来大量不必要的复杂性。除非为创建对象提供一个接口是我们正在编写的库或框架的设计目标，否则我建议坚持使用显式构造函数，以避免不必要的开销。</p><p>由于对象创建的过程实际上是藏身接口之后抽象出来的，单元测试也可能带来问题，这取决于对象创建的过程有多复杂。</p><h3 id="9-10-3-Abstract-Factory（抽象工厂）"><a href="#9-10-3-Abstract-Factory（抽象工厂）" class="headerlink" title="9.10.3 Abstract Factory（抽象工厂）"></a>9.10.3 Abstract Factory（抽象工厂）</h3><p>了解抽象工厂模式也是有用的，它用于封装一组具有共同目标的单个工厂。它能够将一组对象的实现细节从一般用法中分离出来。</p><p>应当使用抽象工厂模式的情况是：一个系统必须独立于它所创建的对象的生成方式，或它需要与多种对象类型一起工作。</p><p>既简单又容易理解的示例是车辆工厂，它定义了获取或注册车辆类型的方法。抽象工厂可以命名为AbstractVehicleFactory。抽象工厂将允许对像car或truck这样的车辆类型进行定义，具体工厂只需要实现履行车辆契约的类（如Vehicle.prototype.drive和Vehicle.prototype.breakDown）。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> AbstractVehicleFactory = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-comment">// 存储车辆类型</span><br>  <span class="hljs-keyword">var</span> types = &#123;&#125;;<br>  <span class="hljs-keyword">return</span> &#123;<br>       getVehicle: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> type, customizations </span>) </span>&#123;<br>            <span class="hljs-keyword">var</span> Vehicle = types[type];<br>            <span class="hljs-keyword">return</span> (Vehicle) ? <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vehicle(customizations) : <span class="hljs-literal">null</span>;<br>       &#125;,<br>       registerVehicle: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> type, Vehicle </span>) </span>&#123;<br>            <span class="hljs-keyword">var</span> proto = Vehicle.prototype;<br>            <span class="hljs-comment">// 只注册实现车辆契约的类</span><br>            <span class="hljs-keyword">if</span> ( proto.drive &amp;&amp; proto.breakDown ) &#123;<br>                  types[type] = Vehicle;<br>            &#125;<br>            <span class="hljs-keyword">return</span> AbstractVehicleFactory;<br>        &#125;<br>  &#125;;<br>&#125;)();<br><span class="hljs-comment">// 用法:</span><br>AbstractVehicleFactory.registerVehicle( <span class="hljs-string">&quot;car&quot;</span>, Car );<br>AbstractVehicleFactory.registerVehicle( <span class="hljs-string">&quot;truck&quot;</span>, Truck );<br><span class="hljs-comment">// 基于抽象车辆类型实例化一个新car对象</span><br><span class="hljs-keyword">var</span> car = AbstractVehicleFactory.getVehicle( <span class="hljs-string">&quot;car&quot;</span> , &#123;<br>             color: <span class="hljs-string">&quot;lime green&quot;</span>,<br>             state: <span class="hljs-string">&quot;like new&quot;</span> &#125; );<br><span class="hljs-comment">// 同理实例化一个新truck对象</span><br><span class="hljs-keyword">var</span> truck = AbstractVehicleFactory.getVehicle( <span class="hljs-string">&quot;truck&quot;</span> , &#123;<br>                wheelSize: <span class="hljs-string">&quot;medium&quot;</span>,<br>                color: <span class="hljs-string">&quot;neon yellow&quot;</span> &#125; );<br></code></pre></div></td></tr></table></figure><h2 id="完整示例代码："><a href="#完整示例代码：" class="headerlink" title="完整示例代码："></a>完整示例代码：</h2><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-comment">//先定义几种车 构造函数  工厂方法</span></span><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span>(<span class="hljs-params">options</span>) </span>&#123;</span><br><span class="javascript"><span class="hljs-built_in">this</span>.doors = options.doors || <span class="hljs-number">4</span>;</span><br><span class="javascript"><span class="hljs-built_in">this</span>.state = options.state || <span class="hljs-string">&quot;brand&quot;</span>;</span><br><span class="javascript"><span class="hljs-built_in">this</span>.color = options.color || <span class="hljs-string">&quot;silver&quot;</span>;</span><br>&#125;<br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Truck</span>(<span class="hljs-params">options</span>) </span>&#123;</span><br><span class="javascript"><span class="hljs-built_in">this</span>.state = options.state || <span class="hljs-string">&quot;used&quot;</span>;</span><br><span class="javascript"><span class="hljs-built_in">this</span>.wheelSize = options.wheelSize || <span class="hljs-string">&quot;large&quot;</span>;</span><br><span class="javascript"><span class="hljs-built_in">this</span>.color = options.color || <span class="hljs-string">&quot;blue&quot;</span>;</span><br>&#125;<br> <br><span class="javascript"><span class="hljs-comment">//再定义生产车辆的工厂</span></span><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">VehicleFactory</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="javascript"><span class="hljs-comment">//定义该工厂生产的默认汽车类型</span></span><br><span class="javascript">VehicleFactory.prototype.vehicleClass = Car; <span class="hljs-comment">//Car是函数</span></span><br><span class="javascript"><span class="hljs-comment">//定义生产汽车的具体过程</span></span><br><span class="javascript">VehicleFactory.prototype.createVehicle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">if</span>(options.vehicleType === <span class="hljs-string">&quot;car&quot;</span>)&#123;</span><br><span class="javascript"><span class="hljs-built_in">this</span>.vehicleClass = Car;</span><br><span class="javascript">&#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="javascript"><span class="hljs-built_in">this</span>.vehicleClass = Truck;</span><br>&#125;<br> <br><span class="javascript"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">this</span>.vehicleClass(options); </span><br>&#125;;<br> <br><span class="javascript"><span class="hljs-comment">//建造工厂并命名</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> carFactory = <span class="hljs-keyword">new</span> VehicleFactory();</span><br><span class="javascript"><span class="hljs-comment">//开始生产汽车</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> car = carFactory.createVehicle(&#123;</span><br><span class="javascript">vehicleType: <span class="hljs-string">&quot;car&quot;</span>,</span><br><span class="javascript">color: <span class="hljs-string">&quot;yellow&quot;</span>,</span><br>doors: 6<br>&#125;);<br><span class="javascript"><span class="hljs-comment">//验证车是否是这个Car类型的车</span></span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(car <span class="hljs-keyword">instanceof</span> Car);</span><br><span class="javascript"><span class="hljs-comment">//验验车，看看货</span></span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(car);</span><br> <br><span class="javascript"><span class="hljs-comment">//再生产另一部车</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> movingTruck = carFactory.createVehicle(&#123;</span><br><span class="javascript">vehicleType: <span class="hljs-string">&quot;truck&quot;</span>,</span><br><span class="javascript">state: <span class="hljs-string">&quot;like new&quot;</span>,</span><br><span class="javascript">color: <span class="hljs-string">&quot;red&quot;</span>,</span><br><span class="javascript">wheelSize: <span class="hljs-string">&quot;small&quot;</span></span><br>&#125;);<br><span class="javascript"><span class="hljs-comment">//验证车是否是Track类型的车</span></span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(movingTruck <span class="hljs-keyword">instanceof</span> Truck);</span><br><span class="javascript"><span class="hljs-comment">//验验车，看看货</span></span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(movingTruck);</span><br> <br><span class="javascript"><span class="hljs-comment">//-----------------------------------------------</span></span><br><span class="javascript"><span class="hljs-comment">//定义第二个工厂  是上面那个工厂的子工厂</span></span><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TruckFactory</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="javascript">TruckFactory.prototype = <span class="hljs-keyword">new</span> VehicleFactory();</span><br>TruckFactory.prototype.vehicleClass = Truck;<br><span class="javascript"><span class="hljs-comment">//创建工厂</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> TruckFactory = <span class="hljs-keyword">new</span> TruckFactory();</span><br><span class="javascript"><span class="hljs-comment">//生产卡车</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> myBigTruck = TruckFactory.createVehicle(&#123;</span><br><span class="javascript">state: <span class="hljs-string">&quot;omg..so bad.&quot;</span>,</span><br><span class="javascript">color: <span class="hljs-string">&quot;pink&quot;</span>,</span><br><span class="javascript">wheelSize: <span class="hljs-string">&quot;so big&quot;</span></span><br>&#125;);<br><span class="javascript"><span class="hljs-comment">//验验车</span></span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(myBigTruck <span class="hljs-keyword">instanceof</span> Truck);</span><br><span class="javascript"><span class="hljs-comment">//看看货</span></span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(myBigTruck);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="原文链接："><a href="#原文链接：" class="headerlink" title="原文链接："></a>原文链接：</h2><p><a href="https://yq.aliyun.com/articles/91494?spm=a2c4e.11153940.0.0.5d4630f9s89vDO&type=2">《JavaScript设计模式》——9.10 Factory（工厂）模式</a></p><p><a href="https://blog.csdn.net/spflinux/article/details/78437032">JS——Factory(工厂)模式</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【转】Git常用的几个命令详解</title>
    <link href="/2020/06/git-commond/"/>
    <url>/2020/06/git-commond/</url>
    
    <content type="html"><![CDATA[<h2 id="查看、添加、提交、删除、找回，重置修改文件"><a href="#查看、添加、提交、删除、找回，重置修改文件" class="headerlink" title="查看、添加、提交、删除、找回，重置修改文件"></a>查看、添加、提交、删除、找回，重置修改文件</h2><p>git help <command> # 显示command的help</p><p>git show # 显示某次提交的内容 git show $id</p><p>git co – <file> # 抛弃工作区修改</p><p>git co . # 抛弃工作区修改</p><p>git add <file> # 将工作文件修改提交到本地暂存区</p><p>git add . # 将所有修改过的工作文件提交暂存区</p><p>git rm <file> # 从版本库中删除文件</p><p>git rm <file> –cached # 从版本库中删除文件，但不删除文件</p><p>git reset <file> # 从暂存区恢复到工作文件</p><p>git reset – . # 从暂存区恢复到工作文件</p><p>git reset –hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改</p><p>git ci <file> git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　</p><p>git ci -am “some comments”</p><p>git ci –amend # 修改最后一次提交记录</p><p>git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象</p><p>git revert HEAD # 恢复最后一次提交的状态</p><h2 id="git-tag-—-标签相关操作"><a href="#git-tag-—-标签相关操作" class="headerlink" title="git tag — 标签相关操作"></a>git tag — 标签相关操作</h2><p>标签可以针对某一时间点的版本做标记，常用于版本发布。</p><h4 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h4><p>$ git tag # 在控制台打印出当前仓库的所有标签</p><p>$ git tag -l ‘v0.1.*’ # 搜索符合模式的标签</p><h4 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h4><p>git标签分为两种类型：轻量标签和附注标签。轻量标签是指向提交对象的引用，附注标签则是仓库中的一个独立对象。建议使用附注标签。</p><p><strong>创建轻量标签</strong></p><p>$ git tag v0.1.2-light</p><p><strong>创建附注标签</strong></p><p>$ git tag -a v0.1.2 -m “0.1.2版本”</p><p>创建轻量标签不需要传递参数，直接指定标签名称即可。<br>创建附注标签时，参数a即annotated的缩写，指定标签类型，后附标签名。参数m指定标签说明，说明信息会保存在标签对象中。</p><h4 id="切换到标签"><a href="#切换到标签" class="headerlink" title="切换到标签"></a>切换到标签</h4><p>与切换分支命令相同，用git checkout [tagname]<br>查看标签信息<br>用git show命令可以查看标签的版本信息：<br>$ git show v0.1.2</p><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><p>误打或需要修改标签时，需要先将标签删除，再打新标签。<br>$ git tag -d v0.1.2 # 删除标签</p><p>参数d即delete的缩写，意为删除其后指定的标签。</p><h4 id="给指定的commit打标签"><a href="#给指定的commit打标签" class="headerlink" title="给指定的commit打标签"></a>给指定的commit打标签</h4><p>打标签不必要在head之上，也可在之前的版本上打，这需要你知道某个提交对象的校验和（通过git log获取）。</p><p><strong>补打标签</strong></p><p>$ git tag -a v0.1.1 9fbc3d0</p><h4 id="标签发布"><a href="#标签发布" class="headerlink" title="标签发布"></a>标签发布</h4><p>通常的git push不会将标签对象提交到git服务器，我们需要进行显式的操作：<br>git push origin v0.1.2 # 将v0.1.2标签提交到git服务器 </p><p>git push origin –tags # 将本地所有标签一次性提交到git服务器</p><p><strong>注意：</strong>如果想看之前某个标签状态下的文件，可以这样操作</p><p>1.git tag   查看当前分支下的标签</p><p>2.git  checkout v0.21   此时会指向打v0.21标签时的代码状态，（但现在处于一个空的分支上）</p><p>3.cat  test.txt   查看某个文件</p><h2 id="查看文件diff"><a href="#查看文件diff" class="headerlink" title="查看文件diff"></a>查看文件diff</h2><p>git diff <file> # 比较当前文件和暂存区文件差异 git diff</p><p>git diff <id1>&lt;</p><p>git diff <branch1>..<branch2> # 在两个分支之间比较</p><p>git diff –staged # 比较暂存区和版本库差异</p><p>git diff –cached # 比较暂存区和版本库差异</p><p>git diff –stat # 仅仅比较统计信息</p><h2 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h2><p>git log git log <file> # 查看该文件每次提交记录</p><p>git log -p <file> # 查看每次详细修改内容的diff</p><p>git log -p -2 # 查看最近两次详细修改内容的diff</p><p>git log –stat #查看提交统计信息</p><h2 id="tig"><a href="#tig" class="headerlink" title="tig"></a>tig</h2><p>Mac上可以使用tig代替diff和log，brew install tig</p><h2 id="Git-本地分支管理-查看、切换、创建和删除分支"><a href="#Git-本地分支管理-查看、切换、创建和删除分支" class="headerlink" title="Git 本地分支管理 - 查看、切换、创建和删除分支"></a>Git 本地分支管理 - 查看、切换、创建和删除分支</h2><p>git br -r # 查看远程分支</p><p>git br <new_branch> # 创建新的分支</p><p>git br -v # 查看各个分支最后提交信息</p><p>git br –merged # 查看已经被合并到当前分支的分支</p><p>git br –no-merged # 查看尚未被合并到当前分支的分支</p><p>git co <branch> # 切换到某个分支</p><p>git co -b <new_branch> # 创建新的分支，并且切换过去</p><p>git co -b <new_branch> <branch> # 基于branch创建新的new_branch</p><p>git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除</p><p>git co $id -b <new_branch> # 把某次历史提交记录checkout出来，创建成一个分支</p><p>git br -d <branch> # 删除某个分支</p><p>git br -D <branch> # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)</p><h2 id="Git-本地分支管理-分支合并和rebase"><a href="#Git-本地分支管理-分支合并和rebase" class="headerlink" title="Git 本地分支管理 - 分支合并和rebase"></a>Git 本地分支管理 - 分支合并和rebase</h2><p>git merge <branch> # 将branch分支合并到当前分支</p><p>git merge origin/master –no-ff # 不要Fast-Foward合并，这样可以生成merge提交</p><p>git rebase master <branch> # 将master rebase到branch，相当于： git co <branch> &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge <branch></p><h2 id="Git补丁管理-方便在多台机器上开发同步时用"><a href="#Git补丁管理-方便在多台机器上开发同步时用" class="headerlink" title="Git补丁管理(方便在多台机器上开发同步时用)"></a>Git补丁管理(方便在多台机器上开发同步时用)</h2><p>git diff &gt; ../sync.patch # 生成补丁</p><p>git apply ../sync.patch # 打补丁</p><p>git apply –check ../sync.patch #测试补丁能否成功</p><h2 id="Git暂存管理"><a href="#Git暂存管理" class="headerlink" title="Git暂存管理"></a>Git暂存管理</h2><p>git stash # 暂存</p><p>git stash list # 列所有stash</p><p>git stash apply # 恢复暂存的内容</p><p>git stash drop # 删除暂存区</p><h2 id="Git远程分支管理"><a href="#Git远程分支管理" class="headerlink" title="Git远程分支管理"></a>Git远程分支管理</h2><p>git pull # 抓取远程仓库所有分支更新并合并到本地</p><p>git pull –no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并</p><p>git fetch origin # 抓取远程仓库更新</p><p>git merge origin/master # 将远程主分支合并到本地当前分支</p><p>git co –track origin/branch # 跟踪某个远程分支创建相应的本地分支</p><p>git co -b <local_branch> origin/<remote_branch> # 基于远程分支创建本地分支，功能同上</p><p>git push # push所有分支</p><p>git push origin master # 将本地主分支推到远程主分支</p><p>git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)</p><p>git push origin <local_branch> # 创建远程分支， origin是远程仓库名</p><p>git push origin <local_branch>:<remote_branch> # 创建远程分支</p><p>git push origin :<remote_branch> #先删除本地分支(git br -d <branch>)，然后再push删除远程分支</p><h2 id="Git远程仓库管理"><a href="#Git远程仓库管理" class="headerlink" title="Git远程仓库管理"></a>Git远程仓库管理</h2><p>git remote -v # 查看远程服务器地址和仓库名称</p><p>git remote show origin # 查看远程服务器仓库状态</p><p>git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址</p><p>git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm <repository> # 删除远程仓库</p><h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><p>git clone –bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库</p><p>scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上</p><p>mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git –bare init # 在服务器创建纯仓库</p><p>git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址</p><p>git push -u origin master # 客户端首次提交</p><p>git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track</p><p>git remote set-head origin master # 设置远程仓库的HEAD指向master分支</p><p>也可以命令设置跟踪远程库和本地库</p><p>git branch –set-upstream master origin/master</p><p>git branch –set-upstream develop origin/develop</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/cspku/articles/Git_cmds.html">《Git常用命令》</a></p><p><a href="https://blog.csdn.net/wangjia55/article/details/8793577/">《git tag — 标签相关操作》</a></p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p><p><strong>原文链接：<a href="https://www.cnblogs.com/PeunZhang/p/5957211.html">Git常用的几个命令详解</a>    作者：白树</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm换源和常用命令</title>
    <link href="/2020/06/npm-registry-basecommond/"/>
    <url>/2020/06/npm-registry-basecommond/</url>
    
    <content type="html"><![CDATA[<p>npm 官方站点 <a href="http://www.npmjs.org/">http://www.npmjs.org/</a> 虽然没有被墙，但是下载第三方依赖包是从国外服务器下载，下载的速度是非常慢让人着急不说还有可能会出现异常。</p><h2 id="切换npm源的几种方式"><a href="#切换npm源的几种方式" class="headerlink" title="切换npm源的几种方式"></a>切换npm源的几种方式</h2><h4 id="通过使用cnpm命令"><a href="#通过使用cnpm命令" class="headerlink" title="通过使用cnpm命令"></a>通过使用cnpm命令</h4><p>首先安装cnpm命令行工具</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install -g cnpm --registry=https://registry.npm.taobao.org<br></code></pre></div></td></tr></table></figure><p>安装完成后检测是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">cnpm -v<br></code></pre></div></td></tr></table></figure><p>安装成功之后，以后安装依赖包的方式和npm是一样的，只是把npm命令换成cnpm就可以了。</p><p>如果已经习惯了用npm安装，不想用cnpm的话，也不是没有办法，只要直接把源换掉就好了，下面有三种方法可以换源：</p><h4 id="通过config配置国内镜像源"><a href="#通过config配置国内镜像源" class="headerlink" title="通过config配置国内镜像源"></a>通过config配置国内镜像源</h4><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">npm config set registry https:<span class="hljs-comment">//registry.npm.taobao.org </span><br></code></pre></div></td></tr></table></figure><h4 id="通过-npm-命令指定下载源"><a href="#通过-npm-命令指定下载源" class="headerlink" title="通过 npm 命令指定下载源"></a>通过 npm 命令指定下载源</h4><p>注意：这种方式只会在当次下载中生效</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">npm install 你要下载的包名 --registry https:<span class="hljs-regexp">//</span>registry.npm.taobao.org <br></code></pre></div></td></tr></table></figure><p>如：</p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install -g @vue<span class="hljs-regexp">/cli --registry https:/</span>/registry.<span class="hljs-built_in">npm</span>.taobao.org<br></code></pre></div></td></tr></table></figure><h4 id="编辑配置文件-npmrc-添加源地址"><a href="#编辑配置文件-npmrc-添加源地址" class="headerlink" title="编辑配置文件 ~/.npmrc 添加源地址"></a>编辑配置文件 ~/.npmrc 添加源地址</h4><p>打开.npmrc文件（通常位于C:\Program Files\nodejs\node_modules\npm.npmrc），写入下面的内容：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">registry = https:<span class="hljs-regexp">//</span>registry.npm.taobao.org<br></code></pre></div></td></tr></table></figure><h4 id="检查是否更换成功"><a href="#检查是否更换成功" class="headerlink" title="检查是否更换成功"></a>检查是否更换成功</h4><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span>list<br>或<br>npm<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">get</span> registery <br></code></pre></div></td></tr></table></figure><p>输出结果是：</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p><h4 id="还原为npm源"><a href="#还原为npm源" class="headerlink" title="还原为npm源"></a>还原为npm源</h4><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">npm config set registry https:<span class="hljs-comment">//registry.npmjs.org/</span><br></code></pre></div></td></tr></table></figure><h2 id="npm常用命令"><a href="#npm常用命令" class="headerlink" title="npm常用命令"></a>npm常用命令</h2><h4 id="npm-install-安装模块"><a href="#npm-install-安装模块" class="headerlink" title="npm install 安装模块"></a>npm install 安装模块</h4><p>最普通的一条安装命令：</p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install @vue/cli<br></code></pre></div></td></tr></table></figure><p>安装指定版本</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> install gulp@<span class="hljs-number">3</span>.<span class="hljs-number">9</span>.<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p><strong>-S, –save 安装包信息将加入到dependencies（生产阶段的依赖）</strong></p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> gulp --save 或 npm <span class="hljs-keyword">install</span> gulp -S<br></code></pre></div></td></tr></table></figure><p>package.json 文件的 dependencies 字段：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c"><span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;gulp&quot;</span>: <span class="hljs-string">&quot;^3.9.1&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>-D, –save-dev 安装包信息将加入到devDependencies（开发阶段的依赖），所以开发阶段一般使用它</strong></p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> gulp --save-dev 或 npm <span class="hljs-keyword">install</span> gulp -D<br></code></pre></div></td></tr></table></figure><p>package.json 文件的 devDependencies字段：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c"><span class="hljs-string">&quot;devDependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;gulp&quot;</span>: <span class="hljs-string">&quot;^3.9.1&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>-O, –save-optional 安装包信息将加入到optionalDependencies（可选阶段的依赖）</strong></p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> gulp --save-optional 或 npm <span class="hljs-keyword">install</span> gulp -O<br></code></pre></div></td></tr></table></figure><p>package.json 文件的optionalDependencies字段：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c"><span class="hljs-string">&quot;optionalDependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;gulp&quot;</span>: <span class="hljs-string">&quot;^3.9.1&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>-E, –save-exact 精确安装指定模块版本</strong></p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> gulp --save-exact 或 npm <span class="hljs-keyword">install</span> gulp -E<br></code></pre></div></td></tr></table></figure><p>输入命令<code>npm install gulp -ES</code>，留意<code>package.json</code> 文件的 <code>dependencies</code> 字段，以看出版本号中的<strong>^</strong>消失了</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c"><span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;gulp&quot;</span>: <span class="hljs-string">&quot;3.9.1&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>模块的依赖都被写入了<code>package.json</code>文件后，他人打开项目的根目录（项目开源、内部团队合作），使用<code>npm install</code>命令可以根据<code>dependencies</code>配置安装所有的依赖包。</p><p>根据安装位置不同分为<strong>本地安装（local）</strong>和<strong>全局安装（global）</strong>：</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> &lt;package&gt;      <span class="hljs-comment"># 本地安装</span><br></code></pre></div></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">npm install &lt;<span class="hljs-keyword">package</span>&gt; -g   # 全局安装,使用 -g 或 <span class="hljs-comment">--global</span><br></code></pre></div></td></tr></table></figure><p><strong>本地安装（安装到项目）</strong><br>将安装包放在项目的 ./node_modules 下（即运行 npm 命令时所在的目录，项目根目录），包的命令行只能在当前目录下使用，如果在其他目录下运行会提示命令不存在。</p><p>如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录，并将信息保存到项目的package.json文件中。（package.json即每次npm install安装项目依赖包的参照文件。）所以，我们第一次运行项目需要npm install的原因就是：下载所有项目依赖包。</p><p>注意：若在项目过程中需要引入外包，<code>npm install &lt;package&gt; </code>不会将包录入package.json中。只有用<code>npm install &lt;package&gt; --save</code>才会录入。</p><p><strong>全局安装（安装到环境）</strong><br>将安装包放在 <code>$NODE_HOME/lib/node_modules</code>，包的命令可以直接所有目录里使用。如：安装vue-cli：<code>npm install vue-cli -g</code>，安装完便可在所有目录下直接使用 vue 命令。</p><h4 id="npm-uninstall-卸载模块"><a href="#npm-uninstall-卸载模块" class="headerlink" title="npm uninstall 卸载模块"></a>npm uninstall 卸载模块</h4><p>基础语法</p><figure class="highlight fsharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fsharp">npm uninstall <span class="hljs-meta">[&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;]</span>... [-S|--save|-D|--save-dev|-O|--save-optional]<br></code></pre></div></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima"><span class="hljs-built_in">aliases</span>: <span class="hljs-built_in">remove</span>, rm, r, un, unlink<br></code></pre></div></td></tr></table></figure><p>如卸载开发版本的模块</p><figure class="highlight q"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs q">npm uninstall gulp --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span><br></code></pre></div></td></tr></table></figure><h4 id="npm-update-更新模块"><a href="#npm-update-更新模块" class="headerlink" title="npm update 更新模块"></a>npm update 更新模块</h4><p>基础语法</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">npm update <span class="hljs-selector-attr">[-g]</span> <span class="hljs-selector-attr">[&lt;pkg&gt;...]</span><br></code></pre></div></td></tr></table></figure><h4 id="npm-outdated-检查模块是否已经过时"><a href="#npm-outdated-检查模块是否已经过时" class="headerlink" title="npm outdated 检查模块是否已经过时"></a>npm outdated 检查模块是否已经过时</h4><p>基础语法</p><figure class="highlight bnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bnf">npm outdated [[<span class="hljs-attribute">&lt;@scope&gt;</span>/]<span class="hljs-attribute">&lt;pkg&gt;</span> ...]<br></code></pre></div></td></tr></table></figure><p>此命令会列出所有已经过时的包，可以及时进行包的更新。</p><h4 id="npm-ls-查看安装的模块"><a href="#npm-ls-查看安装的模块" class="headerlink" title="npm ls 查看安装的模块"></a>npm ls 查看安装的模块</h4><p>基础语法</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">npm <span class="hljs-keyword">ls</span> [[&lt;@scope&gt;/]<span class="hljs-symbol">&lt;pkg&gt;</span> ...]<br><br>aliase<span class="hljs-variable">s:</span> <span class="hljs-keyword">list</span>, <span class="hljs-keyword">la</span>, <span class="hljs-keyword">ll</span><br></code></pre></div></td></tr></table></figure><p>查看全局安装的模块及依赖 </p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> ls -g <br></code></pre></div></td></tr></table></figure><h4 id="npm-version-查看模块版本"><a href="#npm-version-查看模块版本" class="headerlink" title="npm version 查看模块版本"></a>npm version 查看模块版本</h4><p>基础语法</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">npm <span class="hljs-keyword">version</span> [&lt;newversion&gt; | major | minor | patch | premajor | preminor | prepatch | prerelease | <span class="hljs-keyword">from</span>-git]<br><br><span class="hljs-string">&#x27;npm [-v | --version]&#x27;</span> <span class="hljs-keyword">to</span> print npm <span class="hljs-keyword">version</span><br><span class="hljs-string">&#x27;npm view &lt;pkg&gt; version&#x27;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">view</span> a packag<span class="hljs-string">e&#x27;s published version</span><br><span class="hljs-string">&#x27;</span>npm ls<span class="hljs-string">&#x27; to inspect current package/dependency versions</span><br></code></pre></div></td></tr></table></figure><p>查看模块的版本：<code>npm version</code></p><h5 id="模块的版本号"><a href="#模块的版本号" class="headerlink" title="模块的版本号"></a>模块的版本号</h5><p>npm 使用的是一种叫做 semantic version 的规范，它的规则很简单，总结起来就是下面几条：</p><p>使用 semver 的软件必须定义公开、严谨、易于理解的 API。也就是模块要提供功能给用户。</p><p>版本号格式为：<strong>X.Y.Z</strong>，并且 X、Y、Z 均为正整数并且不断递增。X 表示大版本（major）、Y 表示小版本（minor）、Z 表示补丁版本（patch）。</p><p>一个版本发布后，此版本内容不能再变更，变更必须再发布一个新版本。也就是不能覆盖发布。</p><p><strong>0.Y.Z</strong> 表示初始版本，这种版本下的 API 不能保证稳定，随时可能变更。</p><p>当进行了向后兼容的 bug 修复时，补丁版本 Z 必须增加。</p><p>当引入了向后兼容的新功能时，小版本 Y 必须增加，同时 Z 必须重置为 0（小版本里面可能会包含 bug 修复）。</p><p>当引入了不兼容的变更时，大版本 X 必须增加，同时 Y、Z 必须重置为 0（大版本里面可能会包含小版本或者补丁版本的改动）。</p><p><strong>X.Y.Z</strong> 后面还可以加预发布版本号、构建信息，格式为：<strong>X.Y.Z-pre_lease+build_meta</strong>，比如：<strong>1.0.0-alpha+20151226</strong>、<strong>1.0.0-beta.2+20151230</strong>。</p><p>进行版本号比较时，遵循下面的规则：1）依次按数值比较 X、Y、Z 的值，直到第一个不同的位置；2）如果两个版本的 X、Y、Z 都相等，含有 pre-release 版本号的较小；3）如果两个版本的 X、Y、Z 都相等并且都含有 pre-release 版本号，要单独比较 pre-release 版本。比如：<strong>1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1，1.0.0-alpha &lt; 1.0.0，1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2</strong>。</p><h4 id="npm-view-查看模块的注册信息"><a href="#npm-view-查看模块的注册信息" class="headerlink" title="npm view 查看模块的注册信息"></a>npm view 查看模块的注册信息</h4><p>基础语法</p><figure class="highlight fsharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fsharp">npm view <span class="hljs-meta">[&lt;@scope&gt;/]&lt;name&gt;[@&lt;version&gt;]</span> <span class="hljs-meta">[&lt;field&gt;[.&lt;subfield&gt;]</span>...]<br><br>aliases: info, show, v<br></code></pre></div></td></tr></table></figure><p>查看模块的依赖关系</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">npm <span class="hljs-built_in">view</span> gulp <span class="hljs-built_in">dependencies</span><br></code></pre></div></td></tr></table></figure><p>查看模块的源文件地址</p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> view gulp repository.url<br></code></pre></div></td></tr></table></figure><p>查看模块的贡献者，包含邮箱地址</p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> view <span class="hljs-built_in">npm</span> contributors<br></code></pre></div></td></tr></table></figure><h4 id="npm-help-查看某条命令的详细帮助"><a href="#npm-help-查看某条命令的详细帮助" class="headerlink" title="npm help 查看某条命令的详细帮助"></a>npm help 查看某条命令的详细帮助</h4><p>基础语法</p><figure class="highlight fsharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fsharp">npm help &lt;term&gt; <span class="hljs-meta">[&lt;terms..&gt;]</span><br></code></pre></div></td></tr></table></figure><p>例如输入<code>npm help install</code>，系统在默认的浏览器或者默认的编辑器中打开本地nodejs安装包的文件<code>/nodejs/node_modules/npm/html/doc/cli/npm-install.html</code></p><h4 id="npm-init-在项目中引导创建一个package-json文件"><a href="#npm-init-在项目中引导创建一个package-json文件" class="headerlink" title="npm init 在项目中引导创建一个package.json文件"></a>npm init 在项目中引导创建一个package.json文件</h4><p>安装包的信息可保持到项目的package.json文件中，以便后续的其它的项目开发或者他人合作使用，也说package.json在项目中是必不可少的。</p><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">npm init [-f|<span class="hljs-type">--force</span>|<span class="hljs-type">-y</span>|<span class="hljs-type">--yes</span>]<br></code></pre></div></td></tr></table></figure><h4 id="npm-package-json的语法"><a href="#npm-package-json的语法" class="headerlink" title="npm package.json的语法"></a>npm package.json的语法</h4><p>英文原版：<a href="https://docs.npmjs.com/files/package.json">https://docs.npmjs.com/files/package.json</a></p><p>这块内容好多，国内有好心人整理：《npm的package.json中文文档》，从这份文档拷贝出一些比较常见的，如下：</p><p><strong>默认值</strong></p><p>npm会根据包内容设置一些默认值。</p><p>“scripts”: {“start”: “node server.js”}</p><p>如果包的根目录有server.js文件，npm会默认将start命令设置为node server.js。</p><p>“scripts”:{“preinstall”: “node-waf clean || true; node-waf configure build”}</p><p>如果包的根目录有wscript文件，npm会默认将preinstall命令用node-waf进行编译。</p><p>“scripts”:{“preinstall”: “node-gyp rebuild”}</p><p>如果包的根目录有binding.gyp文件，npm会默认将preinstall命令用node-gyp进行编译。</p><p>“contributors”: […]</p><p>如果包的根目录有AUTHORS文件，npm会默认逐行按Name <email> (url)格式处理，邮箱和url是可选的。#号和空格开头的行会被忽略。</p><p><strong>name</strong></p><p>在package.json中最重要的就是name和version字段。他们都是必须的，如果没有就无法install。name和version一起组成的标识在假设中是唯一的。改变包应该同时改变version。</p><p>name是这个东西的名字。注意：</p><ul><li>不要把node或者js放在名字中。因为你写了package.json它就被假定成为了js，不过你可以用”engine”字段指定一个引擎（见后文）。</li><li>这个名字会作为在URL的一部分、命令行的参数或者文件夹的名字。任何non-url-safe的字符都是不能用的。</li><li>这个名字可能会作为参数被传入require()，所以它应该比较短，但也要意义清晰。</li><li>在你爱上你的名字之前，你可能要去npm registry查看一下这个名字是否已经被使用了。<a href="http://registry.npmjs.org/">http://registry.npmjs.org/</a><br><strong>version</strong></li></ul><p>version必须能被<a href="https://github.com/npm/node-semver">node-semver</a>解析，它被包在npm的依赖中。（要自己用可以执行npm install semver）</p><p>可用的“数字”或者“范围”见semver(7).</p><p><strong>description</strong></p><p>放简介，字符串，方便在npm search中搜索</p><p><strong>keywords</strong></p><p>关键字，数组、字符串，方便在npm search中搜索</p><p><strong>bugs</strong></p><p>你项目的提交问题的url和（或）邮件地址</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br> <span class="hljs-attr">&quot;url&quot;</span> : <span class="hljs-string">&quot;http://github.com/owner/project/issues&quot;</span>, <br><span class="hljs-attr">&quot;email&quot;</span> : <span class="hljs-string">&quot;project@hostname.com&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>license</strong></p><p>你应该要指定一个许可证，让人知道使用的权利和限制的。</p><p>最简单的方法是，假如你用一个像BSD或者MIT这样通用的许可证，就只需要指定一个许可证的名字，像这样：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123; <span class="hljs-attr">&quot;license&quot;</span> : <span class="hljs-string">&quot;BSD&quot;</span> &#125;<br></code></pre></div></td></tr></table></figure><p>如果你又更复杂的许可条件，或者想要提供给更多地细节，可以这样:</p><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada"><span class="hljs-string">&quot;licenses&quot;</span> : [<br>  &#123; <span class="hljs-string">&quot;type&quot;</span> : &quot;<span class="hljs-type">MyLicense</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">  , &quot;</span>url<span class="hljs-string">&quot; : &quot;</span>http://github.com/owner/project/path/to/license<span class="hljs-string">&quot;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">]</span><br></code></pre></div></td></tr></table></figure><p><strong>repository</strong></p><p>指定你的代码存放的地方。这个对希望贡献的人有帮助。如果git仓库在github上，那么npm docs命令能找到你。</p><p>这样做：</p><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada"><span class="hljs-string">&quot;repository&quot;</span> :<br>  &#123; <span class="hljs-string">&quot;type&quot;</span> : &quot;<span class="hljs-type">git</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">  , &quot;</span>url<span class="hljs-string">&quot; : &quot;</span>http://github.com/isaacs/npm.git<span class="hljs-string">&quot;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;</span>repository<span class="hljs-string">&quot; :</span><br><span class="hljs-string">  &#123; &quot;</span><span class="hljs-keyword">type</span><span class="hljs-string">&quot; : &quot;</span>svn<span class="hljs-string">&quot;</span><br><span class="hljs-string">  , &quot;</span>url<span class="hljs-string">&quot; : &quot;</span>http://v8.googlecode.com/svn/trunk/<span class="hljs-string">&quot;</span><br><span class="hljs-string">  &#125;</span><br></code></pre></div></td></tr></table></figure><p>URL应该是公开的（即便是只读的）能直接被未经过修改的版本控制程序处理的url。不应该是一个html的项目页面。因为它是给计算机看的。</p><p><strong>scripts</strong></p><p>“scripts”是一个由脚本命令组成的hash对象，他们在包不同的生命周期中被执行。key是生命周期事件，value是要运行的命令。</p><p><strong>config</strong></p><p>“config” hash可以用来配置用于包脚本中的跨版本参数。在实例中，如果一个包有下面的配置：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br> <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;foo&quot;</span>,<br> <span class="hljs-attr">&quot;config&quot;</span> : &#123; <span class="hljs-attr">&quot;port&quot;</span> : <span class="hljs-string">&quot;8080&quot;</span> &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后有一个“start”命令引用了npm_package_config_port环境变量，用户可以通过npm config set foo:port 8001来重写他。</p><p><strong>dependencies</strong></p><p>依赖是给一组包名指定版本范围的一个hash。这个版本范围是一个由一个或多个空格分隔的字符串。依赖还可以用tarball或者git URL。</p><p>请不要将测试或过渡性的依赖放在dependencieshash中。见下文的devDependencies</p><ul><li><p>version 必须完全和version一致</p></li><li><p>&gt;version 必须比version大</p></li><li><p>&gt;=version 同上</p></li><li><p>&lt;version 同上</p></li><li><p>&lt;=version 同上</p></li><li><p>~version 大约一样</p></li><li><p>1.2.x 1.2.0, 1.2.1, 等，但不包括1.3.0</p></li><li><p>http://… 见下文’依赖URL’</p></li><li><p>*所有</p></li><li><p>“” 空，同*</p></li><li><p>version1 - version2 同 &gt;=version1 &lt;=version2.</p></li><li><p>range1 || range2 二选一。</p></li><li><p>git… 见下文’依赖Git URL’</p></li><li><p>user/repo 见下文’GitHub URLs’</p></li></ul><p>比如下面都是合法的：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123; <span class="hljs-attr">&quot;dependencies&quot;</span> :<br>  &#123; <span class="hljs-attr">&quot;foo&quot;</span> : <span class="hljs-string">&quot;1.0.0 - 2.9999.9999&quot;</span><br>  , <span class="hljs-attr">&quot;bar&quot;</span> : <span class="hljs-string">&quot;&gt;=1.0.2 &lt;2.1.2&quot;</span><br>  , <span class="hljs-attr">&quot;baz&quot;</span> : <span class="hljs-string">&quot;&gt;1.0.2 &lt;=2.3.4&quot;</span><br>  , <span class="hljs-attr">&quot;boo&quot;</span> : <span class="hljs-string">&quot;2.0.1&quot;</span><br>  , <span class="hljs-attr">&quot;qux&quot;</span> : <span class="hljs-string">&quot;&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0&quot;</span><br>  , <span class="hljs-attr">&quot;asd&quot;</span> : <span class="hljs-string">&quot;http://asdf.com/asdf.tar.gz&quot;</span><br>  , <span class="hljs-attr">&quot;til&quot;</span> : <span class="hljs-string">&quot;~1.2&quot;</span><br>  , <span class="hljs-attr">&quot;elf&quot;</span> : <span class="hljs-string">&quot;~1.2.3&quot;</span><br>  , <span class="hljs-attr">&quot;two&quot;</span> : <span class="hljs-string">&quot;2.x&quot;</span><br>  , <span class="hljs-attr">&quot;thr&quot;</span> : <span class="hljs-string">&quot;3.3.x&quot;</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>devDependencies</strong></p><p>如果有人要使用你的模块，那么他们可能不需要你开发使用的外部测试或者文档框架。</p><p>在这种情况下，最好将这些附属的项目列在devDependencies中。</p><p>这些东西会在执行npm link或者npm install的时候初始化，并可以像其他npm配置参数一样管理。详见npm-config(7)。</p><p>对于非特定平台的构建步骤，比如需要编译CoffeeScript，可以用prepublish脚本去实现，并把它依赖的包放在devDependency中。（译者注：prepublish定义了在执行npm publish的时候先行执行的脚本）</p><p>比如：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;ethopia-waza&quot;</span>,<br>  <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;a delightfully fruity coffee varietal&quot;</span>,<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.2.3&quot;</span>,<br>  <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;coffee-script&quot;</span>: <span class="hljs-string">&quot;~1.6.3&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;prepublish&quot;</span>: <span class="hljs-string">&quot;coffee -o lib/ -c src/waza.coffee&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;lib/waza.js&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>prepublish脚本会在publishing前运行，这样用户就不用自己去require来编译就能使用。并且在开发模式中（比如本地运行npm install）会运行这个脚本以便更好地测试。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/PeunZhang/p/5553574.html">【原】npm 常用命令详解</a></p><p><a href="https://segmentfault.com/a/1190000004221514">深入 Node 模块的安装和发布</a></p><p><a href="https://github.com/ericdum/mujiang.info/issues/6/">npm的package.json中文文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一台电脑多git账号如何部署hexo博客</title>
    <link href="/2020/06/gits-hexo-d/"/>
    <url>/2020/06/gits-hexo-d/</url>
    
    <content type="html"><![CDATA[<h3 id="多git账号部署hexo博客"><a href="#多git账号部署hexo博客" class="headerlink" title="多git账号部署hexo博客"></a>多git账号部署hexo博客</h3><p>如何在一台电脑上配置多个git账号可以看我的这篇博客<a href="">一台电脑设置多个Git账号</a></p><p>前面成功配置git账号之后，接下来就是修改hexo配置文件的git部署地址，打开你博客根目录下的<code>_config.yml</code>文件（注意是博客根目录下的配置文件，不是别的地方的），找到deploy项，改为如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@你在config文件内配置的host别名:你的用户名/你的用户名.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></div></td></tr></table></figure><p>按理来说这样就可以成功使用<code>hexo g-d</code>部署博客到Github 上了，但是我却遇到了问题。。</p><h3 id="部署时遇到的问题和解决办法"><a href="#部署时遇到的问题和解决办法" class="headerlink" title="部署时遇到的问题和解决办法"></a>部署时遇到的问题和解决办法</h3><p>当在一台电脑上配置了不止一个git账号时，部署博客就出现了一个奇怪的问题：</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p><p>就像上面图片一样，错误的原因是没有配置user.email和user.name，既然没有配置，那我配置上不就好了吗：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config user.email <span class="hljs-string">&quot;youremail&quot;</span><br>git config user.name  <span class="hljs-string">&quot;yourname&quot;</span><br></code></pre></div></td></tr></table></figure><p>备注：这里我没有用<code>--global</code>设置全局的name和Email，主要是因为电脑有多个git账户，怕以后提交的时候出现，明明想用这个用户提交，结果实际却用了另外一个，用上面的代码分别为每个项目设置name和Email就不用担心这样的问题了。</p><p>但是当我配置完之后再执行部署命令时依然报错，而且和原来的好像还有一点不一样，但是看原因好像还是没有配置name和Email：</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p><p>这就奇怪了，我刚刚才配置完，怎么还说没有配置呢。我又检查了博客下的<code>_config.yml</code>文件deploy配置，确定没有错误之后我又尝试了一下，还是不行。这时我想到以前为了配置多个git账号，曾经看了很多相关的文章，其中有篇文章好像提到了git提交时报没有配置user的错误，解决办法是到项目下的<code>.git</code>文件夹内找到<code>config</code>这个文件，在这个文件的后面加上这样一段内容：</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-section">[user]</span><br><span class="hljs-attr">email</span>=your email<br><span class="hljs-attr">name</span>=your name<br></code></pre></div></td></tr></table></figure><p>想到这里，我又去了博客下的<code>.git</code>文件夹看了下<code>config</code>这个文件，发现里面有上面的内容，既然这样那就不应该了，为什么会部署不上呢，这时我突然看到有一个叫<code>.deploy_git</code>的文件夹，这个文件夹我记得一开始是不存在的，应该是在部署之后生成的，并且我在把博客源文件推到git上时也忽略了这个文件夹没有推送，这个文件夹内我记得也有一个<code>.git</code>文件夹，那肯定也有<code>config</code>文件，打开文件一看果然这个文件内没有上面提到的user，在我添加上之后再使用<code>hexo d</code>部署博客，发现推送成功了。之后我又仔细看了下两个<code>.git</code>文件夹内的<code>config</code>文件的区别，发现一个是配置的博客源文件的地址，另一个则是生成的博客静态文件也就是博客网站那个仓库的地址，因为只配置了源文件仓库的地址没有配置网站静态文件仓库的地址，所以才会一直报错。</p><p>但是还有一个不太明白的点，之前我只用一个git账号部署博客的时候并没有出现这样的问题，只要把博客的配置文件和user.email与user.name都写好就能完成部署，但是现在有多个账号了则不行，我还没有搞清楚是什么原因，如果有人知道是怎么回事麻烦告诉我一下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>-Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一台电脑设置多个Git账号</title>
    <link href="/2020/06/cfg-multiple-git-accounts/"/>
    <url>/2020/06/cfg-multiple-git-accounts/</url>
    
    <content type="html"><![CDATA[<p>我们可能经常会用到不止一个git账号（比如一个github一个gitee），用于管理不同的项目，那怎么在一台电脑上配置两个或两个以上的git账号呢，下面介绍一下具体的方法，也算做个记录，以后忘了可以来看看。</p><h3 id="生成SSH-Key"><a href="#生成SSH-Key" class="headerlink" title="生成SSH Key"></a>生成SSH Key</h3><p>如果之前没有生成过SSH Key的话，需要先生成，在命令行内执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ssh-keygen -t rsa -C<span class="hljs-string">&quot;你的github邮箱地址&quot;</span><br></code></pre></div></td></tr></table></figure><p>通常配置一个SSH Key的时候只要一路回车下去就行了，但是现在要配置多个，就不能一路回车到底了，因为要设置某些内容。在运行上面命令之后会一步一步的出现下面的提示内容：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#提示是否使用新的文件名,如果不输入新的文件名，则生成id_rsa文件。</span><br><span class="hljs-comment">##直接输入文件名会在当前执行cmd或者bash文件夹内生成，如果想在.ssh文件夹生成需要把路径写完整</span><br>Enter file <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> to save the key (~/.ssh/id_rsa):<br><span class="hljs-comment">#请输入确认密码，后面还会用到（至少4位数），如果缺省直接按回车</span><br><span class="hljs-comment">##此密码是验证id_rsa的密码，每次代码commit时得输入</span><br>Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase):<br><span class="hljs-comment">#再次输入密码</span><br>Enter same passphrase again:<br></code></pre></div></td></tr></table></figure><p>在生成多个SSH Key重复执行上面的命令即可，在生成第二个之后的ssh keygen时，一定要把生成的ssh keygen文件名或者路径改掉，不要用默认的，不然会把前面生成的覆盖掉。密码有没有都无所谓，记不住就别设，免得到时候忘了密码用不了。</p><h3 id="配置公钥"><a href="#配置公钥" class="headerlink" title="配置公钥"></a>配置公钥</h3><p>前面生成的ssh keygen文件正常情况下应该在<code>C:\\\\User\\你的用户名\\.ssh</code>这个文件夹内，如果没有就自己搜索一下放在哪了吧，打开这个文件夹，你会看到有多个文件，把其中有<code>pub</code>后缀的文件打开，将里面的内容添加到对应的git账号上，以GitHub为例，登录上你的GitHub账号，然后点击你的头像，在下拉菜单中找到settings，</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p><p>然后在页面中找到<code>SSH and GPG keys</code>这一项，</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p><p>接着在右边点击<code>New SSHKey</code>把对应的公钥文件内容复制进去，并且起一个名字，大体知道是用来做什么的。</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p><h3 id="配置config文件（重点）"><a href="#配置config文件（重点）" class="headerlink" title="配置config文件（重点）"></a>配置config文件（重点）</h3><p>进入<code>.ssh</code>文件夹，查看这个文件夹内是否有名为<code>config</code>的文件，如果没有就用<code>touch config</code>新建一个（注意这个命令是bash内执行，如果使用的是cmd则不能用），在新建的文件内加上下面的内容：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#github one</span><br>   Host github_one            <br>   Hostname github.com      <br>   User git_one                    <br>   IdentityFile ~/.ssh/id_rsa   <br>   <br><span class="hljs-comment">#github two</span><br>   Host github_two<br>   Hostname github.com<br>   User git_two<br>   IdentityFile C:\\Users\\你的用户名\\.ssh\\id_rsa_two<br><br><span class="hljs-comment">##如果有第三个或者更多</span><br><span class="hljs-comment">#github more</span><br>   Host github_more<br>   Hostname github.com<br>   User git_more<br>   IdentityFile ~/.ssh/id_rsa_more<br></code></pre></div></td></tr></table></figure><p><strong>说明：</strong><br> HostName 　　　　　　　真实的域名地址<br> IdentityFile 　　　　　　　这个是id_rsa的地址（就是私钥的位置，上面两种写法都可）<br> PreferredAuthentications   配置登录时用什么权限认证（可设为publickey,password publickey,keyboard-interactive等）<br> User 　　　　　　　　　　配置使用用户名</p><p>每个账号单独配置一个<strong>Host</strong>，每个<strong>Host</strong>要取一个别名，每个Host主要配置<strong>HostName</strong>和<strong>IdentityFile</strong>两个属性即可，host可以取为便于区分的名字，如GitHub，gitee，这个host后续会影响到git的相关命令，如果忘了可以到这个config文件中查看。</p><h3 id="测试是否配置成功"><a href="#测试是否配置成功" class="headerlink" title="测试是否配置成功"></a>测试是否配置成功</h3><p>在命令行中输入下面的命令测试是否配置成功：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ssh -T git@github_one <br>ssh -T git@github_two<br></code></pre></div></td></tr></table></figure><p>注意@后面不再是<code>github.com</code>，而是前面你在config文件配置的host的名字。如果配置成功会返回下面的话：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">Hi XXX! You<span class="hljs-string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></code></pre></div></td></tr></table></figure><h3 id="设置提交用户名和电子邮件地址"><a href="#设置提交用户名和电子邮件地址" class="headerlink" title="设置提交用户名和电子邮件地址"></a>设置提交用户名和电子邮件地址</h3><p>在电脑上设置了多个git账号之后最好为每个项目分别设置提交的用户名和电子邮件，这样就不会有希望用这个账号提交项目，结果实际上是另外一个账号提交的情况发生了。另外，GitHub的contributions统计就是按照你提交时设置的邮箱来统计的。</p><p>如果已经设置了全局（global）的user和email，最好先取消掉：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> user.name<br>git config --global --<span class="hljs-built_in">unset</span> user.email<br></code></pre></div></td></tr></table></figure><p>然后为每个项目设置自己的user和email：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config user.email <span class="hljs-string">&quot;youremail&quot;</span><br>git config user.name <span class="hljs-string">&quot;yourusername&quot;</span><br></code></pre></div></td></tr></table></figure><p>git通常有三个级别的配置文件，分别是：</p><ol><li><code>/etc/gitconfig</code> 文件：这个文件位于Git的安装目录下，包含系统上每一个用户及他们仓库的通用配置。 如果在执行 <code>git config</code> 时带上 <code>--system</code> 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户（在 Windows 系统中，一般情况下是 <code>C:\Users\$USER</code> ）。你可以传递 <code>--global</code> 选项让 Git 读写此文件，这会对你系统上 <strong>所有</strong> 的仓库生效。</li><li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（即 <code>.git/config</code>）：针对该仓库。 你可以传递 <code>--local</code> 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。（当然，你需要进入某个 Git 仓库中才能让该选项生效。）</li></ol><p>另外，每一个级别会覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量，也就是说Git会优先使用库级别的配置，再然后是global级别的配置，最后是system级别的配置。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://www.melodydance.top/git-more.html">一台电脑配置两个或多个git帐号</a></p><p><a href="https://www.jianshu.com/p/7ee167911597">一个git配置多个github账号</a></p><p><a href="https://www.cnblogs.com/popfisher/p/5731232.html">Windows下Git多账号配置，同一电脑多个ssh-key的管理</a></p><p><a href="https://www.jianshu.com/p/d696b5fef750">git多账号提交适配</a></p><p><a href="https://help.github.com/cn/github/setting-up-and-managing-your-github-user-account/setting-your-commit-email-address">设置提交电子邮件地址</a></p><p><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE">1.6 起步 - 初次运行 Git 前的配置</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>舔狗日记生成器</title>
    <link href="/2020/06/tiangou-riji/"/>
    <url>/2020/06/tiangou-riji/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树的遍历</title>
    <link href="/2020/06/data-structure01/"/>
    <url>/2020/06/data-structure01/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h2><h3 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h3><ol><li>输入输出</li></ol><p>算法具有零个或者多个输入，同时，算法具有至少一个的输出。</p><ol start="2"><li>确定性</li></ol><p>算法的每一步都具有确定的含义，无二义性。任何条件下，算法只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。</p><p>3)有穷性</p><p>一个算法总是需要（输入合法的情况下）在有限的步骤结束，即每个算法需要在有穷的时间内完成。</p><p>4)可行性</p><p>一个算法是可以被执行的，即算法中的每个操作都可以通过已经实现的基本运算执行有限的次数完成。</p><h3 id="算法设计要求"><a href="#算法设计要求" class="headerlink" title="算法设计要求"></a>算法设计要求</h3><ol><li>正确性</li></ol><p>正确性（Correctness）指的是该算法能够满足预先指定的功能与性能的需求，即能够得到正确答案。</p><p>2)健壮性</p><p>健壮性（Robustness）指的是当输入数据不合法时，算法也能做出相关的处理，而不是产生不可预计的效果。</p><p>3)可读性</p><p>可读性（Readability）指的是算法是可以阅读，理解和交流的。</p><p>4)耗时低，占用空间少</p><p>运行时间（Running time）与占用空间（Storage space）概念，在设计算法时，我们总是希望能够更少的使用时间和空间达成我们的目标。</p><h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h3><p>1)数据</p><p>数据（Data）是信息的载体，是可以被计算机识别，存储并加工处理的描述客观事物的信息符号的总称。数据不仅仅包括了整形，浮点数等数值类型，还包括了字符甚至声音，视频，图像等非数值的类型。</p><p>2)数据元素</p><p>数据元素（Data Element）是描述数据的基本单位，也被称为记录。一个数据元素有若干个数据项组成。</p><p>如禽类，鸡鸭都属于禽类的数据元素。</p><p>3)数据项</p><p>数据项（Data Item）是描述数据的最小单位，其可以分为组合项和原子项：</p><p>a)组合项</p><p>如果数据元素可以再度分割，则每一个独立处理单元就是数据项，数据元素就是数据项的集合。</p><p>b)原子项</p><p>如果数据元素不能再度分割，则每一个独立处理的单元就是原子项。</p><p>如日期2019年4月25日就是一个组合项，其表示日期，但如果单独拿25日这个数据出来观测，这就是一个原子项，因为其不可以再分割。</p><p>4)数据对象</p><p>数据对象（Data Object）是性质相同的一类数据元素的集合，是数据的一个子集。数据对象可以是有限的，也可以是无限的。</p><p>5)数据结构</p><p>数据结构（Data Structures）主要是指数据和关系的集合，数据指的是计算机中需要处理的数据，而关系指的是这些数据相关的前后逻辑，这些逻辑与计算机储存的位置无关，其主要包含以下四大逻辑结构。</p><h3 id="四大逻辑结构（Logic-Structure）"><a href="#四大逻辑结构（Logic-Structure）" class="headerlink" title="四大逻辑结构（Logic Structure）"></a>四大逻辑结构（Logic Structure）</h3><ol><li>集合结构</li></ol><p>集合结构（Set Structure）中所有数据元素除了同属于一个集合外，并无其他关系。</p><ol start="2"><li>线性结构</li></ol><p>线性结构（Linear Structure）指的是数据元素之间存在“一对一的关系”</p><ol start="3"><li>树形结构</li></ol><p>树形结构（Tree Structure）指的是数据元素之间存在“一对多”的层次关系。</p><ol start="4"><li>图形结构</li></ol><p>图形结构（Graphic Structure，也称：网状结构）指的是数据元素之间存在“多对多的关系”（注：此时的“多对多”中的多表示，至少有一个）</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol><li>数据类型</li></ol><p>数据类型（Data Type）是高级程序设计语言中的概念，是数据的取值范围和对数进行操作的总和。数据类型规定了程序中对象的特性。程序中的每一个变量，常量或者表达式都属于一种数据类型。</p><ol start="2"><li>抽象数据类型</li></ol><p>抽象数据类型（Abstract Data Type，ADT）只是一个数学模型以及定义在模型上的一组操作。通常是对数据的抽象，定义了数据的取值范围以及对数据操作的集合。</p><p>抽象数据类型的特征是实现与操作分离，从而实现封装。</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ol><li>时间复杂度</li></ol><p>时间复杂度表示一个程序运行所需要的时间，其具体需要在机器环境中才能得到具体的值，但我们一般并不需要得到详细的值，只是需要比较快慢的区别即可，为此，我们需要引入时间频度（语句频度）的概念。</p><p>时间频度中，n称为问题的规模，当n不断变化时,时间频度T(n)也会不断变化。一般情况下，算法中的基本操作重复次数的是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</p><p>2)空间复杂度</p><p>一个程序的空间复杂度是指运行完一个程序所需内存的大小，其包括两个部分。</p><p>a)固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。</p><p>b)可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/sort.png">https://www.runoob.com/wp-content/uploads/2019/03/sort.png</a></p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png">https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的遍历</title>
    <link href="/2020/06/data-structure02/"/>
    <url>/2020/06/data-structure02/</url>
    
    <content type="html"><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><strong>顺序存储结构和链式存储结构</strong></p><p>线性表存储数据可细分为以下 2 种：</p><p>将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构（简称顺序表）；<br>数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构（简称链表）；</p><p>也就是说，线性表存储结构可细分为顺序存储结构和链式存储结构。</p><p><strong>线性表常用术语</strong></p><p>数据结构中，一组数据中的每个个体被称为“数据元素”（简称“元素”）。</p><p>另外，对于具有“一对一”逻辑关系的数据，我们一直在用“某一元素的左侧（前边）或右侧（后边）”这样不专业的词，其实线性表中有更准确的术语：</p><p>某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”；<br>某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”；</p><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙，将“具有 ‘一对一’ 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构。</p><h4 id="顺序表的初始化"><a href="#顺序表的初始化" class="headerlink" title="顺序表的初始化"></a>顺序表的初始化</h4><p>使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下 2 项数据：</p><ul><li><p>顺序表申请的存储容量；</p></li><li><p>顺序表的长度，也就是表中存储数据元素的个数；</p></li></ul><p>提示：正常状态下，顺序表申请的存储容量要大于顺序表的长度。</p><p>因此，我们需要自定义顺序表，C 语言实现代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Table</span>&#123;</span><br>    <span class="hljs-keyword">int</span> * head;<span class="hljs-comment">//声明了一个名为head的长度不确定的数组，也叫“动态数组”</span><br>    <span class="hljs-keyword">int</span> length;<span class="hljs-comment">//记录当前顺序表的长度</span><br>    <span class="hljs-keyword">int</span> size;<span class="hljs-comment">//记录顺序表分配的存储容量</span><br>&#125;table;<br></code></pre></div></td></tr></table></figure><p>注意，head 是我们声明的一个未初始化的动态数组，不要只把它看做是普通的指针。</p><p>接下来开始学习顺序表的初始化，也就是初步建立一个顺序表。建立顺序表需要做如下工作：</p><p>给 head 动态数据申请足够大小的物理空间；</p><p>给 size 和 length 赋初值；</p><p>因此，C 语言实现代码如下：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-comment">#define Size 5 //对Size进行宏定义，表示顺序表申请空间的大小</span><br>table initTable()&#123;<br>    table t;<br>    t.head = (int*)malloc(Size * sizeof(int));<span class="hljs-regexp">//</span>构造一个空的顺序表，动态申请存储空间<br>    <span class="hljs-keyword">if</span> (!t.head) <span class="hljs-regexp">//</span>如果申请失败，作出提示并直接退出程序<br>    &#123;<br>        printf(<span class="hljs-string">&quot;初始化失败&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    t.length = <span class="hljs-number">0</span>;<span class="hljs-regexp">//</span>空表的长度初始化为<span class="hljs-number">0</span><br>    t.size = Size;<span class="hljs-regexp">//</span>空表的初始存储空间为Size<br>    return t;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>顺序表初始化过程中，要注意对物理空间的申请进行判断，对申请失败的情况进行处理</p><p>顺序表插入元素</p><p>向已有顺序表中插入数据元素，根据插入位置的不同，可分为以下 3 种情况：</p><p>插入到顺序表的表头；<br>在表的中间位置插入元素；<br>尾随顺序表中已有元素，作为顺序表中的最后一个元素；</p><p>虽然数据元素插入顺序表中的位置有所不同，但是都使用的是同一种方式去解决，即：通过遍历，找到数据元素要插入的位置，然后做如下两步工作：</p><p>将要插入位置元素以及后续的元素整体向后移动一个位置；<br>将元素放到腾出来的位置上；</p><p>顺序表插入数据元素的 C 语言实现代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">//插入函数，其中，elem为插入的元素，add为插入到顺序表的位置</span><br><span class="hljs-function">table <span class="hljs-title">addTable</span><span class="hljs-params">(table t, <span class="hljs-keyword">int</span> elem, <span class="hljs-keyword">int</span> add)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-comment">//判断插入本身是否存在问题（如果插入元素位置比整张表的长度+1还大（如果相等，是尾随的情况），或者插入的位置本身不存在，程序作为提示并自动退出）</span><br>    <span class="hljs-keyword">if</span> (add &gt; t.length + <span class="hljs-number">1</span> || add &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置有问题&quot;</span>);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-comment">//做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，如果没有，需要申请</span><br>    <span class="hljs-keyword">if</span> (t.length == t.size) &#123;<br>        t.head = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">realloc</span>(t.head, (t.size + <span class="hljs-number">1</span>) * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>));<br>        <span class="hljs-keyword">if</span> (!t.head) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;存储分配失败&quot;</span>);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br>        t.size += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//插入操作，需要将从插入位置开始的后续元素，逐个后移</span><br>    <span class="hljs-keyword">for</span> (i = t.length - <span class="hljs-number">1</span>; i &gt;= add - <span class="hljs-number">1</span>; i--) &#123;<br>        t.head[i + <span class="hljs-number">1</span>] = t.head[i];<br>    &#125;<br>    <span class="hljs-comment">//后移完成后，直接将所需插入元素，添加到顺序表的相应位置</span><br>    t.head[add - <span class="hljs-number">1</span>] = elem;<br>    <span class="hljs-comment">//由于添加了元素，所以长度+1</span><br>    t.length++;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意，动态数组额外申请更多物理空间使用的是 realloc 函数。</p><p>顺序表删除元素</p><p>从顺序表中删除指定元素，实现起来非常简单，只需找到目标元素，并将其后续所有元素整体前移 1 个位置即可。<br>后续元素整体前移一个位置，会直接将目标元素删除，可间接实现删除元素的目的。</p><p>因此，顺序表删除元素的 C 语言实现代码为：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">table delTable(table t, int add) &#123;<br>    int i;<br>    <span class="hljs-keyword">if</span> (add &gt; t.length || add &lt; <span class="hljs-number">1</span>) &#123;<br>        printf(<span class="hljs-string">&quot;被删除元素的位置有误&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-regexp">//</span>删除操作<br>    <span class="hljs-keyword">for</span> (i = add; i &lt; t.length; i++) &#123;<br>        t.head[i - <span class="hljs-number">1</span>] = t.head[i];<br>    &#125;<br>    t.length--;<br>    return t;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>顺序表更改元素</p><p>顺序表更改元素的实现过程是：<br>找到目标元素；<br>直接修改该元素的值；</p><p>顺序表更改元素的 C 语言实现代码为：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">//更改函数，其中，elem为要更改的元素，newElem为新的数据元素</span><br>table amend<span class="hljs-constructor">Table(<span class="hljs-params">table</span> <span class="hljs-params">t</span>, <span class="hljs-params">int</span> <span class="hljs-params">elem</span>, <span class="hljs-params">int</span> <span class="hljs-params">newElem</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> add = select<span class="hljs-constructor">Table(<span class="hljs-params">t</span>, <span class="hljs-params">elem</span>)</span>;<br>    t.head<span class="hljs-literal">[<span class="hljs-identifier">add</span> - <span class="hljs-number">1</span>]</span> = newElem;<span class="hljs-comment">//由于返回的是元素在顺序表中的位置，所以-1就是该元素在数组中的下标</span><br>    return t;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>顺序表查找元素</p><p>顺序表中查找目标元素，可以使用多种查找算法实现，比如说二分查找算法、插值查找算法等。</p><p>这里，我们选择顺序查找算法，具体实现代码为：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">//查找函数，其中，elem表示要查找的数据元素的值</span><br><span class="hljs-built_in">int</span> select<span class="hljs-constructor">Table(<span class="hljs-params">table</span> <span class="hljs-params">t</span>, <span class="hljs-params">int</span> <span class="hljs-params">elem</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; t.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (t.head<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-operator"> == </span>elem) &#123;<br>            return i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    return -<span class="hljs-number">1</span>;<span class="hljs-comment">//如果查找失败，返回-1</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>完整的实现代码：</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Size 5</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Table</span> &#123;</span><br>    <span class="hljs-keyword">int</span> * head;<br>    <span class="hljs-keyword">int</span> length;<br>    <span class="hljs-keyword">int</span> size;<br>&#125;table;<br><span class="hljs-function">table <span class="hljs-title">initTable</span><span class="hljs-params">()</span> </span>&#123;<br>    table t;<br>    t.head = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(Size * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>));<br>    <span class="hljs-keyword">if</span> (!t.head)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;初始化失败&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    t.length = <span class="hljs-number">0</span>;<br>    t.size = Size;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-function">table <span class="hljs-title">addTable</span><span class="hljs-params">(table t, <span class="hljs-keyword">int</span> elem, <span class="hljs-keyword">int</span> add)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">if</span> (add &gt; t.length + <span class="hljs-number">1</span> || add &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置有问题&quot;</span>);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (t.length &gt;= t.size) &#123;<br>        t.head = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">realloc</span>(t.head, (t.size + <span class="hljs-number">1</span>) * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>));<br>        <span class="hljs-keyword">if</span> (!t.head) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;存储分配失败&quot;</span>);<br>        &#125;<br>        t.size += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = t.length - <span class="hljs-number">1</span>; i &gt;= add - <span class="hljs-number">1</span>; i--) &#123;<br>        t.head[i + <span class="hljs-number">1</span>] = t.head[i];<br>    &#125;<br>    t.head[add - <span class="hljs-number">1</span>] = elem;<br>    t.length++;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-function">table <span class="hljs-title">delTable</span><span class="hljs-params">(table t, <span class="hljs-keyword">int</span> add)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">if</span> (add &gt; t.length || add &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;被删除元素的位置有误&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = add; i &lt; t.length; i++) &#123;<br>        t.head[i - <span class="hljs-number">1</span>] = t.head[i];<br>    &#125;<br>    t.length--;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectTable</span><span class="hljs-params">(table t, <span class="hljs-keyword">int</span> elem)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; t.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (t.head[i] == elem) &#123;<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function">table <span class="hljs-title">amendTable</span><span class="hljs-params">(table t, <span class="hljs-keyword">int</span> elem, <span class="hljs-keyword">int</span> newElem)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> add = <span class="hljs-built_in">selectTable</span>(t, elem);<br>    t.head[add - <span class="hljs-number">1</span>] = newElem;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">displayTable</span><span class="hljs-params">(table t)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; t.length; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, t.head[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i, add;<br>    table t1 = <span class="hljs-built_in">initTable</span>();<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= Size; i++) &#123;<br>        t1.head[i - <span class="hljs-number">1</span>] = i;<br>        t1.length++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;原顺序表：\n&quot;</span>);<br>    <span class="hljs-built_in">displayTable</span>(t1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除元素1:\n&quot;</span>);<br>    t1 = <span class="hljs-built_in">delTable</span>(t1, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">displayTable</span>(t1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;在第2的位置插入元素5:\n&quot;</span>);<br>    t1 = <span class="hljs-built_in">addTable</span>(t1, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">displayTable</span>(t1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查找元素3的位置:\n&quot;</span>);<br>    add = <span class="hljs-built_in">selectTable</span>(t1, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, add);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;将元素3改为6:\n&quot;</span>);<br>    t1 = <span class="hljs-built_in">amendTable</span>(t1, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">displayTable</span>(t1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序运行结果为：</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">原顺序表：<br>1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<br>删除元素1:<br>2<span class="hljs-number"> 3 </span>4 5<br>在第2的位置插入元素5:<br>2<span class="hljs-number"> 5 </span>3<span class="hljs-number"> 4 </span>5<br>查找元素3的位置:<br>3<br>将元素3改为6:<br>2<span class="hljs-number"> 5 </span>6<span class="hljs-number"> 4 </span>5<br></code></pre></div></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><strong>链表的节点</strong></p><p>链表中每个数据的存储都由以下两部分组成：</p><p>数据元素本身，其所在的区域称为数据域；<br>指向直接后继元素的指针，所在的区域称为指针域；</p><p><strong>头节点，头指针和首元节点</strong></p><p>一个完整的链表需要由以下几部分构成：</p><p>头指针：一个普通的指针，它的特点是永远指向链表第一个节点的位置。很明显，头指针用于指明链表的位置，便于后期找到链表并使用表中的数据；</p><p>节点：链表中的节点又细分为头节点、首元节点和其他节点：</p><p>头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题；</p><p>首元节点：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；</p><p>其他节点：链表中其他的节点；</p><p>注意：链表中有头节点时，头指针指向头节点；反之，若链表中没有头节点，则头指针指向首元节点。</p><p>链表中每个节点的具体实现，需要使用 C 语言中的结构体，具体实现代码为：</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Link</span>&#123;</span><br>    <span class="hljs-keyword">char</span> elem; <span class="hljs-comment">//代表数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Link</span> * <span class="hljs-title">next</span>;</span> <span class="hljs-comment">//代表指针域，指向直接后继元素</span><br>&#125;link; <span class="hljs-comment">//link为节点名，每个节点都是一个 link 结构体</span><br></code></pre></div></td></tr></table></figure><p>提示，由于指针域中的指针要指向的也是一个节点，因此要声明为 Link 类型（这里要写成 struct Link* 的形式）。</p><p>链表的创建（初始化）</p><p>创建一个链表需要做如下工作：<br>声明一个头指针（如果有必要，可以声明一个头节点）；<br>创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系；</p><p>例如，创建一个存储 {1,2,3,4} 且无头节点的链表，C 语言实现代码如下：</p><figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso"><span class="hljs-keyword">link</span> * initLink() &#123;<br>    int i;<br>    <span class="hljs-keyword">link</span> * p = <span class="hljs-built_in">NULL</span>;<span class="hljs-comment">//创建头指针</span><br>    <span class="hljs-keyword">link</span> * temp = (<span class="hljs-keyword">link</span>*)malloc(sizeof(<span class="hljs-keyword">link</span>));<span class="hljs-comment">//创建首元节点</span><br>    <span class="hljs-comment">//首元节点先初始化</span><br>    temp-&gt;elem = <span class="hljs-number">1</span>;<br>    temp-&gt;next = <span class="hljs-built_in">NULL</span>;<br>    p = temp;<span class="hljs-comment">//头指针指向首元节点</span><br>    <span class="hljs-comment">//从第二个节点开始创建</span><br>    for (i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//创建一个新节点并初始化</span><br>        <span class="hljs-keyword">link</span> *a = (<span class="hljs-keyword">link</span>*)malloc(sizeof(<span class="hljs-keyword">link</span>));<br>        a-&gt;elem = i;<br>        a-&gt;next = <span class="hljs-built_in">NULL</span>;<br>        <span class="hljs-comment">//将temp节点与新建立的a节点建立逻辑关系</span><br>        temp-&gt;next = a;<br>        <span class="hljs-comment">//指针temp每次都指向新链表的最后一个节点，其实就是 a节点，这里写temp=a也对</span><br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//返回建立的节点，只返回头指针 p即可，通过头指针即可找到整个链表</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果想创建一个存储 {1,2,3,4} 且含头节点的链表，则 C 语言实现代码为：</p><figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl"><span class="hljs-keyword">link</span> * initLink()&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">link</span> * p=(<span class="hljs-keyword">link</span>*)malloc(sizeof(<span class="hljs-keyword">link</span>));<span class="hljs-regexp">//</span>创建一个头结点<br>    <span class="hljs-keyword">link</span> * temp=p;<span class="hljs-regexp">//</span>声明一个指针指向头结点，<br>    //生成链表<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-keyword">link</span> *a=(<span class="hljs-keyword">link</span>*)malloc(sizeof(<span class="hljs-keyword">link</span>));<br>        a-&gt;elem=i;<br>        a-&gt;<span class="hljs-keyword">next</span>=NULL;<br>        temp-&gt;<span class="hljs-keyword">next</span>=a;<br>        temp=temp-&gt;<span class="hljs-keyword">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>链表插入元素</p><p>同顺序表一样，向链表中增添元素，根据添加位置不同，可分为以下 3 种情况：<br>插入到链表的头部（头节点之后），作为首元节点；<br>插入到链表中间的某个位置；<br>插入到链表的最末端，作为链表中最后一个数据元素；</p><p>虽然新元素的插入位置不固定，但是链表插入元素的思想是固定的，只需做以下两步操作，即可将新元素插入到指定的位置：<br>将新结点的 next 指针指向插入位置后的结点；<br>将插入位置前结点的 next 指针指向插入结点；</p><p>链表插入元素的操作：</p><figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl">//p为原链表，elem表示新数据元素，add表示新元素要插入的位置<br><span class="hljs-keyword">link</span> * insertElem(<span class="hljs-keyword">link</span> * p, <span class="hljs-keyword">int</span> elem, <span class="hljs-keyword">int</span> add) &#123;<br>    <span class="hljs-keyword">link</span> * temp = p;<span class="hljs-regexp">//</span>创建临时结点temp<br>    <span class="hljs-keyword">link</span> * c = NULL;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    //首先找到要插入位置的上一个结点<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; add; i++) &#123;<br>        <span class="hljs-keyword">if</span> (temp == NULL) &#123;<br>            <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;插入位置无效\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>        temp = temp-&gt;<span class="hljs-keyword">next</span>;<br>    &#125;<br>    //创建插入结点c<br>    c = (<span class="hljs-keyword">link</span>*)malloc(sizeof(<span class="hljs-keyword">link</span>));<br>    c-&gt;elem = elem;<br>    //向链表中插入结点<br>    //链表插入元素的操作必须是先步骤 <span class="hljs-number">1</span>，再步骤 <span class="hljs-number">2</span>；反之，若先执行步骤 <span class="hljs-number">2</span>，会导致插入位置后续的部分链表丢失，无法再实现步骤 <span class="hljs-number">1</span>。<br>    c-&gt;<span class="hljs-keyword">next</span> = temp-&gt;<span class="hljs-keyword">next</span>;  <span class="hljs-regexp">//</span>①<br>    temp-&gt;<span class="hljs-keyword">next</span> = c;  <span class="hljs-regexp">//</span>②<br>    <span class="hljs-keyword">return</span>  p;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>提示，insertElem 函数中加入一个 if 语句，用于判断用户输入的插入位置是否有效。例如，在已存储 {1,2,3} 的链表中，用户要求在链表中第 100 个数据元素所在的位置插入新元素，显然用户操作无效，此时就会触发 if 语句。</p><p>链表删除元素</p><p>从链表中删除指定数据元素时，实则就是将存有该数据元素的节点从链表中摘除，同时对不再利用的存储空间要及时释放。因此，从链表中删除数据元素需要进行以下 2 步操作：</p><p>将结点从链表中摘下来;<br>手动释放掉结点，回收被结点占用的存储空间;</p><p>其中，从链表上摘除某节点的实现非常简单，只需找到该节点的直接前驱节点 temp，执行一行程序：</p><p><code>temp-&gt;next=temp-&gt;next-&gt;next;</code></p><p>因此，链表删除元素的 C 语言实现如下所示：</p><figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl">//p为原链表，add为要删除元素的值<br><span class="hljs-keyword">link</span> * delElem(<span class="hljs-keyword">link</span> * p, <span class="hljs-keyword">int</span> add) &#123;<br>    <span class="hljs-keyword">link</span> * temp = p;<br>    <span class="hljs-keyword">link</span> * del = NULL;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    //temp指向被删除结点的上一个结点<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; add; i++) &#123;<br>        temp = temp-&gt;<span class="hljs-keyword">next</span>;<br>    &#125;<br>    del = temp-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-regexp">//</span>单独设置一个指针指向被删除结点，以防丢失<br>    temp-&gt;<span class="hljs-keyword">next</span> = temp-&gt;<span class="hljs-keyword">next</span>-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-regexp">//</span>删除某个结点的方法就是更改前一个结点的指针域<br>    free(del);<span class="hljs-regexp">//</span>手动释放该结点，防止内存泄漏<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以看到，从链表上摘下的节点 del 最终通过 free 函数进行了手动释放。</p><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>静态链表存储数据，数据全部存储在数组中（和顺序表一样），但存储位置是随机的，数据之间”一对一”的逻辑关系通过一个整形变量（称为”游标”，和指针功能类似）维持（和链表类似）。</p><p>静态链表中的节点</p><p>静态链表存储数据元素也需要自定义数据类型，至少需要包含以下 2 部分信息：<br>数据域：用于存储数据元素的值；<br>游标：其实就是数组下标，表示直接后继元素所在数组中的位置；</p><p>因此，静态链表中节点的构成用 C 语言实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">int</span> cur;<span class="hljs-comment">//游标</span><br>&#125;component;<br></code></pre></div></td></tr></table></figure><p>备用链表</p><p>静态链表中，除了数据本身通过游标组成的链表外，还需要有一条连接各个空闲位置的链表，称为备用链表。</p><p>备用链表的作用是回收数组中未使用或之前使用过（目前未使用）的存储空间，留待后期使用。也就是说，静态链表使用数组申请的物理空间中，存有两个链表，一条连接数据，另一条连接数组中未使用的空间。<br>通常，备用链表的表头位于数组下标为 0（a[0]） 的位置，而数据链表的表头位于数组下标为 1（a[1]）的位置。</p><p>静态链表中设置备用链表的好处是，可以清楚地知道数组中是否有空闲位置，以便数据链表添加新数据时使用。比如，若静态链表中数组下标为 0 的位置上存有数据，则证明数组已满。</p><p>静态链表的实现<br>假设使用静态链表（数组长度为 6）存储 {1,2,3}，则需经历以下几个阶段。</p><p>在数据链表未初始化之前，数组中所有位置都处于空闲状态，因此都应被链接在备用链表上，当向静态链表中添加数据时，需提前从备用链表中摘除节点，以供新数据使用。</p><p>备用链表摘除节点最简单的方法是摘除 a[0] 的直接后继节点；同样，向备用链表中添加空闲节点也是添加作为 a[0] 新的直接后继节点。因为 a[0] 是备用链表的第一个节点，我们知道它的位置，操作它的直接后继节点相对容易，无需遍历备用链表，耗费的时间复杂度为 O(1)。</p><p>下面给出了创建一个不带头结点的静态链表的 C 语言实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxSize 6</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-keyword">int</span> cur;<br>&#125;component;<br><span class="hljs-comment">//将结构体数组中所有分量链接到备用链表中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reserveArr</span><span class="hljs-params">(component *array)</span></span>;<br><span class="hljs-comment">//初始化静态链表</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">initArr</span><span class="hljs-params">(component *array)</span></span>;<br><span class="hljs-comment">//输出函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">displayArr</span><span class="hljs-params">(component * array, <span class="hljs-keyword">int</span> body)</span></span>;<br><span class="hljs-comment">//从备用链表上摘下空闲节点的函数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mallocArr</span><span class="hljs-params">(component * array)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    component array[maxSize];<br>    <span class="hljs-keyword">int</span> body = <span class="hljs-built_in">initArr</span>(array);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;静态链表为：\n&quot;</span>);<br>    <span class="hljs-built_in">displayArr</span>(array, body);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//创建备用链表</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reserveArr</span><span class="hljs-params">(component *array)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; maxSize; i++) &#123;<br>        array[i].cur = i + <span class="hljs-number">1</span>;<span class="hljs-comment">//将每个数组分量链接到一起</span><br>        array[i].data = <span class="hljs-number">0</span>;<br>    &#125;<br>    array[maxSize - <span class="hljs-number">1</span>].cur = <span class="hljs-number">0</span>;<span class="hljs-comment">//链表最后一个结点的游标值为0</span><br>&#125;<br><span class="hljs-comment">//提取分配空间</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mallocArr</span><span class="hljs-params">(component * array)</span> </span>&#123;<br>    <span class="hljs-comment">//若备用链表非空，则返回分配的结点下标，否则返回 0（当分配最后一个结点时，该结点的游标值为 0）</span><br>    <span class="hljs-keyword">int</span> i = array[<span class="hljs-number">0</span>].cur;<br>    <span class="hljs-keyword">if</span> (array[<span class="hljs-number">0</span>].cur) &#123;<br>        array[<span class="hljs-number">0</span>].cur = array[i].cur;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-comment">//初始化静态链表</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">initArr</span><span class="hljs-params">(component *array)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> tempBody = <span class="hljs-number">0</span>, body = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">reserveArr</span>(array);<br>    body = <span class="hljs-built_in">mallocArr</span>(array);<br>    <span class="hljs-comment">//建立首元结点</span><br>    array[body].data = <span class="hljs-number">1</span>;<br>    array[body].cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//声明一个变量，把它当指针使，指向链表的最后的一个结点，当前和首元结点重合</span><br>    tempBody = body;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-built_in">mallocArr</span>(array); <span class="hljs-comment">//从备用链表中拿出空闲的分量</span><br>        array[j].data = i;      <span class="hljs-comment">//初始化新得到的空间结点</span><br>        array[tempBody].cur = j; <span class="hljs-comment">//将新得到的结点链接到数据链表的尾部</span><br>        tempBody = j;             <span class="hljs-comment">//将指向链表最后一个结点的指针后移</span><br>    &#125;<br>    array[tempBody].cur = <span class="hljs-number">0</span>;<span class="hljs-comment">//新的链表最后一个结点的指针设置为0</span><br>    <span class="hljs-keyword">return</span> body;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">displayArr</span><span class="hljs-params">(component * array, <span class="hljs-keyword">int</span> body)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> tempBody = body;<span class="hljs-comment">//tempBody准备做遍历使用</span><br>    <span class="hljs-keyword">while</span> (array[tempBody].cur) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d\n&quot;</span>, array[tempBody].data, array[tempBody].cur);<br>        tempBody = array[tempBody].cur;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d\n&quot;</span>, array[tempBody].data, array[tempBody].cur);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>代码输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">静态链表为：<br>1,2<br>2,3<br>3,0<br></code></pre></div></td></tr></table></figure><p>静态链表添加元素</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">//向链表中插入数据，body表示链表的头结点在数组中的位置，add表示插入元素的位置，num表示要插入的数据</span><br>void insert<span class="hljs-constructor">Arr(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">body</span>, <span class="hljs-params">int</span> <span class="hljs-params">add</span>, <span class="hljs-params">int</span> <span class="hljs-params">num</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> tempBody = body;<span class="hljs-comment">//tempBody做遍历结构体数组使用</span><br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, insert = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//找到要插入位置的上一个结点在数组中的位置</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; add; i++) &#123;<br>        tempBody = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur;<br>    &#125;<br>    insert = malloc<span class="hljs-constructor">Arr(<span class="hljs-params">array</span>)</span>;<span class="hljs-comment">//申请空间，准备插入</span><br>    <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">insert</span>]</span>.data = num;<br>    <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">insert</span>]</span>.cur = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur;<span class="hljs-comment">//新插入结点的游标等于其直接前驱结点的游标</span><br>    <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur = insert;<span class="hljs-comment">//直接前驱结点的游标等于新插入结点所在数组中的下标</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>静态链表删除元素</p><p>静态链表中删除指定元素，只需实现以下 2 步操作：</p><p>将存有目标元素的节点从数据链表中摘除；<br>将摘除节点添加到备用链表，以便下次再用；</p><p>比较特殊的是，对于无头结点的数据链表来说，如果需要删除头结点，则势必会导致数据链表的表头不再位于数组下标为 1 的位置，换句话说，删除头结点之后，原数据链表中第二个结点将作为整个链表新的首元结点。</p><p>若问题中涉及大量删除元素的操作，建议在建立静态链表之初创建一个带有头节点的静态链表，方便实现删除链表中第一个数据元素的操作。</p><p>如下是针对无头结点的数据链表，实现删除操作的 C 语言代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">//删除结点函数，num表示被删除结点中数据域存放的数据，函数返回新数据链表的表头位置</span><br><span class="hljs-built_in">int</span> delet<span class="hljs-constructor">Arr(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">body</span>, <span class="hljs-params">int</span> <span class="hljs-params">num</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> tempBody = body;<br>    <span class="hljs-built_in">int</span> del = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> newbody = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//找到被删除结点的位置</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.data != num) &#123;<br>        tempBody = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur;<br>        <span class="hljs-comment">//当tempBody为0时，表示链表遍历结束，说明链表中没有存储该数据的结点</span><br>        <span class="hljs-keyword">if</span> (tempBody<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>            printf(<span class="hljs-string">&quot;链表中没有此数据&quot;</span>);<br>            return;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//运行到此，证明有该结点</span><br>    del = tempBody;<br>    tempBody = body;<br>    <span class="hljs-comment">//删除首元结点，需要特殊考虑</span><br>    <span class="hljs-keyword">if</span> (del<span class="hljs-operator"> == </span>body) &#123;<br>        newbody = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">del</span>]</span>.cur;<br>        free<span class="hljs-constructor">Arr(<span class="hljs-params">array</span>, <span class="hljs-params">del</span>)</span>;<br>        return newbody;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//找到该结点的上一个结点，做删除操作</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur != del) &#123;<br>            tempBody = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur;<br>        &#125;<br>        <span class="hljs-comment">//将被删除结点的游标直接给被删除结点的上一个结点</span><br>        <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">del</span>]</span>.cur;<br>        <span class="hljs-comment">//回收被摘除节点的空间</span><br>        free<span class="hljs-constructor">Arr(<span class="hljs-params">array</span>, <span class="hljs-params">del</span>)</span>;<br>        return body;<br>    &#125;  <br>&#125;<br></code></pre></div></td></tr></table></figure><p>静态链表中更改数据</p><p>更改静态链表中的数据，只需找到目标元素所在的节点，直接更改节点中的数据域即可。</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">实现此操作的 C 语言代码如下：<br><span class="hljs-comment">//在以body作为头结点的链表中将数据域为oldElem的结点，数据域改为newElem</span><br>void amend<span class="hljs-constructor">Elem(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">body</span>, <span class="hljs-params">int</span> <span class="hljs-params">oldElem</span>, <span class="hljs-params">int</span> <span class="hljs-params">newElem</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> add = select<span class="hljs-constructor">Num(<span class="hljs-params">array</span>, <span class="hljs-params">body</span>, <span class="hljs-params">oldElem</span>)</span>;<br>    <span class="hljs-keyword">if</span> (add<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>) &#123;<br>        printf(<span class="hljs-string">&quot;无更改元素&quot;</span>);<br>        return;<br>    &#125;<br>    <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">add</span>]</span>.data = newElem;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>静态链表查找元素</p><p>静态链表查找指定元素，由于我们只知道静态链表第一个元素所在数组中的位置，因此只能通过逐个遍历静态链表的方式，查找存有指定数据元素的节点。</p><figure class="highlight d"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs d">静态链表查找指定数据元素的 C 语言实现代码如下：<br><span class="hljs-comment">//在以body作为头结点的链表中查找数据域为elem的结点在数组中的位置</span><br><span class="hljs-keyword">int</span> selectNum(component * array, <span class="hljs-keyword">int</span> <span class="hljs-keyword">body</span>, <span class="hljs-keyword">int</span> num) &#123;<br>    <span class="hljs-comment">//当游标值为0时，表示链表结束</span><br>    <span class="hljs-keyword">while</span> (array[<span class="hljs-keyword">body</span>].cur != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (array[<span class="hljs-keyword">body</span>].data == num) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">body</span>;<br>        &#125;<br>        <span class="hljs-keyword">body</span> = array[<span class="hljs-keyword">body</span>].cur;<br>    &#125;<br>    <span class="hljs-comment">//判断最后一个结点是否符合要求</span><br>    <span class="hljs-keyword">if</span> (array[<span class="hljs-keyword">body</span>].data == num) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">body</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//返回-1，表示在链表中没有找到该元素</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>总结</p><p>这里给出以上对静态链表做 “增删查改” 操作的完整实现代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;stdio.h&gt;<br>#define maxSize <span class="hljs-number">7</span><br>typedef <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-built_in">int</span> data;<br>    <span class="hljs-built_in">int</span> cur;<br>&#125;component;<br><span class="hljs-comment">//将结构体数组中所有分量链接到备用链表中</span><br>void reserve<span class="hljs-constructor">Arr(<span class="hljs-params">component</span> <span class="hljs-operator">*</span><span class="hljs-params">array</span>)</span>;<br><span class="hljs-comment">//初始化静态链表</span><br><span class="hljs-built_in">int</span> init<span class="hljs-constructor">Arr(<span class="hljs-params">component</span> <span class="hljs-operator">*</span><span class="hljs-params">array</span>)</span>;<br><span class="hljs-comment">//向链表中插入数据，body表示链表的头结点在数组中的位置，add表示插入元素的位置，num表示要插入的数据</span><br>void insert<span class="hljs-constructor">Arr(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">body</span>, <span class="hljs-params">int</span> <span class="hljs-params">add</span>, <span class="hljs-params">int</span> <span class="hljs-params">num</span>)</span>;<br><span class="hljs-comment">//删除链表中存有num的结点,返回新数据链表中第一个节点所在的位置</span><br><span class="hljs-built_in">int</span> delet<span class="hljs-constructor">Arr(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">body</span>, <span class="hljs-params">int</span> <span class="hljs-params">num</span>)</span>;<br><span class="hljs-comment">//查找存储有num的结点在数组的位置</span><br><span class="hljs-built_in">int</span> select<span class="hljs-constructor">Num(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">body</span>, <span class="hljs-params">int</span> <span class="hljs-params">num</span>)</span>;<br><span class="hljs-comment">//将链表中的字符oldElem改为newElem</span><br>void amend<span class="hljs-constructor">Elem(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">body</span>, <span class="hljs-params">int</span> <span class="hljs-params">oldElem</span>, <span class="hljs-params">int</span> <span class="hljs-params">newElem</span>)</span>;<br><span class="hljs-comment">//输出函数</span><br>void display<span class="hljs-constructor">Arr(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">body</span>)</span>;<br><span class="hljs-comment">//从备用链表中摘除空闲节点的实现函数</span><br><span class="hljs-built_in">int</span> malloc<span class="hljs-constructor">Arr(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>)</span>;<br><span class="hljs-comment">//将摘除下来的节点链接到备用链表上</span><br>void free<span class="hljs-constructor">Arr(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span>;<br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span> &#123;<br>    component <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">maxSize</span>]</span>;<br>    <span class="hljs-built_in">int</span> body = init<span class="hljs-constructor">Arr(<span class="hljs-params">array</span>)</span>;<br>    <span class="hljs-built_in">int</span> selectAdd;<br>    printf(<span class="hljs-string">&quot;静态链表为：\n&quot;</span>);<br>    display<span class="hljs-constructor">Arr(<span class="hljs-params">array</span>, <span class="hljs-params">body</span>)</span>;<br>    printf(<span class="hljs-string">&quot;在第3的位置上插入元素4:\n&quot;</span>);<br>    insert<span class="hljs-constructor">Arr(<span class="hljs-params">array</span>, <span class="hljs-params">body</span>, 3, 4)</span>;<br>    display<span class="hljs-constructor">Arr(<span class="hljs-params">array</span>, <span class="hljs-params">body</span>)</span>;<br>    printf(<span class="hljs-string">&quot;删除数据域为1的结点:\n&quot;</span>);<br>    body = delet<span class="hljs-constructor">Arr(<span class="hljs-params">array</span>, <span class="hljs-params">body</span>, 1)</span>;<br>    display<span class="hljs-constructor">Arr(<span class="hljs-params">array</span>, <span class="hljs-params">body</span>)</span>;<br>    printf(<span class="hljs-string">&quot;查找数据域为4的结点的位置:\n&quot;</span>);<br>    selectAdd = select<span class="hljs-constructor">Num(<span class="hljs-params">array</span>, <span class="hljs-params">body</span>, 4)</span>;<br>    printf(<span class="hljs-string">&quot;%d\n&quot;</span>, selectAdd);<br>    printf(<span class="hljs-string">&quot;将结点数据域为4改为5:\n&quot;</span>);<br>    amend<span class="hljs-constructor">Elem(<span class="hljs-params">array</span>, <span class="hljs-params">body</span>, 4, 5)</span>;<br>    display<span class="hljs-constructor">Arr(<span class="hljs-params">array</span>, <span class="hljs-params">body</span>)</span>;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//创建备用链表</span><br>void reserve<span class="hljs-constructor">Arr(<span class="hljs-params">component</span> <span class="hljs-operator">*</span><span class="hljs-params">array</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; maxSize; i++) &#123;<br>        <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.cur = i + <span class="hljs-number">1</span>;<span class="hljs-comment">//将每个数组分量链接到一起</span><br>    &#125;<br>    <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">maxSize</span> - <span class="hljs-number">1</span>]</span>.cur = <span class="hljs-number">0</span>;<span class="hljs-comment">//链表最后一个结点的游标值为0</span><br>&#125;<br><span class="hljs-comment">//初始化静态链表</span><br><span class="hljs-built_in">int</span> init<span class="hljs-constructor">Arr(<span class="hljs-params">component</span> <span class="hljs-operator">*</span><span class="hljs-params">array</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> tempBody = <span class="hljs-number">0</span>, body = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>    reserve<span class="hljs-constructor">Arr(<span class="hljs-params">array</span>)</span>;<br>    body = malloc<span class="hljs-constructor">Arr(<span class="hljs-params">array</span>)</span>;<br>    <span class="hljs-comment">//建立首元结点</span><br>    <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">body</span>]</span>.data = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">body</span>]</span>.cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//声明一个变量，把它当指针使，指向链表的最后的一个结点，当前和首元结点重合</span><br>    tempBody = body;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-built_in">int</span> j = malloc<span class="hljs-constructor">Arr(<span class="hljs-params">array</span>)</span>; <span class="hljs-comment">//从备用链表中拿出空闲的分量</span><br>        <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.data = i;      <span class="hljs-comment">//初始化新得到的空间结点</span><br>        <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur = j; <span class="hljs-comment">//将新得到的结点链接到数据链表的尾部</span><br>        tempBody = j;             <span class="hljs-comment">//将指向链表最后一个结点的指针后移</span><br>    &#125;<br>    <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur = <span class="hljs-number">0</span>;<span class="hljs-comment">//新的链表最后一个结点的指针设置为0</span><br>    return body;<br>&#125;<br><span class="hljs-comment">//向链表中插入数据，body表示链表的头结点在数组中的位置，add表示插入元素的位置，num表示要插入的数据</span><br>void insert<span class="hljs-constructor">Arr(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">body</span>, <span class="hljs-params">int</span> <span class="hljs-params">add</span>, <span class="hljs-params">int</span> <span class="hljs-params">num</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> tempBody = body;<span class="hljs-comment">//tempBody做遍历结构体数组使用</span><br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, insert = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//找到要插入位置的上一个结点在数组中的位置</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; add; i++) &#123;<br>        tempBody = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur;<br>    &#125;<br>    insert = malloc<span class="hljs-constructor">Arr(<span class="hljs-params">array</span>)</span>;<span class="hljs-comment">//申请空间，准备插入</span><br>    <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">insert</span>]</span>.data = num;<br>    <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">insert</span>]</span>.cur = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur;<span class="hljs-comment">//新插入结点的游标等于其直接前驱结点的游标</span><br>    <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur = insert;<span class="hljs-comment">//直接前驱结点的游标等于新插入结点所在数组中的下标</span><br>&#125;<br><span class="hljs-comment">//删除结点函数，num表示被删除结点中数据域存放的数据</span><br><span class="hljs-built_in">int</span> delet<span class="hljs-constructor">Arr(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">body</span>, <span class="hljs-params">int</span> <span class="hljs-params">num</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> tempBody = body;<br>    <span class="hljs-built_in">int</span> del = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> newbody = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//找到被删除结点的位置</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.data != num) &#123;<br>        tempBody = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur;<br>        <span class="hljs-comment">//当tempBody为0时，表示链表遍历结束，说明链表中没有存储该数据的结点</span><br>        <span class="hljs-keyword">if</span> (tempBody<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>            printf(<span class="hljs-string">&quot;链表中没有此数据&quot;</span>);<br>            return;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//运行到此，证明有该结点</span><br>    del = tempBody;<br>    tempBody = body;<br>    <span class="hljs-comment">//删除首元结点，需要特殊考虑</span><br>    <span class="hljs-keyword">if</span> (del<span class="hljs-operator"> == </span>body) &#123;<br>        newbody = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">del</span>]</span>.cur;<br>        free<span class="hljs-constructor">Arr(<span class="hljs-params">array</span>, <span class="hljs-params">del</span>)</span>;<br>        return newbody;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//找到该结点的上一个结点，做删除操作</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur != del) &#123;<br>            tempBody = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur;<br>        &#125;<br>        <span class="hljs-comment">//将被删除结点的游标直接给被删除结点的上一个结点</span><br>        <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">del</span>]</span>.cur;<br>        <span class="hljs-comment">//回收被摘除节点的空间</span><br>        free<span class="hljs-constructor">Arr(<span class="hljs-params">array</span>, <span class="hljs-params">del</span>)</span>;<br>        return body;<br>    &#125;  <br>&#125;<br><span class="hljs-comment">//在以body作为头结点的链表中查找数据域为elem的结点在数组中的位置</span><br><span class="hljs-built_in">int</span> select<span class="hljs-constructor">Num(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">body</span>, <span class="hljs-params">int</span> <span class="hljs-params">num</span>)</span> &#123;<br>    <span class="hljs-comment">//当游标值为0时，表示链表结束</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">body</span>]</span>.cur != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">body</span>]</span>.data<span class="hljs-operator"> == </span>num) &#123;<br>            return body;<br>        &#125;<br>        body = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">body</span>]</span>.cur;<br>    &#125;<br>    <span class="hljs-comment">//判断最后一个结点是否符合要求</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">body</span>]</span>.data<span class="hljs-operator"> == </span>num) &#123;<br>        return body;<br>    &#125;<br>    return -<span class="hljs-number">1</span>;<span class="hljs-comment">//返回-1，表示在链表中没有找到该元素</span><br>&#125;<br><span class="hljs-comment">//在以body作为头结点的链表中将数据域为oldElem的结点，数据域改为newElem</span><br>void amend<span class="hljs-constructor">Elem(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">body</span>, <span class="hljs-params">int</span> <span class="hljs-params">oldElem</span>, <span class="hljs-params">int</span> <span class="hljs-params">newElem</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> add = select<span class="hljs-constructor">Num(<span class="hljs-params">array</span>, <span class="hljs-params">body</span>, <span class="hljs-params">oldElem</span>)</span>;<br>    <span class="hljs-keyword">if</span> (add<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>) &#123;<br>        printf(<span class="hljs-string">&quot;无更改元素&quot;</span>);<br>        return;<br>    &#125;<br>    <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">add</span>]</span>.data = newElem;<br>&#125;<br>void display<span class="hljs-constructor">Arr(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">body</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> tempBody = body;<span class="hljs-comment">//tempBody准备做遍历使用</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur) &#123;<br>        printf(<span class="hljs-string">&quot;%d,%d &quot;</span>, <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.data, <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur);<br>        tempBody = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur;<br>    &#125;<br>    printf(<span class="hljs-string">&quot;%d,%d\n&quot;</span>, <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.data, <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">tempBody</span>]</span>.cur);<br>&#125;<br><span class="hljs-comment">//提取分配空间</span><br><span class="hljs-built_in">int</span> malloc<span class="hljs-constructor">Arr(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>)</span> &#123;<br>    <span class="hljs-comment">//若备用链表非空，则返回分配的结点下标，否则返回0（当分配最后一个结点时，该结点的游标值为0）</span><br>    <span class="hljs-built_in">int</span> i = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.cur;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.cur) &#123;<br>        <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.cur = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.cur;<br>    &#125;<br>    return i;<br>&#125;<br><span class="hljs-comment">//备用链表回收空间的函数，其中array为存储数据的数组，k表示未使用节点所在数组的下标</span><br>void free<span class="hljs-constructor">Arr(<span class="hljs-params">component</span> <span class="hljs-operator">*</span> <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;<br>    <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>.cur = <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.cur;<br>    <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.cur = k;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序运行结果为：</p><figure class="highlight dns"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dns">静态链表为：<br><span class="hljs-number">1,2 2,3</span> <span class="hljs-number">3</span>,<span class="hljs-number">0</span><br>在第<span class="hljs-number">3</span>的位置上插入元素<span class="hljs-number">4</span>:<br><span class="hljs-number">1,2 2,3</span> <span class="hljs-number">3,4 4,0</span><br>删除数据域为<span class="hljs-number">1</span>的结点:<br><span class="hljs-number">2,3 3,4</span> <span class="hljs-number">4</span>,<span class="hljs-number">0</span><br>查找数据域为<span class="hljs-number">4</span>的结点的位置:<br><span class="hljs-number">4</span><br>将结点数据域为<span class="hljs-number">4</span>改为<span class="hljs-number">5</span>:<br><span class="hljs-number">2,3 3,4</span> <span class="hljs-number">5</span>,<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h3 id="循环链表-约瑟夫环-的建立及C语言实现"><a href="#循环链表-约瑟夫环-的建立及C语言实现" class="headerlink" title="循环链表(约瑟夫环)的建立及C语言实现"></a>循环链表(约瑟夫环)的建立及C语言实现</h3><p>循环链表实现约瑟夫环</p><p>约瑟夫环问题，是一个经典的循环链表问题，题意是：已知 n 个人（分别用编号 1，2，3，…，n 表示）围坐在一张圆桌周围，从编号为 k 的人开始顺时针报数，数到 m 的那个人出列；他的下一个人又从 1 开始，还是顺时针开始报数，数到 m 的那个人又出列；依次重复下去，直到圆桌上剩余一个人。</p><p>如图 2 所示，假设此时圆周周围有 5 个人，要求从编号为 3 的人开始顺时针数数，数到 2 的那个人出列：</p><p><a href="http://data.biancheng.net/uploads/allimg/170718/2-1FGQ54403413.png">http://data.biancheng.net/uploads/allimg/170718/2-1FGQ54403413.png</a></p><p>图 2 循环链表实现约瑟夫环</p><p>出列顺序依次为：</p><p>编号为 3 的人开始数 1，然后 4 数 2，所以 4 先出列；<br>4 出列后，从 5 开始数 1，1 数 2，所以 1 出列；<br>1 出列后，从 2 开始数 1，3 数 2，所以 3 出列；<br>3 出列后，从 5 开始数 1，2 数 2，所以 2 出列；<br>最后只剩下 5 自己，所以 5 胜出。</p><p>约瑟夫环问题有多种变形，比如顺时针转改为逆时针等，虽然问题的细节有多种变数，但解决问题的中心思想是一样的，即使用循环链表。</p><p>通过以上的分析，我们可以尝试编写 C 语言代码，完整代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> number;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> * <span class="hljs-title">next</span>;</span><br>&#125;person;<br><span class="hljs-function">person * <span class="hljs-title">initLink</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    person * head = <span class="hljs-literal">NULL</span>, *cyclic = <span class="hljs-literal">NULL</span>;<br>    head = (person*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(person));<br>    head-&gt;number = <span class="hljs-number">1</span>;<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    cyclic = head;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        person * body = (person*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(person));<br>        body-&gt;number = i;<br>        body-&gt;next = <span class="hljs-literal">NULL</span>;<br>        cyclic-&gt;next = body;<br>        cyclic = cyclic-&gt;next;<br>    &#125;<br>    cyclic-&gt;next = head;<span class="hljs-comment">//首尾相连</span><br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findAndKillK</span><span class="hljs-params">(person * head, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    person * p = <span class="hljs-literal">NULL</span>;<br>    person * tail = head;<br>    <span class="hljs-comment">//找到链表第一个结点的上一个结点，为删除操作做准备</span><br>    <span class="hljs-keyword">while</span> (tail-&gt;next != head) &#123;<br>        tail = tail-&gt;next;<br>    &#125;<br>    p = head;<br>    <span class="hljs-comment">//找到编号为k的人</span><br>    <span class="hljs-keyword">while</span> (p-&gt;number != k) &#123;<br>        tail = p;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//从编号为k的人开始，只有符合p-&gt;next==p时，说明链表中除了p结点，所有编号都出列了，</span><br>    <span class="hljs-keyword">while</span> (p-&gt;next != p) &#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//找到从p报数1开始，报m的人，并且还要知道数m-1de人的位置tail，方便做删除操作。</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            tail = p;<br>            p = p-&gt;next;<br>        &#125;<br>        tail-&gt;next = p-&gt;next;<span class="hljs-comment">//从链表上将p结点摘下来</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;出列人的编号为:%d\n&quot;</span>, p-&gt;number);<br>        <span class="hljs-built_in">free</span>(p);<br>        p = tail-&gt;next;<span class="hljs-comment">//继续使用p指针指向出列编号的下一个编号，游戏继续</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;出列人的编号为:%d\n&quot;</span>, p-&gt;number);<br>    <span class="hljs-built_in">free</span>(p);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>, m = <span class="hljs-number">0</span>;<br>    person * head = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入圆桌上的人数:&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    head = <span class="hljs-built_in">initLink</span>(n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;从第几个人开始报数(k&gt;1且k&lt;%d)：&quot;</span>, n);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;数到几的人出列：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);<br>    <span class="hljs-built_in">findAndKillK</span>(head, k, m);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出结果：</p><p>输入圆桌上的人数:5<br>从第几个人开始报数(k&gt;1且k&lt;5)：3<br>数到几的人出列：2<br>出列人的编号为:4<br>出列人的编号为:1<br>出列人的编号为:3<br>出列人的编号为:2<br>出列人的编号为:5</p><p>最后出列的人，即为胜利者。当然，你也可以改进程序，令查找出最后一个人时，输出此人胜利的信息。</p><p>总结</p><p>循环链表和动态链表唯一不同在于它的首尾连接，这也注定了在使用循环链表时，附带最多的操作就是遍历链表。</p><p>在遍历的过程中，尤其要注意循环链表虽然首尾相连，但并不表示该链表没有第一个节点和最后一个结点。所以，不要随意改变头指针的指向。</p><h3 id="双向链表及其创建"><a href="#双向链表及其创建" class="headerlink" title="双向链表及其创建"></a>双向链表及其创建</h3><p>双向链表中各节点包含以下 3 部分信息：</p><p>指针域：用于指向当前节点的直接前驱节点；<br>数据域：用于存储数据元素；<br>指针域：用于指向当前节点的直接后继节点。</p><p>双链表的节点结构用 C 语言实现为：</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">typedef <span class="hljs-keyword">struct</span> <span class="hljs-type">line</span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">line</span> * prior; <span class="hljs-comment">//指向直接前趋</span><br>    int data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">line</span> * next; <span class="hljs-comment">//指向直接后继</span><br>&#125;<span class="hljs-keyword">line</span>;<br></code></pre></div></td></tr></table></figure><p>双向链表的创建</p><p>同单链表相比，双链表仅是各节点多了一个用于指向直接前驱的指针域。因此，我们可以在单链表的基础轻松实现对双链表的创建。</p><p>和创建单链表不同的是，创建双向链表的过程中，每一个新节点都要和前驱节点之间建立两次链接，分别是：</p><p>将新节点的 prior 指针指向直接前驱节点；<br>将直接前驱节点的 next 指针指向新节点；</p><p>这里给出创建双向链表的 C 语言实现代码：</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function">line* <span class="hljs-title">initLine</span><span class="hljs-params">(line * head)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    line * list = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//创建一个首元节点，链表的头指针为head</span><br>    head = (line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(line));<br>    <span class="hljs-comment">//对节点进行初始化</span><br>    head-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;data = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//声明一个指向首元节点的指针，方便后期向链表中添加新创建的节点</span><br>    list = head;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//创建新的节点并初始化</span><br>        line * body = (line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(line));<br>        body-&gt;prior = <span class="hljs-literal">NULL</span>;<br>        body-&gt;next = <span class="hljs-literal">NULL</span>;<br>        body-&gt;data = i;<br>        <span class="hljs-comment">//新节点与链表最后一个节点建立关系</span><br>        list-&gt;next = body;<br>        body-&gt;prior = list;<br>        <span class="hljs-comment">//list永远指向链表中最后一个节点</span><br>        list = list-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//返回新创建的链表</span><br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>双向链表添加节点</p><p>根据数据添加到双向链表中的位置不同，可细分为以下 3 种情况：</p><ol><li>添加至表头<br>将新数据元素添加到表头，只需要将该元素与表头元素建立双层逻辑关系即可。</li></ol><p>换句话说，假设新元素节点为 temp，表头节点为 head，则需要做以下 2 步操作即可：<br>temp-&gt;next=head; head-&gt;prior=temp;<br>将 head 移至 temp，重新指向新的表头；</p><ol start="2"><li>添加至表的中间位置</li></ol><p>同单链表添加数据类似，双向链表中间位置添加数据需要经过以下 2 个步骤：</p><p>新节点先与其直接后继节点建立双层逻辑关系；<br>新节点的直接前驱节点与之建立双层逻辑关系；</p><ol start="3"><li>添加至表尾</li></ol><p>与添加到表头是一个道理，实现过程如下：</p><p>找到双链表中最后一个节点；<br>让新节点与最后一个节点进行双层逻辑关系；</p><p>参考代码如下：</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl"><span class="hljs-comment">//data 为要添加的新数据，add 为添加到链表中的位置</span><br>line * insertLine(line * head, int <span class="hljs-keyword">data</span>, int add) &#123;<br>    <span class="hljs-comment">//新建数据域为data的结点</span><br>    line * temp = (line*)malloc(sizeof(line));<br>    <span class="hljs-function"><span class="hljs-title">temp</span>-&gt;</span><span class="hljs-keyword">data</span> = <span class="hljs-keyword">data</span>;<br>    <span class="hljs-function"><span class="hljs-title">temp</span>-&gt;</span>prior = NULL;<br>    <span class="hljs-function"><span class="hljs-title">temp</span>-&gt;</span>next = NULL;<br>    <span class="hljs-comment">//插入到链表头，要特殊考虑</span><br>    <span class="hljs-keyword">if</span> (add == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-function"><span class="hljs-title">temp</span>-&gt;</span>next = head;<br>        <span class="hljs-function"><span class="hljs-title">head</span>-&gt;</span>prior = temp;<br>        head = temp;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        int i = <span class="hljs-number">0</span>;<br>        line * body = head;<br>        <span class="hljs-comment">//找到要插入位置的前一个结点</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; add - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-function"><span class="hljs-title">body</span> = body-&gt;</span>next;<br>            <span class="hljs-keyword">if</span> (body == NULL) &#123;<br>                printf(<span class="hljs-string">&quot;插入位置有误\n&quot;</span>);<br>                break;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (body) &#123;<br>            <span class="hljs-comment">//判断条件为真，说明插入位置为链表尾</span><br>            <span class="hljs-function"><span class="hljs-title">if</span> (body-&gt;</span>next == NULL) &#123;<br>                <span class="hljs-function"><span class="hljs-title">body</span>-&gt;</span>next = temp;<br>                <span class="hljs-function"><span class="hljs-title">temp</span>-&gt;</span>prior = body;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-function"><span class="hljs-title">body</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>prior = temp;<br>                <span class="hljs-function"><span class="hljs-title">temp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = body-&gt;</span>next;<br>                <span class="hljs-function"><span class="hljs-title">body</span>-&gt;</span>next = temp;<br>                <span class="hljs-function"><span class="hljs-title">temp</span>-&gt;</span>prior = body;<br>            &#125;<br>        &#125;<br>    &#125;<br>    return head;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>双向链表删除节点</p><p>双链表删除结点时，只需遍历链表找到要删除的结点，然后将该节点从表中摘除即可。</p><p>双向链表删除节点的 C 语言实现代码如下：</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl"><span class="hljs-comment">//删除结点的函数，data为要删除结点的数据域的值</span><br>line * delLine(line * head, int <span class="hljs-keyword">data</span>) &#123;<br>    line * temp = head;<br>    <span class="hljs-comment">//遍历链表</span><br>    <span class="hljs-keyword">while</span> (temp) &#123;<br>        <span class="hljs-comment">//判断当前结点中数据域和data是否相等，若相等，摘除该结点</span><br>        <span class="hljs-function"><span class="hljs-title">if</span> (temp-&gt;</span><span class="hljs-keyword">data</span> == <span class="hljs-keyword">data</span>) &#123;<br>            <span class="hljs-function"><span class="hljs-title">temp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prior</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = temp-&gt;</span>next;<br>            <span class="hljs-function"><span class="hljs-title">temp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prior</span> = temp-&gt;</span>prior;<br>            free(temp);<br>            return head;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">temp</span> = temp-&gt;</span>next;<br>    &#125;<br>    printf(<span class="hljs-string">&quot;链表中无该数据元素\n&quot;</span>);<br>    return head;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>双向链表更改节点</p><p>更改双链表中指定结点数据域的操作是在查找的基础上完成的。实现过程是：通过遍历找到存储有该数据元素的结点，直接更改其数据域即可。</p><p>实现此操作的 C 语言实现代码如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">//更新函数，其中，<span class="hljs-keyword">add</span> 表示更改结点在双链表中的位置，newElem 为新数据的值<br><span class="hljs-type">line</span> *amendElem(<span class="hljs-type">line</span> * p, <span class="hljs-type">int</span> <span class="hljs-keyword">add</span>, <span class="hljs-type">int</span> newElem) &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">line</span> * <span class="hljs-keyword">temp</span> = p;<br>    //遍历到被删除结点<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-keyword">add</span>; i++) &#123;<br>        <span class="hljs-keyword">temp</span> = <span class="hljs-keyword">temp</span>-&gt;next;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">temp</span> == <span class="hljs-keyword">NULL</span>) &#123;<br>            printf(&quot;更改位置有误！\n&quot;);<br>            break;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">temp</span>) &#123;<br>        <span class="hljs-keyword">temp</span>-&gt;data = newElem;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>双向链表查找节点</p><p>通常，双向链表同单链表一样，都仅有一个头指针。因此，双链表查找指定元素的实现同单链表类似，都是从表头依次遍历表中元素。</p><p>C 语言实现代码为：</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">//head为原双链表，elem表示被查找元素</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectElem</span><span class="hljs-params">(line * head, <span class="hljs-keyword">int</span> elem)</span> </span>&#123;<br>    <span class="hljs-comment">//新建一个指针t，初始化为头指针 head</span><br>    line * t = head;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (t) &#123;<br>        <span class="hljs-keyword">if</span> (t-&gt;data == elem) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        i++;<br>        t = t-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//程序执行至此处，表示查找失败</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>总结</p><p>这里给出双链表中对数据进行 “增删查改” 操作的完整实现代码：</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span> * <span class="hljs-title">prior</span>;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span> * <span class="hljs-title">next</span>;</span><br>&#125;line;<br><span class="hljs-comment">//双链表的创建</span><br><span class="hljs-function">line* <span class="hljs-title">initLine</span><span class="hljs-params">(line * head)</span></span>;<br><span class="hljs-comment">//双链表插入元素，add表示插入位置</span><br><span class="hljs-function">line * <span class="hljs-title">insertLine</span><span class="hljs-params">(line * head, <span class="hljs-keyword">int</span> data, <span class="hljs-keyword">int</span> add)</span></span>;<br><span class="hljs-comment">//双链表删除指定元素</span><br><span class="hljs-function">line * <span class="hljs-title">delLine</span><span class="hljs-params">(line * head, <span class="hljs-keyword">int</span> data)</span></span>;<br><span class="hljs-comment">//双链表中查找指定元素</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectElem</span><span class="hljs-params">(line * head, <span class="hljs-keyword">int</span> elem)</span></span>;<br><span class="hljs-comment">//双链表中更改指定位置节点中存储的数据，add表示更改位置</span><br><span class="hljs-function">line *<span class="hljs-title">amendElem</span><span class="hljs-params">(line * p, <span class="hljs-keyword">int</span> add, <span class="hljs-keyword">int</span> newElem)</span></span>;<br><span class="hljs-comment">//输出双链表的实现函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(line * head)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    line * head = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//创建双链表</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;初始链表为：\n&quot;</span>);<br>    head = <span class="hljs-built_in">initLine</span>(head);<br>    <span class="hljs-built_in">display</span>(head);<br>    <span class="hljs-comment">//在表中第 3 的位置插入元素 7</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;在表中第 3 的位置插入新元素 7：\n&quot;</span>);<br>    head = <span class="hljs-built_in">insertLine</span>(head, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">display</span>(head);<br>    <span class="hljs-comment">//表中删除元素 2</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除元素 2：\n&quot;</span>);<br>    head = <span class="hljs-built_in">delLine</span>(head, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">display</span>(head);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;元素 3 的位置是：%d\n&quot;</span>, <span class="hljs-built_in">selectElem</span>(head, <span class="hljs-number">3</span>));<br>    <span class="hljs-comment">//表中第 3 个节点中的数据改为存储 6</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;将第 3 个节点存储的数据改为 6：\n&quot;</span>);<br>    head = <span class="hljs-built_in">amendElem</span>(head, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">display</span>(head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">line* <span class="hljs-title">initLine</span><span class="hljs-params">(line * head)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    line * list = <span class="hljs-literal">NULL</span>;<br>    head = (line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(line));<br>    head-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;data = <span class="hljs-number">1</span>;<br>    list = head;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>        line * body = (line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(line));<br>        body-&gt;prior = <span class="hljs-literal">NULL</span>;<br>        body-&gt;next = <span class="hljs-literal">NULL</span>;<br>        body-&gt;data = i;<br>        list-&gt;next = body;<br>        body-&gt;prior = list;<br>        list = list-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-function">line * <span class="hljs-title">insertLine</span><span class="hljs-params">(line * head, <span class="hljs-keyword">int</span> data, <span class="hljs-keyword">int</span> add)</span> </span>&#123;<br>    <span class="hljs-comment">//新建数据域为data的结点</span><br>    line * temp = (line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(line));<br>    temp-&gt;data = data;<br>    temp-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//插入到链表头，要特殊考虑</span><br>    <span class="hljs-keyword">if</span> (add == <span class="hljs-number">1</span>) &#123;<br>        temp-&gt;next = head;<br>        head-&gt;prior = temp;<br>        head = temp;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        line * body = head;<br>        <span class="hljs-comment">//找到要插入位置的前一个结点</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; add - <span class="hljs-number">1</span>; i++) &#123;<br>            body = body-&gt;next;<br>            <span class="hljs-keyword">if</span> (body == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置有误\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (body) &#123;<br>            <span class="hljs-comment">//判断条件为真，说明插入位置为链表尾</span><br>            <span class="hljs-keyword">if</span> (body-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>                body-&gt;next = temp;<br>                temp-&gt;prior = body;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                body-&gt;next-&gt;prior = temp;<br>                temp-&gt;next = body-&gt;next;<br>                body-&gt;next = temp;<br>                temp-&gt;prior = body;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-function">line * <span class="hljs-title">delLine</span><span class="hljs-params">(line * head, <span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>    line * temp = head;<br>    <span class="hljs-comment">//遍历链表</span><br>    <span class="hljs-keyword">while</span> (temp) &#123;<br>        <span class="hljs-comment">//判断当前结点中数据域和data是否相等，若相等，摘除该结点</span><br>        <span class="hljs-keyword">if</span> (temp-&gt;data == data) &#123;<br>            temp-&gt;prior-&gt;next = temp-&gt;next;<br>            temp-&gt;next-&gt;prior = temp-&gt;prior;<br>            <span class="hljs-built_in">free</span>(temp);<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表中无该数据元素\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-comment">//head为原双链表，elem表示被查找元素</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectElem</span><span class="hljs-params">(line * head, <span class="hljs-keyword">int</span> elem)</span> </span>&#123;<br>    <span class="hljs-comment">//新建一个指针t，初始化为头指针 head</span><br>    line * t = head;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (t) &#123;<br>        <span class="hljs-keyword">if</span> (t-&gt;data == elem) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        i++;<br>        t = t-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//程序执行至此处，表示查找失败</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//更新函数，其中，add 表示更改结点在双链表中的位置，newElem 为新数据的值</span><br><span class="hljs-function">line *<span class="hljs-title">amendElem</span><span class="hljs-params">(line * p, <span class="hljs-keyword">int</span> add, <span class="hljs-keyword">int</span> newElem)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    line * temp = p;<br>    <span class="hljs-comment">//遍历到被删除结点</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; add; i++) &#123;<br>        temp = temp-&gt;next;<br>        <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;更改位置有误！\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (temp) &#123;<br>        temp-&gt;data = newElem;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-comment">//输出链表的功能函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(line * head)</span> </span>&#123;<br>    line * temp = head;<br>    <span class="hljs-keyword">while</span> (temp) &#123;<br>        <span class="hljs-keyword">if</span> (temp-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, temp-&gt;data);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;&quot;</span>, temp-&gt;data);<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean">初始链表为：<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span><br>在表中第 <span class="hljs-number">3</span> 的位置插入新元素 <span class="hljs-number">7</span>：<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">7</span>-&gt;<span class="hljs-number">3</span><br>删除元素 <span class="hljs-number">2</span>：<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">7</span>-&gt;<span class="hljs-number">3</span><br>元素 <span class="hljs-number">3</span> 的位置是：<span class="hljs-number">3</span><br>将第 <span class="hljs-number">3</span> 个节点存储的数据改为 <span class="hljs-number">6</span>：<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">7</span>-&gt;<span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的遍历</title>
    <link href="/2020/06/data-structure03/"/>
    <url>/2020/06/data-structure03/</url>
    
    <content type="html"><![CDATA[<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="栈及其特点和应用"><a href="#栈及其特点和应用" class="headerlink" title="栈及其特点和应用"></a>栈及其特点和应用</h3><p> <strong>栈和队列顺序栈的基本操作</strong> </p><p>同顺序表和链表一样，栈也是用来存储逻辑关系为 “一对一” 数据的线性存储结构。</p><p>栈只能从表的一端存取数据，另一端是封闭的；在栈中，无论是存数据还是取数据，都必须遵循”先进后出”的原则，即最先进栈的元素最后出栈。因此，我们可以给栈下一个定义，即栈是一种只能从表的一端存取数据且遵循 “先进后出” 原则的线性存储结构。</p><p>通常，栈的开口端被称为栈顶；相应地，封口端被称为栈底。因此，栈顶元素指的就是距离栈顶最近的元素，栈底元素指的是位于栈最底部的元素。</p><p><strong>进栈和出栈</strong></p><p>基于栈结构的特点，在实际应用中，通常只会对栈执行以下两种操作：<br>向栈中添加元素，此过程被称为”进栈”（入栈或压栈）；<br>从栈中提取出指定元素，此过程被称为”出栈”（或弹栈）；</p><p><strong>栈的具体实现</strong></p><p>栈是一种 “特殊” 的线性存储结构，因此栈的具体实现有以下两种方式：</p><p>顺序栈：采用顺序存储结构可以模拟栈存储数据的特点，从而实现栈存储结构；<br>链栈：采用链式存储结构实现栈结构；</p><p>两种实现方式的区别，仅限于数据元素在实际物理空间上存放的相对位置，顺序栈底层采用的是数组，链栈底层采用的是链表。有关顺序栈和链栈的具体实现会在后续章节中作详细讲解。</p><p><strong>栈的应用</strong></p><p>基于栈结构对数据存取采用 “先进后出” 原则的特点，它可以用于实现很多功能。</p><p>例如，我们经常使用浏览器在各种网站上查找信息。假设先浏览的页面 A，然后关闭了页面 A 跳转到页面 B，随后又关闭页面 B 跳转到了页面 C。而此时，我们如果想重新回到页面 A，有两个选择：<br>重新搜索找到页面 A；<br>使用浏览器的”回退”功能。浏览器会先回退到页面 B，而后再回退到页面 A。</p><p>浏览器 “回退” 功能的实现，底层使用的就是栈存储结构。当你关闭页面 A 时，浏览器会将页面 A 入栈；同样，当你关闭页面 B 时，浏览器也会将 B入栈。因此，当你执行回退操作时，才会首先看到的是页面 B，然后是页面 A，这是栈中数据依次出栈的效果。</p><p>不仅如此，栈存储结构还可以帮我们检测代码中的括号匹配问题。多数编程语言都会用到括号（小括号、中括号和大括号），括号的错误使用（通常是丢右括号）会导致程序编译错误，而很多开发工具中都有检测代码是否有编辑错误的功能，其中就包含检测代码中的括号匹配问题，此功能的底层实现使用的就是栈结构。</p><p>同时，栈结构还可以实现数值的进制转换功能。例如，编写程序实现从十进制数自动转换成二进制数，就可以使用栈存储结构来实现。</p><h3 id="顺序栈基本操作（入栈和出栈）"><a href="#顺序栈基本操作（入栈和出栈）" class="headerlink" title="顺序栈基本操作（入栈和出栈）"></a>顺序栈基本操作（入栈和出栈）</h3><p><strong>入栈</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">//元素elem进栈，a为数组，top值为当前栈的栈顶位置</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a,<span class="hljs-keyword">int</span> top,<span class="hljs-keyword">int</span> elem)</span></span>&#123;<br>    a[++top]=elem;<br>    <span class="hljs-keyword">return</span> top;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>代码中的 a[++top]=elem，等价于先执行 ++top，再执行 a[top]=elem。</p><p><strong>出栈</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//数据元素出栈</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * a,<span class="hljs-keyword">int</span> top)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (top==<span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;空栈&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;弹栈元素：%d\n&quot;</span>,a[top]);<br>    top--;<br>    <span class="hljs-keyword">return</span> top;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>代码中的 if 语句是为了防止用户做 “栈中已无数据却还要数据出栈” 的错误操作。代码中，关于对栈中元素出栈操作的实现，只需要 top 值 -1 即可。</p><p><strong>总结</strong></p><p>顺序栈及对数据基本操作的 C 语言完整代码：</p><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">#include &lt;stdio.h&gt;<br>//元素elem进栈<br>int push(int* a,int <span class="hljs-built_in">top</span>,int elem)&#123;<br>    a[++<span class="hljs-built_in">top</span>]=elem;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">top</span>;<br>&#125;<br>//数据元素出栈<br>int pop(int * a,int <span class="hljs-built_in">top</span>)&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">top</span>==<span class="hljs-number">-1</span>) &#123;<br>        printf(<span class="hljs-string">&quot;空栈&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    printf(<span class="hljs-string">&quot;弹栈元素：%d\n&quot;</span>,a[<span class="hljs-built_in">top</span>]);<br>    <span class="hljs-built_in">top</span>--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">top</span>;<br>&#125;<br>int main() &#123;<br>    int a[<span class="hljs-number">100</span>];<br>    int <span class="hljs-built_in">top</span>=<span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">top</span>=push(a, <span class="hljs-built_in">top</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">top</span>=push(a, <span class="hljs-built_in">top</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">top</span>=push(a, <span class="hljs-built_in">top</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">top</span>=push(a, <span class="hljs-built_in">top</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">top</span>=pop(a, <span class="hljs-built_in">top</span>);<br>    <span class="hljs-built_in">top</span>=pop(a, <span class="hljs-built_in">top</span>);<br>    <span class="hljs-built_in">top</span>=pop(a, <span class="hljs-built_in">top</span>);<br>    <span class="hljs-built_in">top</span>=pop(a, <span class="hljs-built_in">top</span>);<br>    <span class="hljs-built_in">top</span>=pop(a, <span class="hljs-built_in">top</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">弹栈元素：4<br>弹栈元素：3<br>弹栈元素：2<br>弹栈元素：1<br>空栈<br></code></pre></div></td></tr></table></figure><h3 id="链栈基本操作（入栈和出栈）"><a href="#链栈基本操作（入栈和出栈）" class="headerlink" title="链栈基本操作（入栈和出栈）"></a>链栈基本操作（入栈和出栈）</h3><p>通常我们将链表的头部作为栈顶，尾部作为栈底，将链表头部作为栈顶的一端，可以避免在实现数据 “入栈” 和 “出栈” 操作时做大量遍历链表的耗时操作。</p><p>链表的头部作为栈顶，意味着：</p><p>在实现数据”入栈”操作时，需要将数据从链表的头部插入；<br>在实现数据”出栈”操作时，需要删除链表头部的首元节点；</p><p>因此，链栈实际上就是一个只能采用头插法插入或删除数据的链表。</p><p>链栈元素入栈</p><p>例如，将元素 1、2、3、4 依次入栈，等价于将各元素采用头插法依次添加到链表中</p><p>C语言实现代码为：</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">//链表中的节点结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lineStack</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lineStack</span> * <span class="hljs-title">next</span>;</span><br>&#125;lineStack;<br><span class="hljs-comment">//stack为当前的链栈，a表示入栈元素</span><br><span class="hljs-function">lineStack* <span class="hljs-title">push</span><span class="hljs-params">(lineStack * stack,<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    <span class="hljs-comment">//创建存储新元素的节点</span><br>    lineStack * line=(lineStack*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(lineStack));<br>    line-&gt;data=a;<br>    <span class="hljs-comment">//新节点与头节点建立逻辑关系</span><br>    line-&gt;next=stack;<br>    <span class="hljs-comment">//更新头指针的指向</span><br>    stack=line;<br>    <span class="hljs-keyword">return</span> stack;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>链栈元素出栈</p><p>实现栈顶元素出链栈的 C 语言实现代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//栈顶元素出链栈的实现函数</span><br><span class="hljs-function">lineStack * <span class="hljs-title">pop</span><span class="hljs-params">(lineStack * stack)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (stack) &#123;<br>        <span class="hljs-comment">//声明一个新指针指向栈顶节点</span><br>        lineStack * p=stack;<br>        <span class="hljs-comment">//更新头指针</span><br>        stack=stack-&gt;next;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;出栈元素：%d &quot;</span>,p-&gt;data);<br>        <span class="hljs-keyword">if</span> (stack) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;新栈顶元素：%d\n&quot;</span>,stack-&gt;data);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈已空\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">free</span>(p);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈内没有元素&quot;</span>);<br>        <span class="hljs-keyword">return</span> stack;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>代码中通过使用 if 判断语句，避免了用户执行”栈已空却还要数据出栈”错误操作。</p><p>总结</p><p>通过采用头插法操作数据的单链表实现了链栈结构，完整的链栈及基本操作代码：</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lineStack</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lineStack</span> * <span class="hljs-title">next</span>;</span><br>&#125;lineStack;<br><span class="hljs-function">lineStack* <span class="hljs-title">push</span><span class="hljs-params">(lineStack * stack,<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    lineStack * line=(lineStack*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(lineStack));<br>    line-&gt;data=a;<br>    line-&gt;next=stack;<br>    stack=line;<br>    <span class="hljs-keyword">return</span> stack;<br>&#125;<br><span class="hljs-function">lineStack * <span class="hljs-title">pop</span><span class="hljs-params">(lineStack * stack)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (stack) &#123;<br>        lineStack * p=stack;<br>        stack=stack-&gt;next;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;弹栈元素：%d &quot;</span>,p-&gt;data);<br>        <span class="hljs-keyword">if</span> (stack) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈顶元素：%d\n&quot;</span>,stack-&gt;data);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈已空\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">free</span>(p);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈内没有元素&quot;</span>);<br>        <span class="hljs-keyword">return</span> stack;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    lineStack * stack=<span class="hljs-literal">NULL</span>;<br>    stack=<span class="hljs-built_in">push</span>(stack, <span class="hljs-number">1</span>);<br>    stack=<span class="hljs-built_in">push</span>(stack, <span class="hljs-number">2</span>);<br>    stack=<span class="hljs-built_in">push</span>(stack, <span class="hljs-number">3</span>);<br>    stack=<span class="hljs-built_in">push</span>(stack, <span class="hljs-number">4</span>);<br>    stack=<span class="hljs-built_in">pop</span>(stack);<br>    stack=<span class="hljs-built_in">pop</span>(stack);<br>    stack=<span class="hljs-built_in">pop</span>(stack);<br>    stack=<span class="hljs-built_in">pop</span>(stack);<br>    stack=<span class="hljs-built_in">pop</span>(stack);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">弹栈元素：4 栈顶元素：3<br>弹栈元素：3 栈顶元素：2<br>弹栈元素：2 栈顶元素：1<br>弹栈元素：1 栈已空<br>栈内没有元素<br></code></pre></div></td></tr></table></figure><h3 id="队列及其应用"><a href="#队列及其应用" class="headerlink" title="队列及其应用"></a>队列及其应用</h3><p>队列的两端都”开口”，要求数据只能从一端进，从另一端出，通常，称进数据的一端为 “队尾”，出数据的一端为 “队头”，数据元素进队列的过程称为 “入队”，出队列的过程称为 “出队”。不仅如此，队列中数据的进出要遵循 “先进先出” 的原则，即最先进队列的数据元素，同样要最先出队列。</p><p><strong>队列的实现</strong></p><p>队列存储结构的实现有以下两种方式：</p><p>顺序队列：在顺序表的基础上实现的队列结构；<br>链队列：在链表的基础上实现的队列结构；</p><p>两者的区别仅是顺序表和链表的区别，即在实际的物理空间中，数据集中存储的队列是顺序队列，分散存储的队列是链队列。</p><p>队列的实际应用</p><p>实际生活中，队列的应用随处可见，比如排队买 XXX、医院的挂号系统等，采用的都是队列的结构。</p><p><strong>栈和队列不要混淆，栈结构是一端封口，特点是”先进后出”；</strong><br><strong>而队列的两端全是开口，特点是”先进先出”。</strong></p><h3 id="顺序队列及其操作"><a href="#顺序队列及其操作" class="headerlink" title="顺序队列及其操作"></a>顺序队列及其操作</h3><p>顺序队列，即采用顺序表模拟实现的队列结构。</p><p>由于顺序队列的底层使用的是数组，因此需预先申请一块足够大的内存空间初始化顺序队列。除此之外，为了满足顺序队列中数据从队尾进，队头出且先进先出的要求，我们还需要定义两个指针（top 和 rear）分别用于指向顺序队列中的队头元素和队尾元素，由于顺序队列初始状态没有存储任何元素，因此 top 指针和 rear 指针重合，且由于顺序队列底层实现靠的是数组，因此 top 和 rear 实际上是两个变量，它的值分别是队头元素和队尾元素所在数组位置的下标。</p><p>当有数据元素进队列时，对应的实现操作是将其存储在指针 rear 指向的数组位置，然后 rear+1；当需要队头元素出队时，仅需做 top+1 操作。</p><p>此方法存在的问题</p><p>整个顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。</p><p>顺序队列整体后移造成的影响是：</p><p>顺序队列之前的数组存储空间将无法再被使用，造成了空间浪费；<br>如果顺序表申请的空间不足够大，则直接造成程序中数组 a 溢出，产生溢出错误；</p><p>为了解决以上两个问题，可以将顺序表打造成一个环状表，即环状顺序队列</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;stdio.h&gt;<br>#define max <span class="hljs-number">5</span><span class="hljs-comment">//表示顺序表申请的空间大小</span><br><span class="hljs-built_in">int</span> en<span class="hljs-constructor">Queue(<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">a</span>,<span class="hljs-params">int</span> <span class="hljs-params">front</span>,<span class="hljs-params">int</span> <span class="hljs-params">rear</span>,<span class="hljs-params">int</span> <span class="hljs-params">data</span>)</span>&#123;<br>    <span class="hljs-comment">//添加判断语句，如果rear超过max，则直接将其从a[0]重新开始存储，如果rear+1和front重合，则表示数组已满</span><br>    <span class="hljs-keyword">if</span> ((rear+<span class="hljs-number">1</span>)%max==front) &#123;<br>        printf(<span class="hljs-string">&quot;空间已满&quot;</span>);<br>        return rear;<br>    &#125;<br>    a<span class="hljs-literal">[<span class="hljs-identifier">rear</span>%<span class="hljs-identifier">max</span>]</span>=data;<br>    rear++;<br>    return rear;<br>&#125;<br><span class="hljs-built_in">int</span>  de<span class="hljs-constructor">Queue(<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">a</span>,<span class="hljs-params">int</span> <span class="hljs-params">front</span>,<span class="hljs-params">int</span> <span class="hljs-params">rear</span>)</span>&#123;<br>    <span class="hljs-comment">//如果front==rear，表示队列为空</span><br>    <span class="hljs-keyword">if</span>(front==rear%max) &#123;<br>        printf(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>        return front;<br>    &#125;<br>    printf(<span class="hljs-string">&quot;%d &quot;</span>,a<span class="hljs-literal">[<span class="hljs-identifier">front</span>]</span>);<br>    <span class="hljs-comment">//front不再直接 +1，而是+1后同max进行比较，如果=max，则直接跳转到 a[0]</span><br>    front=(front+<span class="hljs-number">1</span>)%max;<br>    return front;<br>&#125;<br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span> &#123;<br>    <span class="hljs-built_in">int</span> a<span class="hljs-literal">[<span class="hljs-identifier">max</span>]</span>;<br>    <span class="hljs-built_in">int</span> front,rear;<br>    <span class="hljs-comment">//设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址</span><br>    front=rear=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//入队</span><br>    rear=en<span class="hljs-constructor">Queue(<span class="hljs-params">a</span>,<span class="hljs-params">front</span>,<span class="hljs-params">rear</span>, 1)</span>;<br>    rear=en<span class="hljs-constructor">Queue(<span class="hljs-params">a</span>,<span class="hljs-params">front</span>,<span class="hljs-params">rear</span>, 2)</span>;<br>    rear=en<span class="hljs-constructor">Queue(<span class="hljs-params">a</span>,<span class="hljs-params">front</span>,<span class="hljs-params">rear</span>, 3)</span>;<br>    rear=en<span class="hljs-constructor">Queue(<span class="hljs-params">a</span>,<span class="hljs-params">front</span>,<span class="hljs-params">rear</span>, 4)</span>;<br>    <span class="hljs-comment">//出队</span><br>    front=de<span class="hljs-constructor">Queue(<span class="hljs-params">a</span>, <span class="hljs-params">front</span>, <span class="hljs-params">rear</span>)</span>;<br>    <span class="hljs-comment">//再入队</span><br>    rear=en<span class="hljs-constructor">Queue(<span class="hljs-params">a</span>,<span class="hljs-params">front</span>,<span class="hljs-params">rear</span>, 5)</span>;<br>    <span class="hljs-comment">//再出队</span><br>    front=de<span class="hljs-constructor">Queue(<span class="hljs-params">a</span>, <span class="hljs-params">front</span>, <span class="hljs-params">rear</span>)</span>;<br>    <span class="hljs-comment">//再入队</span><br>    rear=en<span class="hljs-constructor">Queue(<span class="hljs-params">a</span>,<span class="hljs-params">front</span>,<span class="hljs-params">rear</span>, 6)</span>;<br>    <span class="hljs-comment">//再出队</span><br>    front=de<span class="hljs-constructor">Queue(<span class="hljs-params">a</span>, <span class="hljs-params">front</span>, <span class="hljs-params">rear</span>)</span>;<br>    front=de<span class="hljs-constructor">Queue(<span class="hljs-params">a</span>, <span class="hljs-params">front</span>, <span class="hljs-params">rear</span>)</span>;<br>    front=de<span class="hljs-constructor">Queue(<span class="hljs-params">a</span>, <span class="hljs-params">front</span>, <span class="hljs-params">rear</span>)</span>;<br>    front=de<span class="hljs-constructor">Queue(<span class="hljs-params">a</span>, <span class="hljs-params">front</span>, <span class="hljs-params">rear</span>)</span>;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序运行结果：<br>1 2 3 4 5 6</p><p>使用此方法需要注意的是，顺序队列在判断数组是否已满时，出现下面情况：</p><p>当队列为空时，队列的头指针等于队列的尾指针；<br>当数组满员时，队列的头指针等于队列的尾指针；</p><p>顺序队列的存储状态不同，但是判断条件相同。为了对其进行区分，最简单的解决办法是：牺牲掉数组中的一个存储空间，判断数组满员的条件是：尾指针的下一个位置和头指针相遇，就说明数组满了，即程序中第 5 行所示。</p><h3 id="链式队列及基本操作"><a href="#链式队列及基本操作" class="headerlink" title="链式队列及基本操作"></a>链式队列及基本操作</h3><p>链式队列，简称”链队列”，即使用链表实现的队列存储结构。</p><p>链式队列的实现思想同顺序队列类似，只需创建两个指针（命名为 top 和 rear）分别指向链表中队列的队头元素和队尾元素。在链式队列的初始状态，此时队列中没有存储任何数据元素，因此 top 和 rear 指针都同时指向头节点。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">/链表中的节点结构<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> * <span class="hljs-title">next</span>;</span><br>&#125;QNode;<br><span class="hljs-comment">//创建链式队列的函数</span><br><span class="hljs-function">QNode * <span class="hljs-title">initQueue</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//创建一个头节点</span><br>    QNode * queue=(QNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(QNode));<br>    <span class="hljs-comment">//对头节点进行初始化</span><br>    queue-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> queue;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>链式队列数据入队</p><p>链队队列中，当有新的数据元素入队，只需进行以下 3 步操作：</p><p>将该数据元素用节点包裹，例如新节点名称为 elem；<br>与 rear 指针指向的节点建立逻辑关系，即执行 rear-&gt;next=elem；<br>最后移动 rear 指针指向该新节点，即 rear=elem；</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl">QNode* enQueue(QNode * rear,int <span class="hljs-keyword">data</span>)&#123;<br>    <span class="hljs-comment">//1、用节点包裹入队元素</span><br>    QNode * enElem=(QNode*)malloc(sizeof(QNode));<br>    <span class="hljs-function"><span class="hljs-title">enElem</span>-&gt;</span><span class="hljs-keyword">data</span>=<span class="hljs-keyword">data</span>;<br>    <span class="hljs-function"><span class="hljs-title">enElem</span>-&gt;</span>next=NULL;<br>    <span class="hljs-comment">//2、新节点与rear节点建立逻辑关系</span><br>    <span class="hljs-function"><span class="hljs-title">rear</span>-&gt;</span>next=enElem;<br>    <span class="hljs-comment">//3、rear指向新节点</span><br>    rear=enElem;<br>    <span class="hljs-comment">//返回新的rear，为后续新元素入队做准备</span><br>    return rear;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>链式队列数据出队</p><p>当链式队列中，有数据元素需要出队时，按照 “先进先出” 的原则，只需将存储该数据的节点以及它之前入队的元素节点按照原则依次出队即可。</p><p>链式队列中队头元素出队，需要做以下 3 步操作：</p><p>通过 top 指针直接找到队头节点，创建一个新指针 p 指向此即将出队的节点；<br>将 p 节点（即要出队的队头节点）从链表中摘除；<br>释放节点 p，回收其所占的内存空间；</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">void DeQueue(QNode * top,QNode * rear)&#123;<br>    QNode * <span class="hljs-attribute">p</span>=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (top-&gt;<span class="hljs-attribute">next</span>==NULL) &#123;<br>        printf(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>        return ;<br>    &#125;<br>    <span class="hljs-attribute">p</span>=top-&gt;next;<br>    printf(<span class="hljs-string">&quot;%d&quot;</span>,p-&gt;data);<br>    top-&gt;<span class="hljs-attribute">next</span>=p-&gt;next;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-attribute">rear</span>==p) &#123;<br>        <span class="hljs-attribute">rear</span>=top;<br>    &#125;<br>    free(p);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意，将队头元素做出队操作时，需提前判断队列中是否还有元素，如果没有，要提示用户无法做出队操作，保证程序的健壮性。</p><p>总结</p><p>链式队列入队和出队的完整代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;stdio.h&gt;<br>#<span class="hljs-keyword">include</span> &lt;stdlib.h&gt;<br>typedef <span class="hljs-keyword">struct</span> QNode&#123;<br>    <span class="hljs-built_in">int</span> data;<br>    <span class="hljs-keyword">struct</span> QNode<span class="hljs-operator"> * </span>next;<br>&#125;QNode;<br>QNode<span class="hljs-operator"> * </span>init<span class="hljs-constructor">Queue()</span>&#123;<br>    QNode<span class="hljs-operator"> * </span>queue=(QNode*)malloc(sizeof(QNode));<br>    queue-&gt;next=NULL;<br>    return queue;<br>&#125;<br>QNode* en<span class="hljs-constructor">Queue(QNode <span class="hljs-operator">*</span> <span class="hljs-params">rear</span>,<span class="hljs-params">int</span> <span class="hljs-params">data</span>)</span>&#123;<br>    QNode<span class="hljs-operator"> * </span>enElem=(QNode*)malloc(sizeof(QNode));<br>    enElem-&gt;data=data;<br>    enElem-&gt;next=NULL;<br>    <span class="hljs-comment">//使用尾插法向链队列中添加数据元素</span><br>    rear-&gt;next=enElem;<br>    rear=enElem;<br>    return rear;<br>&#125;<br>QNode* <span class="hljs-constructor">DeQueue(QNode <span class="hljs-operator">*</span> <span class="hljs-params">top</span>,QNode <span class="hljs-operator">*</span> <span class="hljs-params">rear</span>)</span>&#123;<br>    QNode<span class="hljs-operator"> * </span>p = NULL;<br>    <span class="hljs-keyword">if</span> (top-&gt;next==NULL) &#123;<br>        printf(<span class="hljs-string">&quot;\n队列为空&quot;</span>);<br>        return rear;<br>    &#125;<br>    p=top-&gt;next;<br>    printf(<span class="hljs-string">&quot;%d &quot;</span>,p-&gt;data);<br>    top-&gt;next=p-&gt;next;<br>    <span class="hljs-keyword">if</span> (rear==p) &#123;<br>        rear=top;<br>    &#125;<br>    free(p);<br>    return rear;<br>&#125;<br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span> &#123;<br>    QNode<span class="hljs-operator"> * </span>queue,*top,*rear;<br>    queue=top=rear=init<span class="hljs-constructor">Queue()</span>;<span class="hljs-comment">//创建头结点</span><br>    <span class="hljs-comment">//向链队列中添加结点，使用尾插法添加的同时，队尾指针需要指向链表的最后一个元素</span><br>    rear=en<span class="hljs-constructor">Queue(<span class="hljs-params">rear</span>, 1)</span>;<br>    rear=en<span class="hljs-constructor">Queue(<span class="hljs-params">rear</span>, 2)</span>;<br>    rear=en<span class="hljs-constructor">Queue(<span class="hljs-params">rear</span>, 3)</span>;<br>    rear=en<span class="hljs-constructor">Queue(<span class="hljs-params">rear</span>, 4)</span>;<br>    <span class="hljs-comment">//入队完成，所有数据元素开始出队列</span><br>    rear=<span class="hljs-constructor">DeQueue(<span class="hljs-params">top</span>, <span class="hljs-params">rear</span>)</span>;<br>    rear=<span class="hljs-constructor">DeQueue(<span class="hljs-params">top</span>, <span class="hljs-params">rear</span>)</span>;<br>    rear=<span class="hljs-constructor">DeQueue(<span class="hljs-params">top</span>, <span class="hljs-params">rear</span>)</span>;<br>    rear=<span class="hljs-constructor">DeQueue(<span class="hljs-params">top</span>, <span class="hljs-params">rear</span>)</span>;<br>    rear=<span class="hljs-constructor">DeQueue(<span class="hljs-params">top</span>, <span class="hljs-params">rear</span>)</span>;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序运行结果为：</p><p>1 2 3 4<br>队列为空</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的遍历</title>
    <link href="/2020/06/data-structure04/"/>
    <url>/2020/06/data-structure04/</url>
    
    <content type="html"><![CDATA[<h2 id="串存储结构及其实现"><a href="#串存储结构及其实现" class="headerlink" title="串存储结构及其实现"></a>串存储结构及其实现</h2><p>数据结构中，字符串要单独用一种存储结构来存储，称为串存储结构。这里的串指的就是字符串。</p><p>严格意义上讲，串存储结构也是一种线性存储结构，因为字符串中的字符之间也具有”一对一”的逻辑关系。只不过串结构只用于存储字符类型的数据。</p><p>数据结构中，根据串中存储字符的数量及特点，对一些特殊的串进行了命名，比如说：</p><p>空串：存储 0 个字符的串，例如 S = “”（双引号紧挨着）；</p><p>空格串：只包含空格字符的串，例如 S = “     “（双引号包含 5 个空格）；</p><p>子串和主串：假设有两个串 a 和 b，如果 a 中可以找到几个连续字符组成的串与 b 完全相同，则称 a 是 b 的主串，b 是 a 的子串。例如，若 a = “shujujiegou”，b = “shuju”，由于 a  中也包含 “shuju”，因此串 a 和串 b 是主串和子串的关系；</p><p>需要注意的是，空格串和空串不同，空格串中含有字符，只是都是空格而已。另外，只有串 b 整体出现在串 a 中，才能说 b 是 a 的子串，比如 “shujiejugou” 和 “shuju” 就不是主串和子串的关系。</p><p>另外，对于具有主串和子串关系的两个串，通常会让你用算法找到子串在主串的位置。子串在主串中的位置，指的是子串首个字符在主串中的位置。</p><p>例如，串 a = “shujujiegou”，串 b = “jiegou”，通过观察，可以判断 a 和 b 是主串和子串的关系，同时子串 b 位于主串 a 中第 6 的位置，因为在串 a 中，串 b 首字符 ‘j’ 的位置是 6。</p><p><strong>串存储结构的具体实现</strong></p><p>存储一个字符串，数据结构包含以下 3 种具体存储结构：</p><p>定长顺序存储：实际上就是用普通数组（又称静态数组）存储。例如 C 语言使用普通数据存储字符串的代码为 char a[20] = “data.biancheng.net”；<br>堆分配存储：用动态数组存储字符串；<br>块链存储：用链表存储字符串；</p><h3 id="定长顺序存储"><a href="#定长顺序存储" class="headerlink" title="定长顺序存储"></a>定长顺序存储</h3><p>串的定长顺序存储结构，可以简单地理解为采用 “固定长度的顺序存储结构” 来存储字符串，因此限定了其底层实现只能使用静态数组。</p><p>使用定长顺序存储结构存储字符串时，需结合目标字符串的长度，预先申请足够大的内存空间。</p><p>例如，采用定长顺序存储结构存储 “hello world”，通过目测得知此字符串长度为 11（不包含结束符 ‘\0’），因此我们申请的数组空间长度至少为 11，用 C 语言表示为：</p><p><code>char str[11] = &quot;hello world&quot;;</code></p><p>使用定长顺序存储结构存储字符串：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">char</span> str[<span class="hljs-number">20</span>]=<span class="hljs-string">&quot;data.biancheng.net&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="串的堆分配存储结构"><a href="#串的堆分配存储结构" class="headerlink" title="串的堆分配存储结构"></a>串的堆分配存储结构</h3><p>串的堆分配存储，其具体实现方式是采用动态数组存储字符串。</p><p>在C语言中，程序会将内存分为 4 个区域，分别为堆区、栈区、数据区和代码区，与其他区域不同，堆区的内存空间需要程序员手动使用 malloc 函数申请，并且在不用后要手动通过 free 函数将其释放。</p><p>C 语言中使用 malloc 函数最多的场景是给数组分配空间，这类数组称为动态数组。例如：</p><p><code>char * a = (char*)malloc(5*sizeof(char));</code></p><p>此行代码创建了一个动态数组 a，通过使用 malloc 申请了 5 个 char 类型大小的堆存储空间。</p><p>动态数组相比普通数组（静态数组）的优势是长度可变，换句话说，根据需要动态数组可额外申请更多的堆空间（使用 relloc 函数）：<br><code>a = (char*)realloc(a, 10*sizeof(char));</code></p><p>通过使用这行代码，之前具有 5 个 char 型存储空间的动态数组，其容量扩大为可存储 10 个 char 型数据。</p><h3 id="串的块链存储结构"><a href="#串的块链存储结构" class="headerlink" title="串的块链存储结构"></a>串的块链存储结构</h3><p>串的块链存储，指的是使用链表结构存储字符串。</p><p>单链表中的 “单” 强调的仅仅是链表各个节点只能有一个指针，并没有限制数据域中存储数据的具体个数。因此在设计链表节点的结构时，可以令各节点存储多个数据。</p><p>链表各节点存储数据个数的多少可参考以下几个因素：</p><p>串的长度和存储空间的大小：若串包含数据量很大，且链表申请的存储空间有限，此时应尽可能的让各节点存储更多的数据，提高空间的利用率（每多一个节点，就要多申请一个指针域的空间）；反之，如果串不是特别长，或者存储空间足够，就需要再结合其他因素综合考虑；</p><p>程序实现的功能：如果实际场景中需要对存储的串做大量的插入或删除操作，则应尽可能减少各节点存储数据的数量；反之，就需要再结合其他因素。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> linkNum 3<span class="hljs-comment">//全局设置链表中节点存储数据的个数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Link</span> &#123;</span><br>    <span class="hljs-keyword">char</span> a[linkNum]; <span class="hljs-comment">//数据域可存放 linkNum 个数据</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Link</span> * <span class="hljs-title">next</span>;</span> <span class="hljs-comment">//代表指针域，指向直接后继元素</span><br>&#125;link; <span class="hljs-comment">// nk为节点名，每个节点都是一个 link 结构体</span><br><span class="hljs-function">link * <span class="hljs-title">initLink</span><span class="hljs-params">(link * head, <span class="hljs-keyword">char</span> * str)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">displayLink</span><span class="hljs-params">(link * head)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    link * head = <span class="hljs-literal">NULL</span>;<br>    head = <span class="hljs-built_in">initLink</span>(head, <span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-built_in">displayLink</span>(head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//初始化链表，其中head为头指针，str为存储的字符串</span><br><span class="hljs-function">link * <span class="hljs-title">initLink</span><span class="hljs-params">(link * head, <span class="hljs-keyword">char</span> * str)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> length = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-comment">//根据字符串的长度，计算出链表中使用节点的个数</span><br>    <span class="hljs-keyword">int</span> num = length/linkNum;<br>    <span class="hljs-keyword">if</span> (length%linkNum) &#123;<br>        num++;<br>    &#125;<br>    <span class="hljs-comment">//创建并初始化首元节点</span><br>    head = (link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(link));<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    link *temp = head;<br>    <span class="hljs-comment">//初始化链表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;num; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; j&lt;linkNum; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i*linkNum + j &lt; length) &#123;<br>                temp-&gt;a[j] = str[i*linkNum + j];<br>            &#125;          <br>            <span class="hljs-keyword">else</span><br>                temp-&gt;a[j] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i*linkNum + j &lt; length)<br>        &#123;<br>            link * newlink = (link*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(link));<br>            newlink-&gt;next = <span class="hljs-literal">NULL</span>;<br>            temp-&gt;next = newlink;<br>            temp = newlink;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-comment">//输出链表</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">displayLink</span><span class="hljs-params">(link * head)</span> </span>&#123;<br>    link * temp = head;<br>    <span class="hljs-keyword">while</span> (temp) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; linkNum; i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, temp-&gt;a[i]);<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序输出结果为：<br><code>hello world</code></p><h3 id="BF算法（串模式匹配算法）"><a href="#BF算法（串模式匹配算法）" class="headerlink" title="BF算法（串模式匹配算法）"></a>BF算法（串模式匹配算法）</h3><p>串的模式匹配算法，通俗地理解，是一种用来判断两个串之间是否具有”主串与子串”关系的算法。</p><p>主串与子串：如果串 A（如 “shujujiegou”）中包含有串 B（如 “ju”），则称串 A 为主串，串 B 为子串。主串与子串之间的关系可简单理解为一个串 “包含” 另一个串的关系。</p><p>实现串的模式匹配的算法主要有以下两种：</p><p>普通的模式匹配算法；<br>快速模式匹配算法；</p><p>BF算法原理即普通模式匹配算法，其实现过程没有任何技巧，就是简单粗暴地拿一个串同另一个串中的字符一一比对，得到最终结果。</p><p>BF 算法的实现思想是：将用户指定的两个串 A 和串 B，使用串的定长顺序存储结构存储起来，然后循环实现两个串的模式匹配过程，C 语言实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">//串普通模式匹配算法的实现函数，其中 B是伪主串，A是伪子串</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mate</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * B,<span class="hljs-keyword">char</span> *A)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-built_in">strlen</span>(B) &amp;&amp; j&lt;<span class="hljs-built_in">strlen</span>(A)) &#123;<br>        <span class="hljs-keyword">if</span> (B[i]==A[j]) &#123;<br>            i++;<br>            j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            i=i-j+<span class="hljs-number">1</span>;<br>            j=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//跳出循环有两种可能，i=strlen(B)说明已经遍历完主串，匹配失败；j=strlen(A),说明子串遍历完成，在主串中成功匹配</span><br>    <span class="hljs-keyword">if</span> (j==<span class="hljs-built_in">strlen</span>(A)) &#123;<br>        <span class="hljs-keyword">return</span> i-<span class="hljs-built_in">strlen</span>(A)+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//运行到此，为i==strlen(B)的情况</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> number=<span class="hljs-built_in">mate</span>(<span class="hljs-string">&quot;ababcabcacbab&quot;</span>, <span class="hljs-string">&quot;abcac&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,number);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序运行结果：6</p><p>注意，在实现过程中，我们借助 i-strlen(A)+1 就可以得到成功模式匹配所用的次数，也就是串 A 移动的总次数。</p><p>BF算法时间复杂度</p><p>该算法最理想的时间复杂度 O(n)，n 表示串 A 的长度，即第一次匹配就成功。</p><p>BF 算法最坏情况的时间复杂度为 O(n*m)，n 为串 A 的长度，m 为串 B 的长度。例如，串 B 为 “0000000001”，而串 A 为 “01”，这种情况下，两个串每次匹配，都必须匹配至串 A 的最末尾才能判断匹配失败，因此运行了 n*m 次。</p><h2 id="数组和广义表"><a href="#数组和广义表" class="headerlink" title="数组和广义表"></a>数组和广义表</h2><p>数组和其他线性存储结构不同，顺序表、链表、栈和队列存储的都是不可再分的数据元素（如数字 5、字符 ‘a’ 等），而数组既可以用来存储不可再分的数据元素，也可以用来存储像顺序表、链表这样的数据结构。</p><p>一维数组，指的是存储不可再分数据元素的数组，二维数组，指的存储一维数组的一维数组，n 维数组，指的是存储 n-1 维数组的一维数组；</p><p>注意，无论数组的维数是多少，数组中的数据类型都必须一致</p><h3 id="数组的顺序存储及（C语言）实现"><a href="#数组的顺序存储及（C语言）实现" class="headerlink" title="数组的顺序存储及（C语言）实现"></a>数组的顺序存储及（C语言）实现</h3><p>数组作为一种线性存储结构，对存储的数据通常只做查找和修改操作，因此数组结构的实现使用的是顺序存储结构。</p><p>由于数组可以是多维的，而顺序存储结构是一维的，因此数组中数据的存储要制定一个先后次序。通常，数组中数据的存储有两种先后存储方式：</p><p>以列序为主（先列后行）：按照行号从小到大的顺序，依次存储每一列的元素<br>以行序为主（先行后序）：按照列号从小到大的顺序，依次存储每一行的元素。</p><p><strong>多维数组查找指定元素</strong></p><p>当需要在顺序存储的多维数组中查找某个指定元素时，需知道以下信息：</p><ul><li>多维数组的存储方式；</li><li>多维数组在内存中存放的起始地址；</li><li>该指定元素在原多维数组的坐标（比如说，二维数组中是通过行标和列标来表明数据元素的具体位置的）；</li><li>数组中数组的具体类型，即数组中单个数据元素所占内存的大小，通常用字母 L 表示；</li></ul><p>根据存储方式的不同，查找目标元素的方式也不同。如果二维数组采用以行序为主的方式，则在二维数组 anm 中查找 aij 存放位置的公式为：<br><code>LOC(i,j) = LOC(0,0) + (i*m + j) * L;</code></p><p>其中，LOC(i,j) 为 aij 在内存中的地址，LOC(0,0) 为二维数组在内存中存放的起始位置（也就是 a00 的位置），要注意起始位置不一定是a00，也可能是a11或者其他位置，下同。</p><p>而如果采用以列存储的方式，在 anm 中查找 aij 的方式为：<br><code>LOC(i,j) = LOC(0,0) + (i*n + j) * L;</code></p><p>以下给出了采用以行序为主的方式存储三维数组 a[3][4][2] 的 C 语言代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span> <span class="hljs-comment">// atoi()</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;io.h&gt;</span> <span class="hljs-comment">// eof()</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INFEASIBLE -1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OVERFLOW 3</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNDERFLOW 4</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Status; <span class="hljs-comment">//Status是函数的类型,其值是函数结果状态代码，如OK等</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Boolean; <span class="hljs-comment">//Boolean是布尔类型,其值是TRUE或FALSE</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_ARRAY_DIM 8 <span class="hljs-comment">//假设数组维数的最大值为8</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType *base; <span class="hljs-comment">//数组元素基址，由InitArray分配</span><br>    <span class="hljs-keyword">int</span> dim; <span class="hljs-comment">//数组维数</span><br>    <span class="hljs-keyword">int</span> *bounds; <span class="hljs-comment">//数组维界基址，由InitArray分配</span><br>    <span class="hljs-keyword">int</span> *constants; <span class="hljs-comment">// 数组映象函数常量基址，由InitArray分配</span><br>&#125; Array;<br><span class="hljs-function">Status <span class="hljs-title">InitArray</span><span class="hljs-params">(Array *A,<span class="hljs-keyword">int</span> dim,...)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//若维数dim和各维长度合法，则构造相应的数组A，并返回OK</span><br>    <span class="hljs-keyword">int</span> elemtotal=<span class="hljs-number">1</span>,i; <span class="hljs-comment">// elemtotal是元素总值</span><br>    va_list ap;<br>    <span class="hljs-keyword">if</span>(dim&lt;<span class="hljs-number">1</span>||dim&gt;MAX_ARRAY_DIM)<br>        <span class="hljs-keyword">return</span> ERROR;<br>    (*A).dim=dim;<br>    (*A).bounds=(<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(dim*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>));<br>    <span class="hljs-keyword">if</span>(!(*A).bounds)<br>        <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    <span class="hljs-built_in">va_start</span>(ap,dim);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;dim; ++i)<br>    &#123;<br>        (*A).bounds[i]=<span class="hljs-built_in">va_arg</span>(ap,<span class="hljs-keyword">int</span>);<br>        <span class="hljs-keyword">if</span>((*A).bounds[i]&lt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> UNDERFLOW;<br>        elemtotal*=(*A).bounds[i];<br>    &#125;<br>    <span class="hljs-built_in">va_end</span>(ap);<br>    (*A).base=(ElemType *)<span class="hljs-built_in">malloc</span>(elemtotal*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ElemType));<br>    <span class="hljs-keyword">if</span>(!(*A).base)<br>        <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    (*A).constants=(<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(dim*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>));<br>    <span class="hljs-keyword">if</span>(!(*A).constants)<br>        <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    (*A).constants[dim<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(i=dim<span class="hljs-number">-2</span>; i&gt;=<span class="hljs-number">0</span>; --i)<br>        (*A).constants[i]=(*A).bounds[i+<span class="hljs-number">1</span>]*(*A).constants[i+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">DestroyArray</span><span class="hljs-params">(Array *A)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//销毁数组A</span><br>    <span class="hljs-keyword">if</span>((*A).base)<br>    &#123;<br>        <span class="hljs-built_in">free</span>((*A).base);<br>        (*A).base=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span>((*A).bounds)<br>    &#123;<br>        <span class="hljs-built_in">free</span>((*A).bounds);<br>        (*A).bounds=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span>((*A).constants)<br>    &#123;<br>        <span class="hljs-built_in">free</span>((*A).constants);<br>        (*A).constants=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Locate</span><span class="hljs-params">(Array A,va_list ap,<span class="hljs-keyword">int</span> *off)</span> <span class="hljs-comment">// Value()、Assign()调用此函数 */</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//若ap指示的各下标值合法，则求出该元素在A中的相对地址off</span><br>    <span class="hljs-keyword">int</span> i,ind;<br>    *off=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;A.dim; i++)<br>    &#123;<br>        ind=<span class="hljs-built_in">va_arg</span>(ap,<span class="hljs-keyword">int</span>);<br>        <span class="hljs-keyword">if</span>(ind&lt;<span class="hljs-number">0</span>||ind&gt;=A.bounds[i])<br>            <span class="hljs-keyword">return</span> OVERFLOW;<br>        *off+=A.constants[i]*ind;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Value</span><span class="hljs-params">(ElemType *e,Array A,...)</span> <span class="hljs-comment">//在VC++中，...之前的形参不能是引用类型</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//依次为各维的下标值，若各下标合法，则e被赋值为A的相应的元素值</span><br>    va_list ap;<br>    Status result;<br>    <span class="hljs-keyword">int</span> off;<br>    <span class="hljs-built_in">va_start</span>(ap,A);<br>    <span class="hljs-keyword">if</span>((result=<span class="hljs-built_in">Locate</span>(A,ap,&amp;off))==OVERFLOW) <span class="hljs-comment">//调用Locate()</span><br>        <span class="hljs-keyword">return</span> result;<br>    *e=*(A.base+off);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Assign</span><span class="hljs-params">(Array *A,ElemType e,...)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//依次为各维的下标值，若各下标合法，则将e的值赋给A的指定的元素</span><br>    va_list ap;<br>    Status result;<br>    <span class="hljs-keyword">int</span> off;<br>    <span class="hljs-built_in">va_start</span>(ap,e);<br>    <span class="hljs-keyword">if</span>((result=<span class="hljs-built_in">Locate</span>(*A,ap,&amp;off))==OVERFLOW) <span class="hljs-comment">//调用Locate()</span><br>        <span class="hljs-keyword">return</span> result;<br>    *((*A).base+off)=e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Array A;<br>    <span class="hljs-keyword">int</span> i,j,k,*p,dim=<span class="hljs-number">3</span>,bound1=<span class="hljs-number">3</span>,bound2=<span class="hljs-number">4</span>,bound3=<span class="hljs-number">2</span>; <span class="hljs-comment">//a[3][4][2]数组</span><br>    ElemType e,*p1;<br>    <span class="hljs-built_in">InitArray</span>(&amp;A,dim,bound1,bound2,bound3); <span class="hljs-comment">//构造3＊4＊2的3维数组A</span><br>    p=A.bounds;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A.bounds=&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;dim; i++) <span class="hljs-comment">//顺序输出A.bounds</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*(p+i));<br>    p=A.constants;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nA.constants=&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;dim; i++) <span class="hljs-comment">//顺序输出A.constants</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*(p+i));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d页%d行%d列矩阵元素如下:\n&quot;</span>,bound1,bound2,bound3);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;bound1; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;bound2; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>; k&lt;bound3; k++)<br>            &#123;<br>                <span class="hljs-built_in">Assign</span>(&amp;A,i*<span class="hljs-number">100</span>+j*<span class="hljs-number">10</span>+k,i,j,k); <span class="hljs-comment">// 将i*100+j*10+k赋值给A[i][j][k]</span><br>                <span class="hljs-built_in">Value</span>(&amp;e,A,i,j,k); <span class="hljs-comment">//将A[i][j][k]的值赋给e</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A[%d][%d][%d]=%2d &quot;</span>,i,j,k,e); <span class="hljs-comment">//输出A[i][j][k]</span><br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    p1=A.base;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A.base=\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;bound1*bound2*bound3; i++) <span class="hljs-comment">//顺序输出A.base</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%4d&quot;</span>,*(p1+i));<br>        <span class="hljs-keyword">if</span>(i%(bound2*bound3)==bound2*bound3<span class="hljs-number">-1</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">DestroyArray</span>(&amp;A);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果为：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">A</span>.bounds=<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">A</span>.constants=<span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">3</span>页<span class="hljs-number">4</span>行<span class="hljs-number">2</span>列矩阵元素如下:<br><span class="hljs-attribute">A</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]= <span class="hljs-number">0</span> A[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]= <span class="hljs-number">1</span><br><span class="hljs-attribute">A</span>[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">10</span> A[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">11</span><br><span class="hljs-attribute">A</span>[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">20</span> A[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">21</span><br><span class="hljs-attribute">A</span>[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">30</span> A[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">31</span><br><br><span class="hljs-attribute">A</span>[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">100</span> A[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">101</span><br><span class="hljs-attribute">A</span>[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">110</span> A[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">111</span><br><span class="hljs-attribute">A</span>[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">120</span> A[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">121</span><br><span class="hljs-attribute">A</span>[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">130</span> A[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">131</span><br><br><span class="hljs-attribute">A</span>[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">200</span> A[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">201</span><br><span class="hljs-attribute">A</span>[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">210</span> A[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">211</span><br><span class="hljs-attribute">A</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">220</span> A[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">221</span><br><span class="hljs-attribute">A</span>[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">230</span> A[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">231</span><br><br><span class="hljs-attribute">A</span>.base=<br>   <span class="hljs-attribute">0</span>   <span class="hljs-number">1</span>  <span class="hljs-number">10</span>  <span class="hljs-number">11</span>  <span class="hljs-number">20</span>  <span class="hljs-number">21</span>  <span class="hljs-number">30</span>  <span class="hljs-number">31</span><br><span class="hljs-attribute">100</span> <span class="hljs-number">101</span> <span class="hljs-number">110</span> <span class="hljs-number">111</span> <span class="hljs-number">120</span> <span class="hljs-number">121</span> <span class="hljs-number">130</span> <span class="hljs-number">131</span><br><span class="hljs-attribute">200</span> <span class="hljs-number">201</span> <span class="hljs-number">210</span> <span class="hljs-number">211</span> <span class="hljs-number">220</span> <span class="hljs-number">221</span> <span class="hljs-number">230</span> <span class="hljs-number">231</span><br></code></pre></div></td></tr></table></figure><h3 id="矩阵（稀疏矩阵）压缩存储"><a href="#矩阵（稀疏矩阵）压缩存储" class="headerlink" title="矩阵（稀疏矩阵）压缩存储"></a>矩阵（稀疏矩阵）压缩存储</h3><p>数据结构中，提供针对某些特殊矩阵的压缩存储结构。</p><p>这里所说的特殊矩阵，主要分为以下两类：<br>含有大量相同数据元素的矩阵，比如对称矩阵；<br>含有大量 0 元素的矩阵，比如稀疏矩阵、上（下）三角矩阵；</p><p>针对以上两类矩阵，数据结构的压缩存储思想是：矩阵中的相同数据元素（包括元素 0）只存储一个。</p><p><strong>对称矩阵</strong></p><p>数据元素沿主对角线对应相等，这类矩阵称为对称矩阵。</p><p>矩阵中有两条对角线，其中左上角到右下角的对角线称为主对角线，另一条从左下角到右上角的对角线为副对角线。对称矩阵指的是各数据元素沿主对角线对称的矩阵。</p><p>结合数据结构压缩存储的思想，我们可以使用一维数组存储对称矩阵。由于矩阵中沿对角线两侧的数据相等，因此数组中只需存储对角线一侧（包含对角线）的数据即可。</p><p>对称矩阵的实现过程是，若存储下三角中的元素，只需将各元素所在的行标 i 和列标 j 代入下面的公式：</p><p>存储上三角的元素要将各元素的行标 i 和列标 j 代入另一个公式：</p><p>最终求得的 k 值即为该元素存储到数组中的位置（矩阵中元素的行标和列标都从 1 开始）。</p><p>注意，以上两个公式既是用来存储矩阵中元素的，也用来从数组中提取矩阵相应位置的元素。</p><p><strong>上（下）三角矩阵</strong></p><p>主对角线下的数据元素全部相同的矩阵为上三角矩阵，主对角线上元素全部相同的矩阵为下三角矩阵。</p><p>对于这类特殊的矩阵，压缩存储的方式是：上（下）三角矩阵采用对称矩阵的方式存储上（下）三角的数据（元素 0 不用存储）。上(下)三角矩阵存储元素和提取元素的过程和对称矩阵相同。</p><p><strong>稀疏矩阵</strong></p><p>如果矩阵中分布有大量的元素 0，即非 0 元素非常少，这类矩阵称为稀疏矩阵。</p><p>压缩存储稀疏矩阵的方法是：只存储矩阵中的非 0 元素，与前面的存储方法不同，稀疏矩阵非 0 元素的存储需同时存储该元素所在矩阵中的行标和列标。</p><p>例如，存储图 5 中的稀疏矩阵，需存储以下信息：<br>(1,1,1)：数据元素为 1，在矩阵中的位置为 (1,1)；<br>(3,3,1)：数据元素为 3，在矩阵中的位置为 (3,1)；<br>(5,2,3)：数据元素为 5，在矩阵中的位置为 (2,3)；<br>除此之外，还要存储矩阵的行数 3 和列数 3；</p><p>由此，可以成功存储一个稀疏矩阵。</p><p><strong>矩阵压缩存储的 3 种方式</strong></p><p>对于以上 3 种特殊的矩阵，对阵矩阵和上下三角矩阵的实现方法是相同的，且实现过程比较容易，仅需套用上面给出的公式即可。</p><p>稀疏矩阵的压缩存储，数据结构提供有 3 种具体实现方式：<br>三元组顺序表；<br>行逻辑链接的顺序表；<br>十字链表；</p><h4 id="三元组顺序表，稀疏矩阵的三元组表示及实现"><a href="#三元组顺序表，稀疏矩阵的三元组表示及实现" class="headerlink" title="三元组顺序表，稀疏矩阵的三元组表示及实现"></a>三元组顺序表，稀疏矩阵的三元组表示及实现</h4><p>三元组是由 3 部分数据组成的集合，组中数据分别表示（行标，列标，元素值）。</p><p>三元组需要用结构体实现，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//三元组结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">int</span> i,j;<span class="hljs-comment">//行标i，列标j</span><br>    <span class="hljs-keyword">int</span> data;<span class="hljs-comment">//元素值</span><br>&#125;triple;<br></code></pre></div></td></tr></table></figure><p>由于稀疏矩阵中非 0 元素有多个，因此需要建立 triple 数组存储各个元素的三元组。除此之外，考虑到还要存储矩阵的总行数和总列数，因此可以采用以下结构表示整个稀疏矩阵：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> number 20</span><br><span class="hljs-comment">//矩阵的结构表示</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    triple data[number];<span class="hljs-comment">//存储该矩阵中所有非0元素的三元组</span><br>    <span class="hljs-keyword">int</span> n,m,num;<span class="hljs-comment">//n和m分别记录矩阵的行数和列数，num记录矩阵中所有的非0元素的个数</span><br>&#125;TSMatrix;<br></code></pre></div></td></tr></table></figure><p>可以看到，TSMatrix 是一个结构体，其包含一个三元组数组，以及用于存储矩阵总行数、总列数和非 0 元素个数的变量。</p><p>使用TSMatrix存储下列稀疏矩阵：<br>1 0 0<br>0 0 5<br>3 0 0</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span>&lt;stdio.h&gt;<br>#define number <span class="hljs-number">3</span><br>typedef <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-built_in">int</span> i,j;<br>    <span class="hljs-built_in">int</span> data;<br>&#125;triple;<br>typedef <span class="hljs-keyword">struct</span> &#123;<br>    triple data<span class="hljs-literal">[<span class="hljs-identifier">number</span>]</span>;<br>    <span class="hljs-built_in">int</span> n,m,num;<br>&#125;TSMatrix;<br><span class="hljs-comment">//输出存储的稀疏矩阵</span><br>void display(TSMatrix M);<br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span> &#123;<br>    TSMatrix M;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>m=<span class="hljs-number">3</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>n=<span class="hljs-number">3</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>num=<span class="hljs-number">3</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.i=<span class="hljs-number">1</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.j=<span class="hljs-number">1</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.data=<span class="hljs-number">1</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>.i=<span class="hljs-number">2</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>.j=<span class="hljs-number">3</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>.data=<span class="hljs-number">5</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>.i=<span class="hljs-number">3</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>.j=<span class="hljs-number">1</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>.data=<span class="hljs-number">3</span>;<br>    display(M);<br>    return <span class="hljs-number">0</span>;<br>&#125;<br>void display(TSMatrix M)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>m;j++)&#123;<br>            <span class="hljs-built_in">int</span> value =<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>num;k++)&#123;<br>                <span class="hljs-keyword">if</span>(i<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>.i<span class="hljs-operator"> &amp;&amp; </span>j<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>.j)&#123;<br>                    printf(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>.data);<br>                    value =<span class="hljs-number">1</span>;<br>                    break;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(value<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>                printf(<span class="hljs-string">&quot;0 &quot;</span>);<br>        &#125;<br>        printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="行逻辑链接的顺序表"><a href="#行逻辑链接的顺序表" class="headerlink" title="行逻辑链接的顺序表"></a>行逻辑链接的顺序表</h4><p>行逻辑链接的顺序表和三元组顺序表的实现过程类似，它们存储矩阵的过程完全相同，都是将矩阵中非 0 元素的三元组（行标、列标和元素值）存储在一维数组中。他们的区别在于行逻辑链接的顺序表存储矩阵时比三元组顺序表多使用了一个数组，专门记录矩阵中每行第一个非 0 元素在一维数组中的位置，它仅比三元组顺序表多使用了一个 rpos 数组，从而提高了提取数据时遍历数组的效率。</p><p>存储下列稀疏矩阵：<br>0 3 0 5<br>0 0 1 0<br>2 0 0 0</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;stdio.h&gt;<br>#define MAXSIZE <span class="hljs-number">12500</span><br>#define MAXRC <span class="hljs-number">100</span><br>#define ElemType <span class="hljs-built_in">int</span><br>typedef <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-built_in">int</span> i,j;<span class="hljs-comment">//行，列</span><br>    ElemType e;<span class="hljs-comment">//元素值</span><br>&#125;Triple;<br>typedef <span class="hljs-keyword">struct</span><br>&#123;<br>    Triple  data<span class="hljs-literal">[MAXSIZE+<span class="hljs-number">1</span>]</span>;<br>    <span class="hljs-built_in">int</span> rpos<span class="hljs-literal">[MAXRC+<span class="hljs-number">1</span>]</span>;<span class="hljs-comment">//每行第一个非零元素在data数组中的位置</span><br>    <span class="hljs-built_in">int</span> mu,nu,tu;<span class="hljs-comment">//行数，列数，元素个数</span><br>&#125;RLSMatrix;<br><span class="hljs-comment">//矩阵的输出函数</span><br>void display(RLSMatrix M)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>mu;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>nu;j++)&#123;<br>            <span class="hljs-built_in">int</span> value=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span> &lt;=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>mu)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>rpos<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;k&lt;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>rpos<span class="hljs-literal">[<span class="hljs-identifier">i</span>+<span class="hljs-number">1</span>]</span>;k++)&#123;<br>                    <span class="hljs-keyword">if</span>(i<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>.i<span class="hljs-operator"> &amp;&amp; </span>j<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>.j)&#123;<br>                        printf(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>.e);<br>                        value=<span class="hljs-number">1</span>;<br>                        break;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(value==<span class="hljs-number">0</span>)&#123;<br>                        printf(<span class="hljs-string">&quot;0 &quot;</span>);<br>                    &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>rpos<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;k&lt;=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>tu;k++)&#123;<br>                    <span class="hljs-keyword">if</span>(i<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>.i<span class="hljs-operator"> &amp;&amp; </span>j<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>.j)&#123;<br>                        printf(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>.e);<br>                        value=<span class="hljs-number">1</span>;<br>                        break;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(value==<span class="hljs-number">0</span>)&#123;<br>                    printf(<span class="hljs-string">&quot;0 &quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-built_in">int</span> main(<span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span>* argv<span class="hljs-literal">[]</span>)<br>&#123;<br>    RLSMatrix M;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>tu = <span class="hljs-number">4</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>mu = <span class="hljs-number">3</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>nu = <span class="hljs-number">4</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>rpos<span class="hljs-literal">[<span class="hljs-number">1</span>]</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>rpos<span class="hljs-literal">[<span class="hljs-number">2</span>]</span> = <span class="hljs-number">3</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>rpos<span class="hljs-literal">[<span class="hljs-number">3</span>]</span> = <span class="hljs-number">4</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>.e = <span class="hljs-number">3</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>.i = <span class="hljs-number">1</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>.j = <span class="hljs-number">2</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>.e = <span class="hljs-number">5</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>.i = <span class="hljs-number">1</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>.j = <span class="hljs-number">4</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>.e = <span class="hljs-number">1</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>.i = <span class="hljs-number">2</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>.j = <span class="hljs-number">3</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">4</span>]</span>.e = <span class="hljs-number">2</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">4</span>]</span>.i = <span class="hljs-number">3</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">4</span>]</span>.j = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//输出矩阵</span><br>    display(M);<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="十字链表法"><a href="#十字链表法" class="headerlink" title="十字链表法"></a>十字链表法</h4><p>该存储方式采用的是 “链表+数组” 结构，矩阵中的各行各列都各用一各链表存储，与此同时，所有行链表的表头存储到一个数组（rhead），所有列链表的表头存储到另一个数组（chead）中。</p><p>链表中节点的 C 语言代码表示应为：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OLNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> i,j;<span class="hljs-comment">//元素的行标和列标</span><br>    <span class="hljs-keyword">int</span> data;<span class="hljs-comment">//元素的值</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OLNode</span> * <span class="hljs-title">right</span>,*<span class="hljs-title">down</span>;</span><span class="hljs-comment">//两个指针域</span><br>&#125;OLNode;<br></code></pre></div></td></tr></table></figure><p>同时，表示十字链表结构的 C 语言代码应为：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span>&lt;stdio.h&gt;<br>#<span class="hljs-keyword">include</span>&lt;stdlib.h&gt;<br>typedef <span class="hljs-keyword">struct</span> OLNode<br>&#123;<br>    <span class="hljs-built_in">int</span> i, j, e; <span class="hljs-comment">//矩阵三元组i代表行 j代表列 e代表当前位置的数据</span><br>    <span class="hljs-keyword">struct</span> OLNode *right, *down; <span class="hljs-comment">//指针域 右指针 下指针</span><br>&#125;OLNode, *OLink;<br>typedef <span class="hljs-keyword">struct</span><br>&#123;<br>    OLink *rhead, *chead; <span class="hljs-comment">//行和列链表头指针</span><br>    <span class="hljs-built_in">int</span> mu, nu, tu;  <span class="hljs-comment">//矩阵的行数,列数和非零元的个数</span><br>&#125;CrossList;<br>CrossList <span class="hljs-constructor">CreateMatrix_OL(CrossList M)</span>;<br>void display(CrossList M);<br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span><br>&#123;<br>    CrossList M;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>rhead = NULL;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>chead = NULL;<br>    M = <span class="hljs-constructor">CreateMatrix_OL(M)</span>;<br>    printf(<span class="hljs-string">&quot;输出矩阵M:\n&quot;</span>);<br>    display(M);<br>    return <span class="hljs-number">0</span>;<br>&#125;<br>CrossList <span class="hljs-constructor">CreateMatrix_OL(CrossList M)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> m, n, t;<br>    <span class="hljs-built_in">int</span> i, j, e;<br>    OLNode *p, *q;<br>    printf(<span class="hljs-string">&quot;输入矩阵的行数、列数和非0元素个数：&quot;</span>);<br>    scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;m, &amp;n, &amp;t);<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>mu = m;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>nu = n;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>tu = t;<br>    <span class="hljs-keyword">if</span> (!(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>rhead = (OLink*)malloc((m + <span class="hljs-number">1</span>)<span class="hljs-operator"> * </span>sizeof(OLink)))<span class="hljs-operator"> || </span>!(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>chead = (OLink*)malloc((n + <span class="hljs-number">1</span>)<span class="hljs-operator"> * </span>sizeof(OLink))))<br>    &#123;<br>        printf(<span class="hljs-string">&quot;初始化矩阵失败&quot;</span>);<br>        exit(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>rhead<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = NULL;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>    &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>chead<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = NULL;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;i, &amp;j, &amp;e); <span class="hljs-number">0</span> != i; scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;i, &amp;j, &amp;e)) &#123;<br>        <span class="hljs-keyword">if</span> (!(p = (OLNode*)malloc(sizeof(OLNode))))<br>        &#123;<br>            printf(<span class="hljs-string">&quot;初始化三元组失败&quot;</span>);<br>            exit(<span class="hljs-number">0</span>);<br>        &#125;<br>        p-&gt;i = i;<br>        p-&gt;j = j;<br>        p-&gt;e = e;<br>        <span class="hljs-comment">//链接到行的指定位置</span><br>        <span class="hljs-keyword">if</span> (NULL<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>rhead<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-operator"> || </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>rhead<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>-&gt;j &gt; j)<br>        &#123;<br>            p-&gt;right = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>rhead<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>rhead<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = p;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (q = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>rhead<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>; (q-&gt;right)<span class="hljs-operator"> &amp;&amp; </span>q-&gt;right-&gt;j &lt; j; q = q-&gt;right);<br>            p-&gt;right = q-&gt;right;<br>            q-&gt;right = p;<br>        &#125;<br>        <span class="hljs-comment">//链接到列的指定位置</span><br>        <span class="hljs-keyword">if</span> (NULL<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>chead<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span><span class="hljs-operator"> || </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>chead<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>-&gt;i &gt; i)<br>        &#123;<br>            p-&gt;down = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>chead<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>chead<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = p;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (q = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>chead<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>; (q-&gt;down)<span class="hljs-operator"> &amp;&amp; </span>q-&gt;down-&gt;i &lt; i; q = q-&gt;down);<br>            p-&gt;down = q-&gt;down;<br>            q-&gt;down = p;<br>        &#125;<br>    &#125;<br>    return M;<br>&#125;<br>void display(CrossList M) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>nu; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (NULL != <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>chead<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)<br>        &#123;<br>            OLink p = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>chead<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>            <span class="hljs-keyword">while</span> (NULL != p)<br>            &#123;<br>                printf(<span class="hljs-string">&quot;%d\t%d\t%d\n&quot;</span>, p-&gt;i, p-&gt;j, p-&gt;e);<br>                p = p-&gt;down;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">输入矩阵的行数、列数和非0元素个数：3<span class="hljs-number"> 3 </span>3<br>2<span class="hljs-number"> 2 </span>3<br>2<span class="hljs-number"> 3 </span>4<br>3<span class="hljs-number"> 2 </span>5<br>0<span class="hljs-number"> 0 </span>0<br>输出矩阵M:<br>2      <span class="hljs-number"> 2 </span>      3<br>3      <span class="hljs-number"> 2 </span>      5<br>2      <span class="hljs-number"> 3 </span>      4<br></code></pre></div></td></tr></table></figure><h4 id="矩阵（稀疏矩阵）的转置算法"><a href="#矩阵（稀疏矩阵）的转置算法" class="headerlink" title="矩阵（稀疏矩阵）的转置算法"></a>矩阵（稀疏矩阵）的转置算法</h4><p>矩阵转置的实现思路是：不断遍历存储矩阵的三元组表，每次都取出表中 j 列最小的那一个三元组，互换行标和列标的值，并按次序存储到一个新三元组表中。</p><p>矩阵转置的实现过程需完成以下 3 步：</p><p>将矩阵的行数和列数互换；<br>将三元组表（存储矩阵）中的 i 列和 j 列互换，实现矩阵的转置；<br>以 j 列为序，重新排列三元组表中存储各三元组的先后顺序；</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span>&lt;stdio.h&gt;<br>#define number <span class="hljs-number">10</span><br>typedef <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-built_in">int</span> i,j;<br>    <span class="hljs-built_in">int</span> data;<br>&#125;triple;<br>typedef <span class="hljs-keyword">struct</span> &#123;<br>    triple data<span class="hljs-literal">[<span class="hljs-identifier">number</span>]</span>;<br>    <span class="hljs-built_in">int</span> n,m,num;<br>&#125;TSMatrix;<br>TSMatrix transpose<span class="hljs-constructor">Matrix(TSMatrix M,TSMatrix T)</span>&#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>m=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>n;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>n=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>m;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>num=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>num;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>num) &#123;<br>        <span class="hljs-built_in">int</span> q=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col=<span class="hljs-number">1</span>;col&lt;=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>m; col++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> p=<span class="hljs-number">0</span>; p&lt;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>num; p++) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">p</span>]</span>.j==col) &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">q</span>]</span>.i=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">p</span>]</span>.j;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">q</span>]</span>.j=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">p</span>]</span>.i;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">q</span>]</span>.data=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">p</span>]</span>.data;<br>                    q++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    return T;<br>&#125;<br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span> &#123;<br>    TSMatrix M;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>m=<span class="hljs-number">2</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>n=<span class="hljs-number">3</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>num=<span class="hljs-number">4</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.i=<span class="hljs-number">1</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.j=<span class="hljs-number">2</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.data=<span class="hljs-number">1</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>.i=<span class="hljs-number">2</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>.j=<span class="hljs-number">2</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>.data=<span class="hljs-number">3</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>.i=<span class="hljs-number">3</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>.j=<span class="hljs-number">1</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>.data=<span class="hljs-number">6</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>.i=<span class="hljs-number">3</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>.j=<span class="hljs-number">2</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">M</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>.data=<span class="hljs-number">5</span>;<br>    TSMatrix T;<br>    T=transpose<span class="hljs-constructor">Matrix(M, T)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>num; i++) &#123;<br>        printf(<span class="hljs-string">&quot;(%d,%d,%d)\n&quot;</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.i,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.j,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">T</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.data);<br>    &#125;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序运行结果为：</p><figure class="highlight clojure"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clojure">(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)<br>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<br></code></pre></div></td></tr></table></figure><p>由于此算法中嵌套使用了两个 for 循环，时间复杂度为 O(n2)。</p><h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><p>广义表，又称列表，也是一种线性存储结构。</p><p>同数组类似，广义表中既可以存储不可再分的元素，也可以存储广义表，记作：<br>LS = (a1,a2,…,an)</p><p>其中，LS 代表广义表的名称，an 表示广义表存储的数据。广义表中每个 ai 既可以代表单个元素，也可以代表另一个广义表。</p><p><strong>原子和子表</strong></p><p>通常，广义表中存储的单个元素称为 “原子”，而存储的广义表称为 “子表”。</p><p>例如创建一个广义表LS = {1,{1,2,3}}，我们可以这样解释此广义表的构成：广义表 LS 存储了一个原子 1 和子表 {1,2,3}。</p><p>以下是广义表存储数据的一些常用形式：</p><p>A = ()：A 表示一个广义表，只不过表是空的。<br>B = (e)：广义表 B 中只有一个原子 e。<br>C = (a,(b,c,d)) ：广义表 C 中有两个元素，原子 a 和子表 (b,c,d)。<br>D = (A,B,C)：广义表 D 中存有 3 个子表，分别是A、B和C。这种表示方式等同于 D = ((),(e),(b,c,d)) 。<br>E = (a,E)：广义表 E 中有两个元素，原子 a 和它本身。这是一个递归广义表，等同于：E = (a,(a,(a,…)))。</p><p>注意，A = () 和 A = (()) 是不一样的。前者是空表，而后者是包含一个子表的广义表，只不过这个子表是空表。</p><p><strong>广义表的表头和表尾</strong></p><p>当广义表不是空表时，称第一个数据（原子或子表）为”表头”，剩下的数据构成的新广义表为”表尾”。<br>强调一下，除非广义表为空表，否则广义表一定具有表头和表尾，且广义表的表尾一定是一个广义表。</p><p>例如在广义表中LS={1,{1,2,3},5}  中，表头为原子 1，表尾为子表 {1,2,3} 和原子 5 构成的广义表，即 {{1,2,3},5}。再比如，在广义表 LS = {1} 中，表头为原子 1 ，但由于广义表中无表尾元素，因此该表的表尾是一个空表，用{} 表示。### 广义表的存储结构（两种方式）由于广义表中可同时存储原子和子表两种形式的数据，因此链表节点的结构也有两种，如图 1 所示： 广义表节点的两种类型图 1 广义表节点的两种类型如图 1 所示，表示原子的节点由两部分构成，分别是 tag 标记位和原子的值，表示子表的节点由三部分构成，分别是 tag 标记位、hp 指针和 tp 指针。tag 标记位用于区分此节点是原子还是子表，通常原子的 tag 值为 0，子表的 tag 值为 1。子表节点中的 hp 指针用于连接本子表中存储的原子或子表，tp 指针用于连接广义表中下一个原子或子表。因此，广义表中两种节点的 C 语言表示代码为：<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> tag;<span class="hljs-comment">//标志域</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span><br>        <span class="hljs-keyword">char</span> atom;<span class="hljs-comment">//原子结点的值域</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span> * <span class="hljs-title">hp</span>,*<span class="hljs-title">tp</span>;</span><br>        &#125;ptr;<span class="hljs-comment">//子表结点的指针域，hp指向表头；tp指向表尾</span><br>    &#125;;<br>&#125;*Glist;<br></code></pre></div></td></tr></table></figure>这里用到了 union 共用体，因为同一时间此节点不是原子节点就是子表节点，当表示原子节点时，就使用 atom 变量；反之则使用 ptr 结构体。例如，广义表 {a,{b,c,d}} 是由一个原子 a 和子表 {b,c,d} 构成，而子表 {b,c,d} 又是由原子 b、c 和 d 构成，用链表存储该广义表如图 2 所示：</p><p>广义表 {a,{b,c,d}} 的结构示意图<br>图 2 广义表 {a,{b,c,d}} 的结构示意图</p><p>图 2 可以看到，存储原子 a、b、c、d 时都是用子表包裹着表示的，因为原子 a 和子表 {b,c,d} 在广义表中同属一级，而原子 b、c、d 也同属一级。</p><p>图 2 中链表存储的广义表用 C  语言代码表示为：</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl">Glist creatGlist(Glist C)&#123;<br>    <span class="hljs-comment">//广义表C</span><br>    C=(Glist)malloc(sizeof(Glist));<br>    C-&gt;tag=<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//表头原子‘a’</span><br>    C-&gt;ptr.hp=(Glist)malloc(sizeof(Glist));<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>tag=<span class="hljs-number">0</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>atom=<span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-comment">//表尾子表（b,c,d）,是一个整体</span><br>    C-&gt;ptr.tp=(Glist)malloc(sizeof(Glist));<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>tag=<span class="hljs-number">1</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>ptr.hp=(Glist)malloc(sizeof(Glist));<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>ptr.tp=NULL;<br>    <span class="hljs-comment">//开始存放下一个数据元素（b,c,d）,表头为‘b’，表尾为（c,d）</span><br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>tag=<span class="hljs-number">1</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>ptr.hp=(Glist)malloc(sizeof(Glist));<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>tag=<span class="hljs-number">0</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>atom=<span class="hljs-string">&#x27;b&#x27;</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>ptr.tp=(Glist)malloc(sizeof(Glist));<br>    <span class="hljs-comment">//存放子表(c,d)，表头为c，表尾为d</span><br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>tag=<span class="hljs-number">1</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>ptr.hp=(Glist)malloc(sizeof(Glist));<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>tag=<span class="hljs-number">0</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>atom=<span class="hljs-string">&#x27;c&#x27;</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>ptr.tp=(Glist)malloc(sizeof(Glist));<br>    <span class="hljs-comment">//存放表尾d</span><br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>tag=<span class="hljs-number">1</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>ptr.hp=(Glist)malloc(sizeof(Glist));<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>tag=<span class="hljs-number">0</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>atom=<span class="hljs-string">&#x27;d&#x27;</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>ptr.tp=NULL;<br>    return C;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>另一种广义表存储结构</p><p>如果你觉得图 2 这种存储广义表的方式不合理，可以使用另一套表示广义表中原子和子表结构的节点，如图 3 所示：</p><p>广义表的另一套节点结构<br>图 3 广义表的另一套节点结构</p><p>如图 3 所示，表示原子的节点构成由 tag 标记位、原子值和 tp 指针构成，表示子表的节点还是由 tag 标记位、hp 指针和 tp 指针构成。</p><p>图 3 的节点结构用 C 语言代码表示为：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> tag;<span class="hljs-comment">//标志域</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span><br>        <span class="hljs-keyword">int</span> atom;<span class="hljs-comment">//原子结点的值域</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span> *<span class="hljs-title">hp</span>;</span><span class="hljs-comment">//子表结点的指针域，hp指向表头</span><br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span> * <span class="hljs-title">tp</span>;</span><span class="hljs-comment">//这里的tp相当于链表的next指针，用于指向下一个数据元素</span><br>&#125;*Glist;<br></code></pre></div></td></tr></table></figure><p>采用图 3 中的节点结构存储广义表 {a,{b,c,d}} 的示意图如图 4 所示：</p><p>图 4 存储广义表对应的 C 语言代码为：</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl">Glist creatGlist(Glist C)&#123;<br>    C=(Glist)malloc(sizeof(Glist));<br>    C-&gt;tag=<span class="hljs-number">1</span>;<br>    C-&gt;hp=(Glist)malloc(sizeof(Glist));<br>    C-&gt;tp=NULL;<br>    <span class="hljs-comment">//表头原子a</span><br>    C-&gt;<span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span>tag=<span class="hljs-number">0</span>;<br>    C-&gt;atom=<span class="hljs-string">&#x27;a&#x27;</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span>tp=(Glist)malloc(sizeof(Glist));<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span>tag=<span class="hljs-number">1</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span>hp=(Glist)malloc(sizeof(Glist));<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span>tp=NULL;<br>    <span class="hljs-comment">//原子b</span><br>    C-&gt;<span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span>tag=<span class="hljs-number">0</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span>atom=<span class="hljs-string">&#x27;b&#x27;</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span>tp=(Glist)malloc(sizeof(Glist));<br>    <span class="hljs-comment">//原子c</span><br>    C-&gt;<span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span>tag=<span class="hljs-number">0</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span>atom=<span class="hljs-string">&#x27;c&#x27;</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span>tp=(Glist)malloc(sizeof(Glist));<br>    <span class="hljs-comment">//原子d</span><br>    C-&gt;<span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span>tag=<span class="hljs-number">0</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span>atom=<span class="hljs-string">&#x27;d&#x27;</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">hp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tp</span>-&gt;</span>tp=NULL;<br>    return C;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="广义表的复制"><a href="#广义表的复制" class="headerlink" title="广义表的复制"></a>广义表的复制</h3><p>对于任意一个非空广义表来说，都是由两部分组成：表头和表尾。反之，只要确定的一个广义表的表头和表尾，那么这个广义表就可以唯一确定下来。</p><p>复制一个广义表，也是不断的复制表头和表尾的过程。如果表头或者表尾同样是一个广义表，依旧复制其表头和表尾。</p><p>所以，复制广义表的过程，其实就是不断的递归，复制广义表中表头和表尾的过程。</p><p>递归的出口有两个：</p><p>如果当前遍历的数据元素为空表，则直接返回空表。<br>如果当前遍历的数据元素为该表的一个原子，那么直接复制，返回即可。</p><p>代码实现：</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>typedef struct GLNode&#123;<br>    int tag;<span class="hljs-comment">//标志域</span><br>    union&#123;<br>        char atom;<span class="hljs-comment">//原子结点的值域</span><br>        struct&#123;<br>            struct GLNode * hp,*tp;<br>        &#125;ptr;<span class="hljs-comment">//子表结点的指针域，hp指向表头；tp指向表尾</span><br>    &#125;;<br>&#125;*Glist,GNode;<br>Glist creatGlist(Glist C)&#123;<br>    <span class="hljs-comment">//广义表C</span><br>    C=(Glist)malloc(sizeof(GNode));<br>    C-&gt;tag=<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//表头原子‘a’</span><br>    C-&gt;ptr.hp=(Glist)malloc(sizeof(GNode));<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>tag=<span class="hljs-number">0</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>atom=<span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-comment">//表尾子表（b,c,d）,是一个整体</span><br>    C-&gt;ptr.tp=(Glist)malloc(sizeof(GNode));<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>tag=<span class="hljs-number">1</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>ptr.hp=(Glist)malloc(sizeof(GNode));<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>ptr.tp=NULL;<br>    <span class="hljs-comment">//开始存放下一个数据元素（b,c,d）,表头为‘b’，表尾为（c,d）</span><br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>tag=<span class="hljs-number">1</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>ptr.hp=(Glist)malloc(sizeof(GNode));<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>tag=<span class="hljs-number">0</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>atom=<span class="hljs-string">&#x27;b&#x27;</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>ptr.tp=(Glist)malloc(sizeof(GNode));<br>    <span class="hljs-comment">//存放子表(c,d)，表头为c，表尾为d</span><br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>tag=<span class="hljs-number">1</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>ptr.hp=(Glist)malloc(sizeof(GNode));<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>tag=<span class="hljs-number">0</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>atom=<span class="hljs-string">&#x27;c&#x27;</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>ptr.tp=(Glist)malloc(sizeof(GNode));<br>    <span class="hljs-comment">//存放表尾d</span><br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>tag=<span class="hljs-number">1</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>ptr.hp=(Glist)malloc(sizeof(GNode));<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>tag=<span class="hljs-number">0</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>atom=<span class="hljs-string">&#x27;d&#x27;</span>;<br>    C-&gt;<span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp-&gt;</span>ptr.tp=NULL;<br>    return C;<br>&#125;<br>void copyGlist(Glist C, Glist *T)&#123;<br>    <span class="hljs-comment">//如果C为空表，那么复制表直接为空表 </span><br>    <span class="hljs-keyword">if</span> (!C) &#123;<br>        *T=NULL;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        *T=(Glist)malloc(sizeof(GNode));<span class="hljs-comment">//C不是空表，给T申请内存空间</span><br>        <span class="hljs-comment">//申请失败，程序停止</span><br>        <span class="hljs-keyword">if</span> (!*T) &#123;<br>            exit(<span class="hljs-number">0</span>);<br>        &#125;<br>        (*T)-&gt;<span class="hljs-function"><span class="hljs-title">tag</span>=C-&gt;</span>tag;<span class="hljs-comment">//复制表C的tag值</span><br>        <span class="hljs-comment">//判断当前表元素是否为原子，如果是，直接复制</span><br>        <span class="hljs-function"><span class="hljs-title">if</span> (C-&gt;</span>tag==<span class="hljs-number">0</span>) &#123;<br>            (*T)-&gt;<span class="hljs-function"><span class="hljs-title">atom</span>=C-&gt;</span>atom;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//运行到这，说明复制的是子表</span><br>            <span class="hljs-function"><span class="hljs-title">copyGlist</span>(C-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp, &amp;((*T)-&gt;</span>ptr.hp));<span class="hljs-comment">//复制表头</span><br>            <span class="hljs-function"><span class="hljs-title">copyGlist</span>(C-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.tp, &amp;((*T)-&gt;</span>ptr.tp));<span class="hljs-comment">//复制表尾</span><br>        &#125;<br>    &#125;<br>&#125;<br>int main(int argc, const char * argv[]) &#123;<br>    Glist C=NULL;<br>    C=creatGlist(C);<br>    Glist T=NULL;<br>    copyGlist(C,&amp;T);<br>    <span class="hljs-function"><span class="hljs-title">printf</span>(&quot;%c&quot;,T-&gt;</span><span class="hljs-function"><span class="hljs-title">ptr</span>.hp-&gt;</span>atom);<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：a</p><p>总结</p><p>在实现复制广义表的过程中，实现函数为：</p><p><code>void copyGlist(Glist C, Glist *T);</code></p><p>其中，<code>Glist *T</code>，等同于: <code>struct GLNode* *T</code>，此为二级指针，不是一级指针。在主函数中，调用此函数时，传入的是指针 T 的地址，而不是 T 。</p><p>这里使用的是地址传递，而不是值传递。如果在这里使用值传递，会导致广义表 T 丢失结点，复制失败。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的遍历</title>
    <link href="/2020/06/data-structure05/"/>
    <url>/2020/06/data-structure05/</url>
    
    <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树存储结构"><a href="#树存储结构" class="headerlink" title="树存储结构"></a>树存储结构</h3><p>树的结点</p><p>结点：使用树结构存储的每一个数据元素都被称为“结点”。</p><p>父结点（双亲结点）、子结点和兄弟结点：有相同的父结点，所以互为兄弟结点。</p><p>树根结点（简称“根结点”）：每一个非空树都有且只有一个被称为根的结点。</p><p>树根的判断依据为：如果一个结点没有父结点，那么这个结点就是整棵树的根结点。</p><p>叶子结点：如果结点没有任何子结点，那么此结点称为叶子结点（叶结点）。</p><p>子树和空树</p><p>子树：如图 1（A）中，整棵树的根结点为结点 A，而如果单看结点 B、E、F、K、L 组成的部分来说，也是棵树，而且节点 B 为这棵树的根结点。所以称 B、E、F、K、L 这几个结点组成的树为整棵树的子树；同样，结点 E、K、L 构成的也是一棵子树，根结点为 E。</p><p>注意：单个结点也是一棵树，只不过根结点就是它本身。</p><p>知道了子树的概念后，树也可以这样定义：树是由根结点和若干棵子树构成的。</p><p>空树：如果集合本身为空，那么构成的树就被称为空树。空树中没有结点。</p><p>补充：在树结构中，对于具有同一个根结点的各个子树，相互之间不能有交集。如果有，就破坏了树的结构，不能算做是一棵树。</p><p>结点的度和层次</p><p>对于一个结点，拥有的子树数（结点有多少分支）称为结点的度（Degree）。例如，图 1（A）中，根结点 A 下分出了 3 个子树，所以，结点 A 的度为 3。<br>一棵树的度是树内各结点的度的最大值。图 1（A）表示的树中，各个结点的度的最大值为 3，所以，整棵树的度的值是 3。<br>结点的层次：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。对于图 1（A）来说，A 结点在第一层，B、C、D 为第二层，E、F、G、H、I、J 在第三层，K、L、M 在第四层。<br>一棵树的深度（高度）是树中结点所在的最大的层次。图 1（A）树的深度为 4。<br>如果两个结点的父结点虽不相同，但是它们的父结点处在同一层次上，那么这两个结点互为堂兄弟。例如，图 1（A）中，结点 G 和 E、F、H、I、J 的父结点都在第二层，所以之间为堂兄弟的关系。<br>有序树和无序树<br>如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树。<br>在有序树中，一个结点最左边的子树称为”第一个孩子”，最右边的称为”最后一个孩子”。<br>拿图 1（A）来说，如果是其本身是一棵有序树，则以结点 B 为根结点的子树为整棵树的第一个孩子，以结点 D 为根结点的子树为整棵树的最后一个孩子。</p><p>森林</p><p>由 m（m &gt;= 0）个互不相交的树组成的集合被称为森林。图 1（A）中，分别以 B、C、D 为根结点的三棵子树就可以称为森林。</p><p>前面讲到，树可以理解为是由根结点和若干子树构成的，而这若干子树本身是一个森林，所以，树还可以理解为是由根结点和森林组成的。用一个式子表示为：<br>Tree =（root,F）<br>其中，root 表示树的根结点，F 表示由 m（m &gt;= 0）棵树组成的森林。</p><p>树的表示方法</p><p>除了图 1（A）表示树的方法外，还有其他表示方法：</p><div class="hljs code-wrapper"><pre><code>      （A）                                         （B）</code></pre></div><p>图2 树的表示形式</p><p>图 2（A）是以嵌套的集合的形式表示的（集合之间绝不能相交，即图中任意两个圈不能相交）。</p><p>图 2（B）使用的是凹入表示法（了解即可），表示方式是：最长条为根结点，相同长度的表示在同一层次。例如 B、C、D 长度相同，都为 A 的子结点，E 和 F 长度相同，为 B 的子结点，K 和 L 长度相同，为 E 的子结点，依此类推。</p><p>最常用的表示方法是使用广义表的方式。图 1（A）用广义表表示为：<br>(A , ( B ( E ( K , L ) , F ) , C ( G ) , D ( H ( M ) , I , J ) ) )</p><h3 id="二叉树及其性质"><a href="#二叉树及其性质" class="headerlink" title="二叉树及其性质"></a>二叉树及其性质</h3><p>满足以下两个条件的树就是二叉树：<br>本身是有序树；<br>树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；</p><p>二叉树的性质<br>经过前人的总结，二叉树具有以下几个性质：<br>二叉树中，第 i 层最多有 2i-1 个结点。<br>如果二叉树的深度为 K，那么此二叉树最多有 2K-1 个结点。<br>二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。<br>性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n1），那么总结点 n=n0+n1+n2。<br>同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B=n1+2<em>n2。所以，n 用另外一种方式表示为 n=n1+2</em>n2+1。<br>两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1。</p><p>二叉树还可以继续分类，衍生出满二叉树和完全二叉树。</p><p>满二叉树<br>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。</p><p>满二叉树示意图<br>图 2 满二叉树示意图</p><p>如图 2 所示就是一棵满二叉树。</p><p>满二叉树除了满足普通二叉树的性质，还具有以下性质：<br>满二叉树中第 i 层的节点数为 2n-1 个。<br>深度为 k 的满二叉树必有 2k-1 个节点 ，叶子数为 2k-1。<br>满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。<br>具有 n 个节点的满二叉树的深度为 log2(n+1)。</p><p>完全二叉树<br>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。</p><p>完全二叉树示意图<br>图 3 完全二叉树示意图</p><p>如图 3a) 所示是一棵完全二叉树，图 3b) 由于最后一层的节点没有按照从左向右分布，因此只能算作是普通的二叉树。</p><p>完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊log2n⌋+1。<br>⌊log2n⌋ 表示取小于 log2n 的最大整数。例如，⌊log24⌋ = 2，而 ⌊log25⌋ 结果也是 2。</p><p>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 3a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：<br>当 i&gt;1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）<br>如果 2*i&gt;n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2<em>i 。<br>如果 2*i+1&gt;n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2</em>i+1 。</p><h3 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h3><p>二叉树的顺序存储，指的是使用顺序表（数组）存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。换句话说，只有完全二叉树才可以使用顺序表存储。因此，如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树。</p><p>完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可。</p><h3 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h3><p>采用链式存储二叉树时，其节点结构由 3 部分构成（如图 3 所示）：<br>指向左孩子节点的指针（Lchild）；<br>节点存储的数据（data）；<br>指向右孩子节点的指针（Rchild）；</p><p>表示该节点结构的代码为：</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">typedef <span class="hljs-keyword">struct</span> <span class="hljs-type">BiTNode</span>&#123;<br>    TElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">BiTNode</span> *lchild,*rchild;<span class="hljs-comment">//左右孩子指针</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">BiTNode</span> *parent;<br>&#125;BiTNode,*BiTree;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的遍历</title>
    <link href="/2020/06/data-structure06/"/>
    <url>/2020/06/data-structure06/</url>
    
    <content type="html"><![CDATA[<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><hr>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的遍历</title>
    <link href="/2020/06/tree-traversal/"/>
    <url>/2020/06/tree-traversal/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式零宽断言</title>
    <link href="/2020/06/regexp-lookaround/"/>
    <url>/2020/06/regexp-lookaround/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【转】修改hosts有时不生效的原因和可能的解决办法</title>
    <link href="/2020/06/hosts-not-effect/"/>
    <url>/2020/06/hosts-not-effect/</url>
    
    <content type="html"><![CDATA[<p> <strong>Update:</strong></p><p>如果浏览器使用了代理工具，修改 Hosts 也不会生效。这里是因为，浏览器会优先考虑代理工具（如添加 pac 文件、SwitchySharp等）的代理，建议调试的时候先关闭这些代理。<br>使用 pac 文件代理有的时候部分文件的代理不生效，应该是 pac 对应的代理服务器上，做了部分处理。<br>部分浏览器也有 DNS 缓存，如 chrome(chrome://dns)，这是为什么重启浏览器也不生效的原因，一般设定时间为 60s (如 Firefox)。<br>浏览器有DNS缓存，系统也会存在 DNS 缓存，有的时候即便在 chrome://dns 清空了浏览器 DNS 缓存，依然不生效，是因为系统 DNS 缓存还未刷新，刷新方式可以看<a href="https://cnzhx.net/blog/how-to-flush-dns-cache-in-linux-windows-mac/">这篇文章</a>。</p><hr><p> 相信很多同学都在使用 SwitchHosts/iHosts/Gas Mask 等 Hosts 管理工具，当然也有人直接修改 /etc/hosts 或者 system32/drivers/etc/hosts 文件，而经常遇到的疑问是：咿，刚才不是修改并且保存了么，为何 Chrome 浏览器还不生效呢？</p><p>有人说重启下浏览器就好了，<br>有人说清空下缓存 DNS（chrome://net-internals/#DNS）就好了，<br>有人说隐私模式下打开就好了，<br>有人说等一分钟吧…<br>结果就是，进入隐私模式的都好了，重启、清空缓存DNS和等一分钟的同学还在继续纠结中。。。</p><p>上面提到的三个工具，SwitchHosts/iHosts/Gas Mask，其实也只有 iHosts 生效了(Mac下)。</p><p>开发过程中我们会无数次的切换 Hosts，如果不知道原理，我们在测试的时候还是很心惊胆战的=_=||</p><h3 id="修改Hosts不生效的根本原因"><a href="#修改Hosts不生效的根本原因" class="headerlink" title="修改Hosts不生效的根本原因"></a>修改Hosts不生效的根本原因</h3><p>因为服务器设置了 keep-alive ！次要原因是存在浏览器 DNS 缓存和系统 DNS 缓存。<a href="http://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5">Keep-alive 相关文档</a></p><p>服务器在响应头设置了 Connection: keep-alive （一般的网页都会设置 keep-alive，保持长连接，避免多次连接产生网络消耗）之后，客户端会跟服务器保持长连接，只要长连接不断开，页面在请求的时候就不会重新解析域名！</p><p>我们可以这样来测试：</p><ol><li><p>打开一个你至少两分钟没有打开的浏览器（你也可以关闭掉你的浏览器，然后重新打开，记得把所有的 tab 都关了，除了当前 tab ^_^）</p></li><li><p>在 hosts 添加 127.0.0.1 <a href="http://www.taobao.com/">www.taobao.com</a></p></li><li><p>新开 tab，打开 <a href="http://www.taobao.com,是不是进不去了/">www.taobao.com，是不是进不去了</a> &lt;这里说明 hosts 修改生效了&gt;</p></li><li><p>注释掉刚才hosts修改，# 127.0.0.1 <a href="http://www.taobao.com/">www.taobao.com</a> ，再打开 <a href="http://www.taobao.com,很好,正常打开了/">www.taobao.com，很好，正常打开了</a> &lt;这里说明 hosts 修改也生效了&gt;</p></li><li><p>去掉注释符，127.0.0.1 <a href="http://www.taobao.com/">www.taobao.com</a> ，再打开 <a href="http://www.taobao.com,依然可以访问!!!/">www.taobao.com，依然可以访问！！！</a></p></li><li><p>Chrome 中进入 chrome://net-internals/#sockets，</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p><p>可以看到淘宝首页中很多域名都是与服务器保持着长连接，点击上方的 close idle sockets 按钮，可以关闭所有的长连接</p></li><li><p>此时，再去访问 <a href="http://www.taobao.com,是不是进不去了!/">www.taobao.com，是不是进不去了！</a></p></li></ol><h3 id="为何一些修改可以让-“Hosts-生效”"><a href="#为何一些修改可以让-“Hosts-生效”" class="headerlink" title="为何一些修改可以让 “Hosts 生效”"></a>为何一些修改可以让 “Hosts 生效”</h3><ol><li><p>重启浏览器<br>重启浏览器之后，所有的连接（包括长连接）都会断开，自然就生效了</p></li><li><p>隐私模式打开<br>因为隐私模式下不会复用 TCP 连接，新开连接的时候，会重新解析 DNS 域名，自然也生效了</p></li><li><p>iHosts 管理器在 Mac 下生效<br>因为我在 Windows 下测试过，貌似没有立即生效。问了 iHosts 的作者@必隆，他告诉我，在修改 hosts 文件的时候，会重启网络服务，这个时候必然会断开所有的 TCP 连接（重启网络服务，差不多相当于先断网再联网…)</p></li><li><p>修改之后，等一会儿…<br>“等一会儿”，要稍微等久一点，keep-alive 的默认设置是 120s，开发者也有可能增大或者减小这个配置，所以“等一会儿”也是很伤神的=。 =</p></li></ol><p>看到这里，你对其中的原理是否有所了解了呢？</p><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><p><a href="https://www.cnblogs.com/hustskyking/p/hosts-modify.html">修改Hosts为何不生效，是DNS缓存？——Barret李靖</a></p>]]></content>
    
    
    <categories>
      
      <category>杂类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hosts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】LocalStorage过期删除</title>
    <link href="/2020/06/localstorage-expire/"/>
    <url>/2020/06/localstorage-expire/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>浏览器端需要存储一个用户的标识和<code>cookie</code>一样需要过期时间，但是用的是<code>localStorage</code>存储。而<code>localStorage</code>一经存储除非手动删除是不会过期的。那就需要自己实现过期机制。网上找了几种简单的方法。</p><h2 id="方案一：ES5扩展Storage"><a href="#方案一：ES5扩展Storage" class="headerlink" title="方案一：ES5扩展Storage"></a>方案一：ES5扩展Storage</h2><p>思路很简单，存储的值加一个时间戳，下次取值时验证时间戳。<br><strong>注意：</strong> <code>localStorage</code>只能存储字符，存入时将对象转为<code>json</code>字符串,读取时也要解析</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">CopyStorage.prototype.setExpire = <span class="hljs-function">(<span class="hljs-params">key, value, expire</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">let</span> obj = &#123;<br>data: value,<br>time: <span class="hljs-built_in">Date</span>.now(),<br>expire: expire<br>&#125;;<br><span class="hljs-comment">//localStorage 设置的值不能为对象,转为json字符串</span><br><span class="hljs-built_in">localStorage</span>.setItem(key, <span class="hljs-built_in">JSON</span>.stringify(obj));<br>&#125;<br><br>Storage.prototype.getExpire = <span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> val = <span class="hljs-built_in">localStorage</span>.getItem(key);<br>    <span class="hljs-keyword">if</span> (!val) &#123;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>    val = <span class="hljs-built_in">JSON</span>.parse(val);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Date</span>.now() - val.time &gt; val.expire) &#123;<br>        <span class="hljs-built_in">localStorage</span>.removeItem(key);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> val.data;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>测试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">CopylocalStorage.setExpire(<span class="hljs-string">&#x27;userId&#x27;</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-number">5000</span>);<br><span class="hljs-built_in">window</span>.setInterval(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">localStorage</span>.getExpire(<span class="hljs-string">&quot;userId&quot;</span>));<br>&#125;,<span class="hljs-number">1000</span>)<br></code></pre></div></td></tr></table></figure><p>前5秒还是有值的，之后即为<code>null</code></p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="image"></p><h2 id="方案二：ES6扩展Storage"><a href="#方案二：ES6扩展Storage" class="headerlink" title="方案二：ES6扩展Storage"></a>方案二：ES6扩展Storage</h2><p>大体思路和方案一是一样的只不过是用了ES6的最新语法实现。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">Copyclass Storage &#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.props = props || &#123;&#125;<br>        <span class="hljs-built_in">this</span>.source = <span class="hljs-built_in">this</span>.props.source || <span class="hljs-built_in">window</span>.localStorage<br>        <span class="hljs-built_in">this</span>.initRun();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">initRun</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * set 存储方法</span><br><span class="hljs-comment">        * @ param &#123;String&#125;     key 键</span><br><span class="hljs-comment">        * @ param &#123;String&#125;     value 值，存储的值可能是数组/对象，不能直接存储，需要转换 JSON.stringify</span><br><span class="hljs-comment">        * @ param &#123;String&#125;     expired 过期时间，以分钟为单位</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">const</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;__expires__&quot;</span>);<br>        <span class="hljs-keyword">let</span> data = <span class="hljs-built_in">this</span>.source;<br>        <span class="hljs-keyword">let</span> list = <span class="hljs-built_in">Object</span>.keys(data);<br>        <span class="hljs-keyword">if</span>(list.length &gt; <span class="hljs-number">0</span>)&#123;<br>            list.map(<span class="hljs-function">(<span class="hljs-params">key,v</span>)=&gt;</span>&#123;<br>                <span class="hljs-keyword">if</span>( !reg.test(key ))&#123;<br>                    <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now();<br>                    <span class="hljs-keyword">let</span> expires = data[<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>__expires__`</span>]||<span class="hljs-built_in">Date</span>.now+<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (now &gt;= expires ) &#123;<br>                        <span class="hljs-built_in">this</span>.remove(key);<br>                    &#125;;<br>                &#125;;<br>                <span class="hljs-keyword">return</span> key;<br>            &#125;);<br>        &#125;;<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">key, value, expired</span>)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * set 存储方法</span><br><span class="hljs-comment">    * @ param &#123;String&#125;     key 键</span><br><span class="hljs-comment">    * @ param &#123;String&#125;     value 值，</span><br><span class="hljs-comment">    * @ param &#123;String&#125;     expired 过期时间，以毫秒为单位，非必须</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">let</span> source = <span class="hljs-built_in">this</span>.source;<br>    source[key] = <span class="hljs-built_in">JSON</span>.stringify(value);<br>    <span class="hljs-keyword">if</span> (expired)&#123;<br>        source[<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>__expires__`</span>] = <span class="hljs-built_in">Date</span>.now() + expired<br>    &#125;;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">key</span>)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * get 获取方法</span><br><span class="hljs-comment">        * @ param &#123;String&#125;     key 键</span><br><span class="hljs-comment">        * @ param &#123;String&#125;     expired 存储时为非必须字段，所以有可能取不到，默认为 Date.now+1</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">const</span> source = <span class="hljs-built_in">this</span>.source,<br>        expired = source[<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>__expires__`</span>]||<span class="hljs-built_in">Date</span>.now+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">const</span> now = <span class="hljs-built_in">Date</span>.now();<br>    <br>        <span class="hljs-keyword">if</span> ( now &gt;= expired ) &#123;<br>            <span class="hljs-built_in">this</span>.remove(key);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">const</span> value = source[key] ? <span class="hljs-built_in">JSON</span>.parse(source[key]) : source[key];<br>        <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">key</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">this</span>.source,<br>        value = data[key];<br>    <span class="hljs-keyword">delete</span> data[key];<br>    <span class="hljs-keyword">delete</span> data[<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>__expires__`</span>];<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>set()</code>,<code>get()</code>,<code>remove()</code>方法可以理解用来存、取、删, <code>initRun()</code>做什么用呢？过期的值只有取时才能知道是不是过期，不取一直存着。<code>initRun()</code>和<code>constructor</code>只是在初始化时实现清理，也不是一定即时。另外写一个定时器去清理貌似也不值当，所以觉得做到这样已经够用了。</p><p>使用如下代码进行测试一下,效果和方案一相同</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">Copyvar ls=<span class="hljs-keyword">new</span> Storage();<br>ls.set(<span class="hljs-string">&#x27;userId&#x27;</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-number">5000</span>);<br><span class="hljs-built_in">window</span>.setInterval(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(ls.get(<span class="hljs-string">&quot;userId&quot;</span>));<br>&#125;,<span class="hljs-number">1000</span>)<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/qq_20343517/article/details/83656450">localStorage 设置过期时间</a></li><li><a href="https://segmentfault.com/a/1190000016892019">如何给localStorage设置一个过期时间？</a></li><li>原文链接：<a href="https://www.cnblogs.com/ricolee/p/localstorage-expiretime.html">localStorage设置过期时间</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>LocalStorage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式获取图片src</title>
    <link href="/2020/06/regexp-img-src/"/>
    <url>/2020/06/regexp-img-src/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>regexp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记仇生成器</title>
    <link href="/2020/06/jichou/"/>
    <url>/2020/06/jichou/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>奇奇怪怪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>奇奇怪怪</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>富文本编辑器 Summernote 从入门到放弃（文档篇）</title>
    <link href="/2020/05/summernote-doc/"/>
    <url>/2020/05/summernote-doc/</url>
    
    <content type="html"><![CDATA[<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h3><h3 id="i18n支持"><a href="#i18n支持" class="headerlink" title="i18n支持"></a>i18n支持</h3><h3 id="第三方支持"><a href="#第三方支持" class="headerlink" title="第三方支持"></a>第三方支持</h3><h2 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h2><h3 id="初始化选项"><a href="#初始化选项" class="headerlink" title="初始化选项"></a>初始化选项</h3><h3 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h3><h3 id="字体样式API"><a href="#字体样式API" class="headerlink" title="字体样式API"></a>字体样式API</h3><h3 id="段落API"><a href="#段落API" class="headerlink" title="段落API"></a>段落API</h3><h3 id="插入内容API"><a href="#插入内容API" class="headerlink" title="插入内容API"></a>插入内容API</h3><h3 id="范围和选择API"><a href="#范围和选择API" class="headerlink" title="范围和选择API"></a>范围和选择API</h3><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><h3 id="自定义按钮"><a href="#自定义按钮" class="headerlink" title="自定义按钮"></a>自定义按钮</h3><h2 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h2><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><h3 id="轻巧模式"><a href="#轻巧模式" class="headerlink" title="轻巧模式"></a>轻巧模式</h3><h3 id="使用多个编辑器"><a href="#使用多个编辑器" class="headerlink" title="使用多个编辑器"></a>使用多个编辑器</h3><h3 id="点击编辑"><a href="#点击编辑" class="headerlink" title="点击编辑"></a>点击编辑</h3><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><h4 id="词语提示"><a href="#词语提示" class="headerlink" title="词语提示"></a>词语提示</h4><h4 id="表情提示"><a href="#表情提示" class="headerlink" title="表情提示"></a>表情提示</h4><h4 id="选择提示"><a href="#选择提示" class="headerlink" title="@选择提示"></a>@选择提示</h4><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://summernote.org/">Summernote</a></p><p><a href="https://www.bootstrap-table.com.cn/">Bootstrap Table中文网</a></p><p><a href="https://www.cnblogs.com/landeanfen/p/4976838.html">JS组件系列——表格组件神器：bootstrap table</a></p><p><a href="https://www.jianshu.com/p/b9d0f0935263">表格神器bootstraptable</a></p><p><a href="https://blog.csdn.net/S_clifftop/article/details/77937356">Bootstrap Table API 中文版（完整翻译文档）</a></p><p><a href="https://blog.csdn.net/sky_sunshine_x/article/details/80985097">富文本编辑器summernote的基本使用（自定义行高字体属性）</a></p><p><a href="https://www.xuexiareas.com/index/Articles/details/num/13.html">富文本编辑器之图片上传删除问题</a></p><p><a href="http://tinymce.ax-z.cn/">http://tinymce.ax-z.cn/</a></p>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>HTML</tag>
      
      <tag>JS</tag>
      
      <tag>富文本编辑器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;p&gt;不能嵌套&lt;div&gt;</title>
    <link href="/2020/05/p-div/"/>
    <url>/2020/05/p-div/</url>
    
    <content type="html"><![CDATA[<p>这是很久以前写网页碰到的事了，当时查到解决方法以后就草草过去了，今天突然想起来觉得还是记一下比较好。</p><p>复现一下当时的问题：</p><p>我在一个<code>&lt;p&gt;</code>内放了一个<code>&lt;div&gt;</code>标签，代码是这么写的：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span> 这是最外面的一个div，套个颜色好区分<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>这是一个p标签<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这是p标签里面包含的div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>CSS是这么写的：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-id">#test</span> &#123;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">600px</span>;<br><span class="hljs-attribute">background-color</span>:yellow;<br>&#125;<br><span class="hljs-selector-id">#test</span> <span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">150px</span>;<br><span class="hljs-attribute">background-color</span>:red;<br>&#125;<br><span class="hljs-selector-id">#test</span> <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">80px</span>;<br><span class="hljs-attribute">background-color</span>:blue;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后当我在浏览器里打开这个网页的时候，发现显示出来是这个样的：</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p><p>嗯？好像哪不对？里面的div不应该是蓝色的吗，赶紧到控制台查看元素，发现更不对了：</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p><p>为什么div跑到p外面了，为什么div下面还有个空的p？吓得我赶紧在里面又放了个<code>&lt;span&gt;</code>试试，一试好像没什么问题，但是div的位置依旧不对劲，这是怎么肥四？？我记得p和div都是块级标签，应该是可以互相嵌套的啊，想了半天没想通之后我去查了些资料，终于搞明白原来有的块元素不能包含另一些块元素。</p><p>而且根据新的HTML规范，元素类型已经不按inline和block来区分了，</p><blockquote><p>规范中的每个元素都有以下两项：</p><ul><li>Categories</li><li>Content Model</li></ul><p>Categories 是该元素本身的分类，content model 规定了合法的元素的内容（子元素、文本等）类型。</p></blockquote><p>MDN中的介绍是这样的：</p><blockquote><p>每一个HTML元素都必须遵循定义了它可以包含哪一类内容的规则。 这些规则被归类为几个常见的元素内容模型（content model）。每个HTML元素都属于0个、1 个或多个内容模型，每个模型都有一些规则使得元素中的内容必须遵循一个HTML规范文档( HTML-conformant document)。</p><p>以下是三种类型的内容分类：</p><ul><li>主内容类，描述了很多元素共享的内容规范；</li><li>表单相关的内容类，描述了表单相关元素共有的内容规范；</li><li>特殊内容类，描述了仅仅在某些特殊元素上才需要遵守的内容规范，通常这些元素都有特殊的上下文关系。</li></ul></blockquote><p><img src="https://media.prod.mdn.mozit.cloud/attachments/2012/07/09/3704/07b3e5bb546840a09bb35d45b36009a6/Content_categories_venn.png" srcset="/img/loading.gif" lazyload></p><p>每个元素都有内容分类（<strong>Content categories</strong>）和允许的内容（<strong>Permitted content</strong>）两项来说明元素属于何种内容模型和该元素内允许的内容类型。</p><p>回到原来的问题上来，p标签不能包含div的原因其实就是因为新规范中规定了p元素<strong>允许的内容</strong>不包括div，所以才会出现上面的问题，同样不能包含的还有其他元素，比如<code>&lt;p&gt;</code>自己，<code>&lt;ul&gt;</code>列表等都不能被放进p标签内。</p><p>规范其实也说明了一点，虽然有时候在HTML中随意嵌套元素也可以正常显示，但事实上元素应该在他出现的地方才能更好的发挥作用，比如：<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;dl&gt;</code>、<code>&lt;table&gt;</code>，它们的子一层都是指定的元素，<code>&lt;ul&gt;、&lt;ol&gt;</code>的子一级是<code>&lt;li&gt;</code>；<code>&lt;dl&gt;</code>的子一级必须是<code>&lt;dt&gt;</code>或者<code>&lt;dd&gt;</code>；<code>&lt;table&gt;</code>的子一层可以是<code>&lt;caption&gt;</code> 或<code>&lt;thead&gt;</code>、<code>&lt;tfoot&gt;</code>、<code>&lt;tbody&gt;</code>等，而再子一层是<code>&lt;tr&gt; </code>（<code>&lt;tr&gt;</code>只存在于<code>&lt;thead&gt;</code>、<code>&lt;tfoot&gt;</code>、<code>&lt;tbody&gt;</code>中），之后才是<code>&lt;td&gt;</code>或者<code>&lt;th&gt;</code>。以后我们写完代码可以去<a href="https://validator.w3.org/">W3C验证平台</a>上检查一下自己的代码存在什么问题，就能减少一些像上面这样的错误。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.zhihu.com/question/34952563/answer/60672228">a 标签为什么能够包含块级元素？ - 顾轶灵的回答 - 知乎</a></p><p><a href="https://www.cnblogs.com/Iona/p/4732452.html">HTML中为何p标签内不可包含div标签?那哪些块元素里面不能放哪些块元素呢？</a></p><p><a href="https://html.spec.whatwg.org/multipage/dom.html#element-definitions">HTML Standard</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/p">&lt;p&gt; - HTML（超文本标记语言） | MDN</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Content_categories">内容分类 - Web 开发者指南 | MDN</a></p>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bootstrap-Datepicker的基本用法</title>
    <link href="/2020/05/bootstrap-datepicker/"/>
    <url>/2020/05/bootstrap-datepicker/</url>
    
    <content type="html"><![CDATA[<p>在用Bootstrap-Datepicker之前，也用过一个<a href="https://github.com/Eonasdan/bootstrap-datetimepicker">日期时间选择插件</a>，同样也是基于Bootstrap的，可以选择日期和时间，但是因为好像有些小bug，所以再就没有用过，后来又找了一款<strong>日期选择</strong>插件，但是只能选择日期，不能选择时间，在不需要输入具体时间的地方用足够了，并且目前还没有发现什么问题。下面就介绍一下用法吧。</p><h2 id="使用和依赖"><a href="#使用和依赖" class="headerlink" title="使用和依赖"></a>使用和依赖</h2><p><a href="https://github.com/uxsolutions/bootstrap-datepicker"><strong>Bootstrap-datepicker</strong></a>是一款基于Bootstrap样式的datepicker小部件。要求使用<a href="https://getbootstrap.com/">Bootstrap</a> 2.0.4 版本以上，<a href="https://jquery.com/">jQuery</a> 1.7.1版本以上。</p><p>可以下载后引入CSS和JS文件，也可以直接通过CDN引入。</p><p>下载的完整库中包含一些不同的样式表。每个CSS文件的用途分别是：</p><ul><li><p><code>bootstrap-datepicker.css</code>提供对bootstrap v2的旧支持</p></li><li><p><code>bootstrap-datepicker3.css</code>用于bootstrap v3支持</p></li><li><p><code>bootstrap-datepicker.standalone.css</code>可以直接用于datepicker，而无需依赖 bootstrap 库。</p></li></ul><p><strong>下载地址放在最后参考链接中</strong>。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>通过javascript调用datepicker：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;.datepicker&#x27;</span>).datepicker();<br></code></pre></div></td></tr></table></figure><p>通过data-API：</p><p>与bootstrap自己的插件一样，datepicker提供了一个数据API，可用于实例化datepicker，而无需自定义JavaScript。对于大多数日期选择器，只需在要初始化的元素上设置<code>data-provide=&quot;datepicker&quot;</code>，它就会延迟初始化。对于内联日期选择器，请使用<code>data-provide=&quot;datepicker-inline&quot;</code>; 这些将在页面加载时立即初始化，并且不能延迟加载。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">data-provide</span>=<span class="hljs-string">&quot;datepicker&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>选项<code>datepicker</code>在实例化时通过选项传递到函数：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;.datepicker&#x27;</span>).datepicker(&#123;<br>    format: <span class="hljs-string">&#x27;mm/dd/yyyy&#x27;</span>,<br>    startDate: <span class="hljs-string">&#x27;-3d&#x27;</span><br>&#125;);<br></code></pre></div></td></tr></table></figure><p>也可以在目标元素上通过data-API属性使用，大多数选项都提供支持：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;datepicker&quot;</span> <span class="hljs-attr">data-date-format</span>=<span class="hljs-string">&quot;mm/dd/yyyy&quot;</span>&gt;</span><br>$(&#x27;.datepicker&#x27;).datepicker(&#123;<br>    startDate: &#x27;-3d&#x27;<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>可以通过更改<code>$.fn.datepicker.defaults</code>来修改所有选项的默认值：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$.fn.datepicker.defaults.format = <span class="hljs-string">&quot;mm/dd/yyyy&quot;</span>;<br>$(<span class="hljs-string">&#x27;.datepicker&#x27;</span>).datepicker(&#123;<br>    startDate: <span class="hljs-string">&#x27;-3d&#x27;</span><br>&#125;);<br></code></pre></div></td></tr></table></figure><h3 id="无冲突模式"><a href="#无冲突模式" class="headerlink" title="无冲突模式"></a>无冲突模式</h3><p><code>$.fn.datepicker.noConflict</code> 提供一种避免与其他jQuery datepicker插件冲突的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> datepicker = $.fn.datepicker.noConflict(); <span class="hljs-comment">// return $.fn.datepicker to previously assigned value</span><br>$.fn.bootstrapDP = datepicker;                 <span class="hljs-comment">// give $().bootstrapDP the bootstrap-datepicker functionality</span><br></code></pre></div></td></tr></table></figure><h2 id="HTML标记"><a href="#HTML标记" class="headerlink" title="HTML标记"></a>HTML标记</h2><p>有四种类型的显示方式：</p><ul><li><p>输入框</p><p>最简单的方式，当点击输入框或者焦点切换到输入框内时，显示选择器</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;02-16-2012&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><img src="" srcset="/img/loading.gif" lazyload></p></li><li><p>组件</p><p>添加<code>date</code>类到一个输入框组<code>input-group</code>上，这可以让拥有<code>input-group-addon</code>类的元素打开日期选择器。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-group date&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;12-02-2012&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-group-addon&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;glyphicon glyphicon-th&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>范围选择</p><p>将<code>input-daterange</code>添加到输入框组与多个子输入框一起使用将为每个输入框实例化一个选择器，以允许选择范围。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-group input-daterange&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2012-04-05&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-group-addon&quot;</span>&gt;</span>to<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2012-04-19&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul><p><strong>注意：</strong><code>input-daterange</code>自身并不会实现<code>datepicker</code>的方法，方法应该直接被输入框调用，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;.input-daterange input&#x27;</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    $(<span class="hljs-built_in">this</span>).datepicker(<span class="hljs-string">&#x27;clearDates&#x27;</span>);<br>&#125;);<br></code></pre></div></td></tr></table></figure><ul><li><p>内联或嵌入式  </p><p>在简单的<code>div</code>上实例化<code>datepicker</code>将提供一个始终可见的嵌入式选择器。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-date</span>=<span class="hljs-string">&quot;12/03/2012&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>一个实例：将选择器的值的保存到隐藏的字段中。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;datepicker&quot;</span> <span class="hljs-attr">data-date</span>=<span class="hljs-string">&quot;12/03/2012&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;my_hidden_input&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;#datepicker&#x27;</span>).datepicker();<br>$(<span class="hljs-string">&#x27;#datepicker&#x27;</span>).on(<span class="hljs-string">&#x27;changeDate&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  $(<span class="hljs-string">&#x27;#my_hidden_input&#x27;</span>).val(<br>    $(<span class="hljs-string">&#x27;#datepicker&#x27;</span>).datepicker(<span class="hljs-string">&#x27;getFormattedDate&#x27;</span>)<br>  );<br>&#125;);<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h2><p>所有带有<code>Date</code>的选项都可以处理为一个Date对象。或相对于今天的时间增量，例如“ -1d”，“ + 6m + 1y”等，其中有效单位为“ d”（天），“ w”（周），“ m”（月）和“ y” “ （年）。今天使用“ 0”。相对时间增量也有别名：“昨天”等于“ -1d”，“今天”等于“ + 0d”，“明天”等于“ + 1d”。</p><p>大多数选项可以通过数据属性提供。通过以下方式可以将选项转换为数据属性：将选项中的每个大写字母替换为其小写字母，并在每个单词前加上破折号，然后在结果前添加<code>data-date-</code>。例如，<code>startDate</code>转换为<code>data-date-start-date</code>，<code>format</code>转换为<code>data-date-format</code>而<code>daysOfWeekDisabled</code>将是<code>data-date-days-of-week-disabled</code>。</p><p>可以在官方提供的在线<a href="https://uxsolutions.github.io/bootstrap-datepicker/#sandbox">DEMO</a>中测试下面的选项。另外官方demo中的<code>Start date</code>和<code>End date</code>选项存在bug，如果直接输入会在控制台报错，并且日期选择器将失效，如果想测试可以把选项内容在别的地方写好，然后复制进去测试。</p><p>下面介绍一些常用的选项：</p><h4 id="autoclose"><a href="#autoclose" class="headerlink" title="autoclose"></a>autoclose</h4><h4 id="assumeNearbyYear"><a href="#assumeNearbyYear" class="headerlink" title="assumeNearbyYear"></a>assumeNearbyYear</h4><h4 id="beforeShowDay"><a href="#beforeShowDay" class="headerlink" title="beforeShowDay"></a>beforeShowDay</h4><h4 id="calendarWeeks"><a href="#calendarWeeks" class="headerlink" title="calendarWeeks"></a>calendarWeeks</h4><h4 id="container"><a href="#container" class="headerlink" title="container"></a>container</h4><h4 id="datesDisabled"><a href="#datesDisabled" class="headerlink" title="datesDisabled"></a>datesDisabled</h4><h4 id="daysOfWeekDisabled"><a href="#daysOfWeekDisabled" class="headerlink" title="daysOfWeekDisabled"></a>daysOfWeekDisabled</h4><h4 id="daysOfWeekHighlighted"><a href="#daysOfWeekHighlighted" class="headerlink" title="daysOfWeekHighlighted"></a>daysOfWeekHighlighted</h4><h4 id="defaultViewDate"><a href="#defaultViewDate" class="headerlink" title="defaultViewDate"></a>defaultViewDate</h4><h4 id="enableOnReadonly"><a href="#enableOnReadonly" class="headerlink" title="enableOnReadonly"></a>enableOnReadonly</h4><h4 id="endDate"><a href="#endDate" class="headerlink" title="endDate"></a>endDate</h4><h4 id="forceParse"><a href="#forceParse" class="headerlink" title="forceParse"></a>forceParse</h4><h4 id="format"><a href="#format" class="headerlink" title="format"></a>format</h4><h4 id="immediateUpdates"><a href="#immediateUpdates" class="headerlink" title="immediateUpdates"></a>immediateUpdates</h4><h4 id="keepEmptyValues"><a href="#keepEmptyValues" class="headerlink" title="keepEmptyValues"></a>keepEmptyValues</h4><h4 id="language"><a href="#language" class="headerlink" title="language"></a>language</h4><h4 id="maxViewMode"><a href="#maxViewMode" class="headerlink" title="maxViewMode"></a>maxViewMode</h4><h4 id="minViewMode"><a href="#minViewMode" class="headerlink" title="minViewMode"></a>minViewMode</h4><h4 id="multidate"><a href="#multidate" class="headerlink" title="multidate"></a>multidate</h4><h4 id="multidateSeparator"><a href="#multidateSeparator" class="headerlink" title="multidateSeparator"></a>multidateSeparator</h4><h4 id="orientation"><a href="#orientation" class="headerlink" title="orientation"></a>orientation</h4><h4 id="startDate"><a href="#startDate" class="headerlink" title="startDate"></a>startDate</h4><h4 id="startView"><a href="#startView" class="headerlink" title="startView"></a>startView</h4><h4 id="showWeekDays"><a href="#showWeekDays" class="headerlink" title="showWeekDays"></a>showWeekDays</h4><h4 id="todayBtn"><a href="#todayBtn" class="headerlink" title="todayBtn"></a>todayBtn</h4><h4 id="todayHighlight"><a href="#todayHighlight" class="headerlink" title="todayHighlight"></a>todayHighlight</h4><h4 id="autoclose-1"><a href="#autoclose-1" class="headerlink" title="autoclose"></a>autoclose</h4><h4 id="weekStart"><a href="#weekStart" class="headerlink" title="weekStart"></a>weekStart</h4><h4 id="zIndexOffset"><a href="#zIndexOffset" class="headerlink" title="zIndexOffset"></a>zIndexOffset</h4><p>更多选项及其默认值的概述，请参见<a href="https://bootstrap-datepicker.readthedocs.io/en/stable/options.html#quick-reference">快速参考</a>。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h4 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h4><h4 id="show"><a href="#show" class="headerlink" title="show"></a>show</h4><h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><h4 id="setDate"><a href="#setDate" class="headerlink" title="setDate"></a>setDate</h4><h4 id="getDate"><a href="#getDate" class="headerlink" title="getDate"></a>getDate</h4><h4 id="clearDates"><a href="#clearDates" class="headerlink" title="clearDates"></a>clearDates</h4><h4 id="setDatesDisabled"><a href="#setDatesDisabled" class="headerlink" title="setDatesDisabled"></a>setDatesDisabled</h4><h4 id="setDaysOfWeekHighlighted"><a href="#setDaysOfWeekHighlighted" class="headerlink" title="setDaysOfWeekHighlighted"></a>setDaysOfWeekHighlighted</h4><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h4 id="show-1"><a href="#show-1" class="headerlink" title="show"></a>show</h4><h4 id="hide"><a href="#hide" class="headerlink" title="hide"></a>hide</h4><h4 id="clearDate"><a href="#clearDate" class="headerlink" title="clearDate"></a>clearDate</h4><h4 id="changeDate"><a href="#changeDate" class="headerlink" title="changeDate"></a>changeDate</h4><h4 id="changeMonth"><a href="#changeMonth" class="headerlink" title="changeMonth"></a>changeMonth</h4><h4 id="changeYear"><a href="#changeYear" class="headerlink" title="changeYear"></a>changeYear</h4><h4 id="changeDecade"><a href="#changeDecade" class="headerlink" title="changeDecade"></a>changeDecade</h4><h4 id="changeCentury"><a href="#changeCentury" class="headerlink" title="changeCentury"></a>changeCentury</h4><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="键盘支持"><a href="#键盘支持" class="headerlink" title="键盘支持"></a>键盘支持</h3><p>日期选择器支持使用键盘选择。在使用键盘选择时，被选择的日期会突出显示（与鼠标悬停一样）。</p><ul><li><p>上，下，左，右方向键</p><p>就其本身而言，左/右将使焦点向后/向前移动一天，向上/向下将使焦点向后/向前移动一周。</p><p>配合使用<kbd>Shift</kbd>键，向上<kbd>↑</kbd>/向左<kbd>←</kbd>将焦点向前移动一个月，向下<kbd>↓</kbd>/向右<kbd>→</kbd>将焦点向后移动一个月。</p><p>配合使用<kbd>Ctrl</kbd>键，向上<kbd>↑</kbd>/向左<kbd>←</kbd>将焦点向前移动一年，向下<kbd>↓</kbd>/向右<kbd>→</kbd>将焦点向后移动一年。</p><p><kbd>Shift + Ctrl</kbd>的行为与<kbd>Ctrl</kbd>相同，也就是说，它不会同时更改月份和年份，而只会更改年份。</p></li><li><p>Enter键</p><p>当选择器可见时，按<kbd>Enter</kbd>将选择焦点日期（如果有的话）。当选择器不可见时，<kbd>Enter</kbd>键将具有正常效果，如提交当前表单等。<br>当取消选择日期时，触发<code>clearDate</code>事件，否则触发<code>changeDate</code>事件。如果<code>autoclose</code>启用，日期选择器将在选择或取消选择后隐藏。</p></li><li><p>ESC键</p><p><kbd>ESC</kbd>可用于清除焦点日期，以及隐藏并重新显示日期选择器；如果用户要手动编辑值，则必须隐藏选择器。</p></li></ul><h3 id="I18N"><a href="#I18N" class="headerlink" title="I18N"></a>I18N</h3><p>日期选择器支持<code>i18n</code>，提供不同语言的月份和周工作日名称，以及设置weekStart选项。默认语言为英语（”en”），在<code>js/locales/</code>目录中还提供其他可用语言的翻译，只需在插件中添加所需的语言即可。要添加更多语言，只需在调用<code>.datepicker()</code>之前添加一个键到<code>$.fn.datepicker.dates</code>。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$.fn.datepicker.dates[<span class="hljs-string">&#x27;en&#x27;</span>] = &#123;<br>    days: [<span class="hljs-string">&quot;Sunday&quot;</span>, <span class="hljs-string">&quot;Monday&quot;</span>, <span class="hljs-string">&quot;Tuesday&quot;</span>, <span class="hljs-string">&quot;Wednesday&quot;</span>, <span class="hljs-string">&quot;Thursday&quot;</span>, <span class="hljs-string">&quot;Friday&quot;</span>, <span class="hljs-string">&quot;Saturday&quot;</span>],<br>    daysShort: [<span class="hljs-string">&quot;Sun&quot;</span>, <span class="hljs-string">&quot;Mon&quot;</span>, <span class="hljs-string">&quot;Tue&quot;</span>, <span class="hljs-string">&quot;Wed&quot;</span>, <span class="hljs-string">&quot;Thu&quot;</span>, <span class="hljs-string">&quot;Fri&quot;</span>, <span class="hljs-string">&quot;Sat&quot;</span>],<br>    daysMin: [<span class="hljs-string">&quot;Su&quot;</span>, <span class="hljs-string">&quot;Mo&quot;</span>, <span class="hljs-string">&quot;Tu&quot;</span>, <span class="hljs-string">&quot;We&quot;</span>, <span class="hljs-string">&quot;Th&quot;</span>, <span class="hljs-string">&quot;Fr&quot;</span>, <span class="hljs-string">&quot;Sa&quot;</span>],<br>    months: [<span class="hljs-string">&quot;January&quot;</span>, <span class="hljs-string">&quot;February&quot;</span>, <span class="hljs-string">&quot;March&quot;</span>, <span class="hljs-string">&quot;April&quot;</span>, <span class="hljs-string">&quot;May&quot;</span>, <span class="hljs-string">&quot;June&quot;</span>, <span class="hljs-string">&quot;July&quot;</span>, <span class="hljs-string">&quot;August&quot;</span>, <span class="hljs-string">&quot;September&quot;</span>, <span class="hljs-string">&quot;October&quot;</span>, <span class="hljs-string">&quot;November&quot;</span>, <span class="hljs-string">&quot;December&quot;</span>],<br>    monthsShort: [<span class="hljs-string">&quot;Jan&quot;</span>, <span class="hljs-string">&quot;Feb&quot;</span>, <span class="hljs-string">&quot;Mar&quot;</span>, <span class="hljs-string">&quot;Apr&quot;</span>, <span class="hljs-string">&quot;May&quot;</span>, <span class="hljs-string">&quot;Jun&quot;</span>, <span class="hljs-string">&quot;Jul&quot;</span>, <span class="hljs-string">&quot;Aug&quot;</span>, <span class="hljs-string">&quot;Sep&quot;</span>, <span class="hljs-string">&quot;Oct&quot;</span>, <span class="hljs-string">&quot;Nov&quot;</span>, <span class="hljs-string">&quot;Dec&quot;</span>],<br>    today: <span class="hljs-string">&quot;Today&quot;</span>,<br>    clear: <span class="hljs-string">&quot;Clear&quot;</span>,<br>    format: <span class="hljs-string">&quot;mm/dd/yyyy&quot;</span>,<br>    titleFormat: <span class="hljs-string">&quot;MM yyyy&quot;</span>, <span class="hljs-comment">/* Leverages same syntax as &#x27;format&#x27; */</span><br>    weekStart: <span class="hljs-number">0</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>[&#39;en&#39;]</code>就是添加新语言的键，在后面大括号中添加月和周的对应语言翻译。使用时将键添加到选项中：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;.datepicker&#x27;</span>).datepicker(&#123;<br>    language: <span class="hljs-string">&#x27;XX&#x27;</span> <span class="hljs-comment">//XX就是键名</span><br>&#125;);<br></code></pre></div></td></tr></table></figure><p>从右到左的语言添加<code>rtl: true</code>也可以使日历正确显示。</p><p>如果您的浏览器（或您用户的浏览器）的字符显示错误，则可能是浏览器正在加载具有非Unicode编码的javascript文件。只需添加<code>charset=&quot;UTF-8&quot;</code>到您的script标签即可正常显示：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;bootstrap-datepicker.XX.js&quot;</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.bootcss.com/">bootstrap中文网</a></p><p><a href="https://bootstrap-datepicker.readthedocs.io/en/stable/index.html">bootstrap-datepicker文档</a></p><p><a href="https://github.com/uxsolutions/bootstrap-datepicker/releases">下载地址</a></p><p><a href="https://www.cmd5.com/">md5在线解密破解,md5解密加密</a></p>]]></content>
    
    
    <categories>
      
      <category>Bootstrap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bootstrap</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bootstrap-Table的基本使用教程</title>
    <link href="/2020/05/bootstrap-table/"/>
    <url>/2020/05/bootstrap-table/</url>
    
    <content type="html"><![CDATA[<h2 id="引入文件"><a href="#引入文件" class="headerlink" title="引入文件"></a>引入文件</h2><p>引入CSS文件</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/bootstrap.min.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/bootstrap-table.min.css&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>引入js文件</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/jquery-1.11.0.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/bootstrap.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/bootstrap-table.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/bootstrap-table-zh-CN.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="初始化表格"><a href="#初始化表格" class="headerlink" title="初始化表格"></a>初始化表格</h2><p>表格的初始化有两种方式:</p><p>一种是通过数据属性初始化：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">&lt;table<br>  data-toggle=&quot;table&quot;<br>  data-url=&quot;data.json&quot;<br>  data-pagination=&quot;true&quot;&gt;<br>  <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">data-sortable</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">data-field</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span>Item ID<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">data-field</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>Item Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">data-field</span>=<span class="hljs-string">&quot;price&quot;</span>&gt;</span>Item Price<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>另一种是通过JavaScript初始化：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;table&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><br>$(&#x27;#table&#x27;).bootstrapTable(&#123;<br>  url: &#x27;data.json&#x27;,<br>  pagination: true,<br>  columns: [&#123;<br>    field: &#x27;id&#x27;,<br>    title: &#x27;Item ID&#x27;<br>  &#125;, &#123;<br>    field: &#x27;name&#x27;,<br>    title: &#x27;Item Name&#x27;<br>  &#125;, &#123;<br>    field: &#x27;price&#x27;,<br>    title: &#x27;Item Price&#x27;<br>  &#125;]<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>如果只是做简单的数据展示的话，比较适合用数据属性初始化表格；如果表格结构功能复杂更推荐使用JS，处理表格比较容易。下面我就用JS初始化一个带有各种常用选项的表格。</p><p>HTML</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;table table-striped table-hover&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;table-request&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>JavaScript</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 初始化表格</span><br>$(<span class="hljs-string">&#x27;#table-request&#x27;</span>).bootstrapTable(&#123;<br>    url: <span class="hljs-string">&#x27;../test0.json&#x27;</span>,             <span class="hljs-comment">//请求后台的URL（*）/article/list</span><br>    method: <span class="hljs-string">&#x27;get&#x27;</span>,                      <span class="hljs-comment">//请求方式（*）</span><br>    toolbar: <span class="hljs-string">&#x27;#toolbar&#x27;</span>,                <span class="hljs-comment">//工具按钮用哪个容器</span><br>    striped: <span class="hljs-literal">true</span>,                      <span class="hljs-comment">//是否显示行间隔色</span><br>    locale: <span class="hljs-string">&#x27;zh-CN&#x27;</span>,<br>    resizable: <span class="hljs-literal">true</span>,                    <span class="hljs-comment">//设置height后拖动调整列宽失效</span><br>    cache: <span class="hljs-literal">false</span>,                       <span class="hljs-comment">//是否使用缓存，默认为true，所以一般情况下需要设置一下这个属性（*）</span><br>    pagination: <span class="hljs-literal">true</span>,                   <span class="hljs-comment">//是否显示分页（*）</span><br>    sortable: <span class="hljs-literal">false</span>,                     <span class="hljs-comment">//是否启用排序</span><br>    queryParams: <span class="hljs-string">&#x27;queryParams&#x27;</span>,         <span class="hljs-comment">//传递参数（*）</span><br>    queryParamsType: <span class="hljs-string">&#x27;&#x27;</span>,                <span class="hljs-comment">//查询参数类型</span><br>    sidePagination: <span class="hljs-string">&quot;client&quot;</span>,           <span class="hljs-comment">//分页方式：client客户端分页，server服务端分页（*）</span><br>    pageNumber:<span class="hljs-number">1</span>,                       <span class="hljs-comment">//初始化加载第一页，默认第一页</span><br>    pageSize: <span class="hljs-number">10</span>,                       <span class="hljs-comment">//每页的记录行数（*）</span><br>    pageList: [<span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>],        <span class="hljs-comment">//可供选择的每页的行数（*）</span><br>    totalField: <span class="hljs-string">&#x27;total&#x27;</span>,<br>    dataField: <span class="hljs-string">&#x27;rows&#x27;</span>,<br>    smartDisplay:<span class="hljs-literal">false</span>,<br>    search: <span class="hljs-literal">false</span>,                      <span class="hljs-comment">//是否显示表格搜索，此搜索是客户端搜索，不会进服务端，所以，个人感觉意义不大</span><br>    strictSearch: <span class="hljs-literal">true</span>,<br>    showColumns: <span class="hljs-literal">false</span>,                 <span class="hljs-comment">//是否显示所有的列</span><br>    showRefresh: <span class="hljs-literal">false</span>,                 <span class="hljs-comment">//是否显示刷新按钮</span><br>    minimumCountColumns: <span class="hljs-number">2</span>,             <span class="hljs-comment">//最少允许的列数</span><br>    clickToSelect: <span class="hljs-literal">false</span>,                <span class="hljs-comment">//是否启用点击选中行</span><br>    <span class="hljs-comment">// height: 500,                        //行高，如果没有设置height属性，表格自动根据记录条数觉得表格高度</span><br>    uniqueId: <span class="hljs-string">&quot;ID&quot;</span>,                     <span class="hljs-comment">//每一行的唯一标识，一般为主键列</span><br>    showToggle:<span class="hljs-literal">false</span>,                   <span class="hljs-comment">//是否显示详细视图和列表视图的切换按钮</span><br>    cardView: <span class="hljs-literal">false</span>,                    <span class="hljs-comment">//是否显示详细视图</span><br>    detailView: <span class="hljs-literal">false</span>,                   <span class="hljs-comment">//是否显示父子表</span><br>    columns: [<br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     field:&#x27;id&#x27;,</span><br>        <span class="hljs-comment">//     title:&#x27;文章id&#x27;,</span><br>        <span class="hljs-comment">//     // visible: false,</span><br>        <span class="hljs-comment">// &#125;,&#123;</span><br>        <span class="hljs-comment">//     field:&#x27;id&#x27;,</span><br>        <span class="hljs-comment">//     // field:&#x27;title&#x27;,</span><br>        <span class="hljs-comment">//     title:&#x27;文章标题&#x27;,</span><br>        <span class="hljs-comment">// &#125;,&#123;</span><br>        <span class="hljs-comment">//     field:&#x27;name&#x27;,</span><br>        <span class="hljs-comment">//     // field:&#x27;roundup&#x27;,</span><br>        <span class="hljs-comment">//     title:&#x27;摘要&#x27;,</span><br>        <span class="hljs-comment">// &#125;,&#123;</span><br>        <span class="hljs-comment">//     field:&#x27;price&#x27;,</span><br>        <span class="hljs-comment">//     // field:&#x27;ntype&#x27;,</span><br>        <span class="hljs-comment">//     title:&#x27;所属分类&#x27;,</span><br>        <span class="hljs-comment">//     // formatter: function (value, row, index) &#123;</span><br>        <span class="hljs-comment">//     //     if (row[&#x27;ntype&#x27;] === 1) &#123;</span><br>        <span class="hljs-comment">//     //         return &#x27;集团新闻&#x27;;</span><br>        <span class="hljs-comment">//     //     &#125;</span><br>        <span class="hljs-comment">//     //     if (row[&#x27;ntype&#x27;] === 2) &#123;</span><br>        <span class="hljs-comment">//     //         return &#x27;媒体报道&#x27;;</span><br>        <span class="hljs-comment">//     //     &#125;</span><br>        <span class="hljs-comment">//     //     if (row[&#x27;ntype&#x27;] === 3) &#123;</span><br>        <span class="hljs-comment">//     //         return &#x27;社会活动&#x27;;</span><br>        <span class="hljs-comment">//     //     &#125;</span><br>        <span class="hljs-comment">//     //         return value;</span><br>        <span class="hljs-comment">//     // &#125;,</span><br>        <span class="hljs-comment">// &#125;,&#123;</span><br>        <span class="hljs-comment">//     field:&#x27;opt&#x27;,</span><br>        <span class="hljs-comment">//     // field:&#x27;uptime&#x27;,</span><br>        <span class="hljs-comment">//     title:&#x27;修改时间&#x27;,</span><br>        <span class="hljs-comment">// &#125;,&#123;</span><br>        <span class="hljs-comment">//     field:&#x27;action&#x27;,</span><br>        <span class="hljs-comment">//     title:&#x27;操作&#x27;,</span><br>        <span class="hljs-comment">//     events:&#x27;operateEvents&#x27;,</span><br>        <span class="hljs-comment">//     formatter:&#x27;operateFormatter&#x27;,       //自定义表格内容，字符串内是方法名称</span><br>        <span class="hljs-comment">// &#125;</span><br>        &#123;<br>            field:<span class="hljs-string">&#x27;id&#x27;</span>,<br>            title:<span class="hljs-string">&#x27;文章id&#x27;</span>,<br>            visible: <span class="hljs-literal">false</span>,<br>        &#125;,&#123;<br>            field:<span class="hljs-string">&#x27;title&#x27;</span>,<br>            title:<span class="hljs-string">&#x27;文章标题&#x27;</span>,<br>            width: <span class="hljs-number">300</span>,<br>        &#125;,&#123;<br>            field:<span class="hljs-string">&#x27;roundup&#x27;</span>,<br>            title:<span class="hljs-string">&#x27;摘要&#x27;</span>,<br>            width: <span class="hljs-number">300</span>,<br>        &#125;,&#123;<br>            field:<span class="hljs-string">&#x27;ntype&#x27;</span>,<br>            title:<span class="hljs-string">&#x27;所属分类&#x27;</span>,<br>            formatter: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, row, index</span>) </span>&#123;<br>                <span class="hljs-keyword">if</span> (row[<span class="hljs-string">&#x27;ntype&#x27;</span>] == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;集团新闻&#x27;</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (row[<span class="hljs-string">&#x27;ntype&#x27;</span>] == <span class="hljs-number">2</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;媒体报道&#x27;</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (row[<span class="hljs-string">&#x27;ntype&#x27;</span>] == <span class="hljs-number">3</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;社会活动&#x27;</span>;<br>                &#125;<br>                    <span class="hljs-keyword">return</span> value;<br>            &#125;,<br>        &#125;,&#123;<br>            field:<span class="hljs-string">&#x27;uptime&#x27;</span>,<br>            title:<span class="hljs-string">&#x27;修改时间&#x27;</span>,<br>        &#125;,&#123;<br>            field:<span class="hljs-string">&#x27;action&#x27;</span>,<br>            title:<span class="hljs-string">&#x27;操作&#x27;</span>,<br>            events:<span class="hljs-string">&#x27;operateEvents&#x27;</span>,<br>            formatter:<span class="hljs-string">&#x27;operateFormatter&#x27;</span>      <br>        &#125;<br>    ]<br>        <span class="hljs-comment">//列设置</span><br>&#125;); <br></code></pre></div></td></tr></table></figure><h2 id="请求参数设置"><a href="#请求参数设置" class="headerlink" title="请求参数设置"></a>请求参数设置</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//请求参数设置</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryParams</span>(<span class="hljs-params">params</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        npage: params.pageNumber,      <span class="hljs-comment">//页码</span><br>        pagesize: params.pageSize,        <span class="hljs-comment">//一页多少条记录</span><br>        ntype: $(<span class="hljs-string">&#x27;#article-class&#x27;</span>).val(),  <span class="hljs-comment">//文章类型</span><br>        btime : $(<span class="hljs-string">&#x27;#start-time&#x27;</span>).val(), <span class="hljs-comment">//起始时间 </span><br>        etime : $(<span class="hljs-string">&#x27;#end-time&#x27;</span>).val(), <span class="hljs-comment">//结束时间 </span><br>            <span class="hljs-comment">// name: $(...).val()   //其他自定义参数，从页面获取</span><br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="单元格自定义设置：行内操作按钮"><a href="#单元格自定义设置：行内操作按钮" class="headerlink" title="单元格自定义设置：行内操作按钮"></a>单元格自定义设置：行内操作按钮</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">operateFormatter</span>(<span class="hljs-params">value, row, index</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> [<br>        <span class="hljs-string">&#x27;&lt;div class=&quot;btn-group&quot; role=&quot;group&quot; aria-label=&quot;...&quot;&gt;&#x27;</span>,<br>        <span class="hljs-string">&#x27;&lt;button type=&quot;button&quot; class=&quot;btn btn-default edit&quot;&gt;编辑&lt;/button&gt;&#x27;</span>,<br>        <span class="hljs-string">&#x27;&lt;button type=&quot;button&quot; class=&quot;btn btn-danger remove&quot;&gt;删除&lt;/button&gt;&#x27;</span>,<span class="hljs-string">&#x27;&lt;/div&gt;&#x27;</span>,<br>    ].join(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="" srcset="/img/loading.gif" lazyload></p><h2 id="处理行内按钮的点击事件"><a href="#处理行内按钮的点击事件" class="headerlink" title="处理行内按钮的点击事件"></a>处理行内按钮的点击事件</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.operateEvents = &#123;<br>    <span class="hljs-string">&#x27;click .edit&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e, value, row, index</span>) </span>&#123;<br>            alert(<span class="hljs-string">&quot;edit&quot;</span>);<br>            <span class="hljs-comment">// 点编辑打开模态框并获取内容</span><br>            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;text-id&quot;</span>).value = row.id;<br>            $(<span class="hljs-string">&#x27;#myModal2&#x27;</span>).modal(&#123;&#125;);<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;text-id&quot;</span>).value);<br>            <span class="hljs-keyword">var</span> id = row.id;<br>            <span class="hljs-keyword">var</span> sj = &#123;<span class="hljs-attr">id</span>:id&#125;;<br>            <span class="hljs-keyword">var</span> sj = <span class="hljs-built_in">JSON</span>.stringify(sj);<br>        <span class="hljs-comment">//     $.ajax(&#123;</span><br>        <span class="hljs-comment">//         type:&quot;post&quot;,</span><br>        <span class="hljs-comment">//         url:&quot;/article/detail&quot;,</span><br>        <span class="hljs-comment">//         data:sj,</span><br>        <span class="hljs-comment">//         async:false,</span><br>        <span class="hljs-comment">//         success: function(res)&#123;</span><br>        <span class="hljs-comment">//             if (res.result == &quot;OK&quot;) &#123;</span><br>                    <span class="hljs-comment">// console.log(res.data);</span><br>                        <span class="hljs-comment">// var obj = res.data;</span><br>                        <span class="hljs-comment">// if ($.isEmptyObject(obj)) &#123;</span><br>                        <span class="hljs-comment">//     alert(&quot;获取文章数据失败&quot;);</span><br>                        <span class="hljs-comment">// &#125;else&#123;</span><br>                        <span class="hljs-comment">//     document.getElementById(&quot;text-title2&quot;).value = obj.title;</span><br>                        <span class="hljs-comment">//     document.getElementById(&quot;text-summary2&quot;).value = obj.roundup;</span><br>                        <span class="hljs-comment">//     document.getElementById(&quot;text-class2&quot;).value = obj.ntype;</span><br>                        <span class="hljs-comment">//     document.getElementById(&quot;upload_img2&quot;).src = obj.thumb;</span><br>                        <span class="hljs-comment">//     $(&#x27;#summernote2&#x27;).summernote(&#x27;code&#x27;,obj.content);</span><br>                        <span class="hljs-comment">//     $(&#x27;#myModal2&#x27;).modal(&#123;&#125;);</span><br>                        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">//             &#125;else&#123;</span><br>                        <span class="hljs-comment">// if (res.errorcode == 1) &#123;</span><br>                        <span class="hljs-comment">//     alert(&quot;未登录，请先登录&quot;);</span><br>                        <span class="hljs-comment">//     location.href = &quot;login.html&quot;;</span><br>                        <span class="hljs-comment">// &#125;&#125;</span><br>        <span class="hljs-comment">//         &#125;,</span><br>                <span class="hljs-comment">// error: function(err)&#123;alert(&quot;获取文章内容网络错误&quot;);&#125;               </span><br>        <span class="hljs-comment">//     &#125;);</span><br>    &#125;,<br>    <span class="hljs-string">&#x27;click .remove&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e, value, row, index</span>) </span>&#123;<br>            alert(<span class="hljs-string">&quot;remove&quot;</span>);<br>            <span class="hljs-comment">// 删除文章</span><br>            <span class="hljs-keyword">var</span> id = row.id;<br>            <span class="hljs-keyword">var</span> sj = &#123;<span class="hljs-attr">id</span>:id&#125;;<br>            <span class="hljs-keyword">var</span> sj = <span class="hljs-built_in">JSON</span>.stringify(sj);<br>            <span class="hljs-keyword">var</span> conf = confirm(<span class="hljs-string">&quot;确定要删除&quot;</span>+row.name+<span class="hljs-string">&quot;吗&quot;</span>);<br>            <span class="hljs-keyword">if</span> (conf == <span class="hljs-literal">true</span>) &#123;<br>                alert(<span class="hljs-string">&quot;删除&quot;</span>);<br><span class="hljs-comment">//     $.ajax(&#123;</span><br><span class="hljs-comment">//         type:&quot;post&quot;,</span><br><span class="hljs-comment">//         url:&quot;/article/del&quot;,</span><br><span class="hljs-comment">//         data:sj,</span><br><span class="hljs-comment">//         async:false,</span><br><span class="hljs-comment">//         success: function(res)&#123;</span><br><span class="hljs-comment">//             if (res.result == &quot;OK&quot;) &#123;</span><br><span class="hljs-comment">// //alert(&quot;删除成功&quot;);</span><br><span class="hljs-comment">//                 location.reload();</span><br><span class="hljs-comment">//             &#125;else&#123;&#125;</span><br><span class="hljs-comment">//         &#125;</span><br><span class="hljs-comment">//     &#125;);</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                alert(<span class="hljs-string">&quot;不删&quot;</span>);<br>            &#125;<br>    &#125;,<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><img src="" srcset="/img/loading.gif" lazyload></p><h2 id="表格可调整列宽（插件）"><a href="#表格可调整列宽（插件）" class="headerlink" title="表格可调整列宽（插件）"></a>表格可调整列宽（插件）</h2><p>首先需要引入CSS和js文件</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/jquery.resizableColumns.css&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/jquery.resizableColumns.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/bootstrap-table-resizable.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>然后设置数据属性<code>data-resizable</code>为<code>true</code>或者在JS初始化的表格中添加选项<code>resizable:true</code></p><p>插件存在的已知问题：当设置了表格高度时，此插件无法正常工作。也就是说，在设置表格高度以启用固定表格列头之后，表格的调整列宽功能将出现问题（其实就是二选一）。<br><img src="" srcset="/img/loading.gif" lazyload></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//请求参数设置</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryParams</span>(<span class="hljs-params">params</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        npage: params.pageNumber,      <span class="hljs-comment">//页码</span><br>        pagesize: params.pageSize,        <span class="hljs-comment">//一页多少条记录</span><br>        ntype: $(<span class="hljs-string">&#x27;#article-class&#x27;</span>).val(),  <span class="hljs-comment">//文章类型</span><br>        btime : $(<span class="hljs-string">&#x27;#start-time&#x27;</span>).val(), <span class="hljs-comment">//起始时间 </span><br>        etime : $(<span class="hljs-string">&#x27;#end-time&#x27;</span>).val(), <span class="hljs-comment">//结束时间 </span><br>            <span class="hljs-comment">// name: $(...).val()   //其他自定义参数，从页面获取</span><br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="" srcset="/img/loading.gif" lazyload></p><p>更多功能可以到官网查看，或者查看下面的参考链接。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://bootstrap-table.com/">Bootstrap Table</a></p><p><a href="https://www.bootstrap-table.com.cn/">Bootstrap Table中文网</a></p><p><a href="https://www.cnblogs.com/landeanfen/p/4976838.html">JS组件系列——表格组件神器：bootstrap table</a></p><p><a href="https://www.jianshu.com/p/b9d0f0935263">表格神器bootstraptable</a></p><p><a href="https://blog.csdn.net/S_clifftop/article/details/77937356">Bootstrap Table API 中文版（完整翻译文档）</a></p><p><a href="https://blog.csdn.net/havebeenstand/article/details/96439201">BootstrapTable中文文档</a></p><p><a href="https://www.cnblogs.com/wdcwy/p/6590855.html">bootstrap table使用总结</a></p>]]></content>
    
    
    <categories>
      
      <category>Bootstrap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bootstrap</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bootstrap多个模态框（modals）重叠嵌套问题</title>
    <link href="/2020/05/bootstrap-modals-problem/"/>
    <url>/2020/05/bootstrap-modals-problem/</url>
    
    <content type="html"><![CDATA[<h2 id="如何实现多个模态框嵌套"><a href="#如何实现多个模态框嵌套" class="headerlink" title="如何实现多个模态框嵌套"></a>如何实现多个模态框嵌套</h2><p>最近做项目的时候用到了Bootstrap的模态框插件，官方文档里面 特别清楚提示了一条：</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p><p>但是我就想模态框上叠模态框怎么办呢，机智如我的想到可以给上面的模态框加一个更大的<code>z-index</code>值，这样不就可以显示在上面了 吗，我这里因为只有两个模态框嵌套，所以直接修改最上面那个模态框的<code>z-index</code>的值就好，那如果需要更多的模态框嵌套该怎么办呢，一个一个去修改太麻烦了，然后我就在网上找到这样一个方法：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 通过该方法来为每次弹出的模态框设置最新的zIndex值，从而使最新的modal显示在最前面</span><br>    $(<span class="hljs-built_in">document</span>).on(<span class="hljs-string">&#x27;show.bs.modal&#x27;</span>, <span class="hljs-string">&#x27;.modal&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>         <span class="hljs-keyword">var</span> zIndex = <span class="hljs-number">1040</span> + (<span class="hljs-number">10</span> * $(<span class="hljs-string">&#x27;.modal:visible&#x27;</span>).length);<br>         $(<span class="hljs-built_in">this</span>).css(<span class="hljs-string">&#x27;z-index&#x27;</span>, zIndex);<br>            <span class="hljs-comment">// setTimeout(function() &#123;</span><br>            <span class="hljs-comment">//     $(&#x27;.modal-backdrop&#x27;).not(&#x27;.modal-stack&#x27;).css(&#x27;z-index&#x27;, zIndex - 1).addClass(&#x27;modal-stack&#x27;);</span><br>            <span class="hljs-comment">// &#125;, 0);</span><br>    &#125;);<br>&#125;);<br></code></pre></div></td></tr></table></figure><p><strong>PS：这个方法还没试过，不敢保证好用</strong>，只是找到贴出来，以防以后用得上。</p><h2 id="关闭子模态框父模态框也关闭？"><a href="#关闭子模态框父模态框也关闭？" class="headerlink" title="关闭子模态框父模态框也关闭？"></a>关闭子模态框父模态框也关闭？</h2><p>前面解决好了多个模态框重叠嵌套的问题，本以为可以美滋滋的 继续往下做项目了，结果又发现了另外一个更严重的问题，当我把最上面打开的子模态框关掉以后，为什么下面的父模态框也没了？？看起来官网说得对：</p><blockquote><p>千万不要在一个模态框上重叠另一个模态框</p></blockquote><p>可我还是想套一起用咋办呢，我就又去了万能的**，然后找到了解决方法，这次需要修改一下Bootstrap的源码了，先找到这一行：</p><p><code>this.$element.on(&#39;click.dismiss.bs.modal&#39;, &#39;[data-dismiss=&quot;modal&quot;]&#39;, $.proxy(this.hide, this))</code></p><p>然后把他改成：</p><p><code>this.$element.on(&#39;click.dismiss.bs.modal&#39;, &#39;[data-dismiss=&quot;modal&quot;]:first&#39;, $.proxy(this.hide, this))</code></p><p>这样就不会出现关闭上面的模态框下面也跟着关掉的问题了。</p><h2 id="滚动条怎么不见了？"><a href="#滚动条怎么不见了？" class="headerlink" title="滚动条怎么不见了？"></a>滚动条怎么不见了？</h2><p>在上面两个问题都搞定了以后，我以为不会再有bug了，然而，，事实上。。</p><p>某天我在模态框上瞎点的时候，突然发现我把上面的模态框关掉以后，下面父模态框的滚动条不见了，，当时我就傻了，这父模态框最底下还有按钮呢，滚动条没了怎么点按钮啊，于是我就打开控制台研究了一下这个模态框的结构，然后发现，在这个模态框打开的时候，Bootstrap会给body加一个叫<code>modal-open</code>的class，然后打开的模态框上面有这样一个CSS：</p><p><code>.modal-open .modal &#123;overflow-x:hidden;overflow-y:auto&#125;</code></p><p>当你把任意一个模态框关掉的时候，body上的class就没了，上面这个CSS 也就不生效了，所以就出现了滚动条神秘消失的问题，知道了是这个原因就好办了，只要给这个模态框上加一条<code>style=&quot;overflow: auto&quot;</code>不就好了吗，就像下面这样：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal fade&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myModal&quot;</span> <span class="hljs-attr">tabindex</span>=<span class="hljs-string">&quot;-1&quot;</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;dialog&quot;</span> <span class="hljs-attr">aria-labelledby</span>=<span class="hljs-string">&quot;myModalLabel&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;overflow: auto;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal-dialog modal-lg&quot;</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;document&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal-content&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal-header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal-body&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal-footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>加上之后一试滚动条果然还在。我改完了之后想知道有没有其他的方法就去搜了一下，结果搜到了和我一样的方法，，emmmm那就这样吧。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jianshu.com/p/0f05e628f87b">bootstrap中多个modal弹出的问题解决方案</a></p><p><a href="https://blog.csdn.net/iteye_20240/article/details/82654114">关于bootstrap的modal弹出层嵌套子Modal所引发的血案</a></p><p><a href="https://www.jb51.net/article/119206.htm">bootstrap多层模态框滚动条消失的问题</a></p>]]></content>
    
    
    <categories>
      
      <category>Bootstrap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bootstrap</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于jQuery的简单列表滚动</title>
    <link href="/2020/05/list-rolling/"/>
    <url>/2020/05/list-rolling/</url>
    
    <content type="html"><![CDATA[<p>通过点击按钮列表可以上下滚动，依赖于jQuery。在线demo：<a href="">列表滚动</a></p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p><p><strong>完整代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$</span>) </span>&#123;<br>    $.fn.extend(&#123;<br>    Scroll: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">opt, callback</span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (!opt) <span class="hljs-keyword">var</span> opt = &#123;&#125;;<br>            <span class="hljs-keyword">var</span> _btnUp = $(<span class="hljs-string">&quot;#&quot;</span> + opt.up); <span class="hljs-comment">//向上滚动按钮   </span><br>            <span class="hljs-keyword">var</span> _btnDown = $(<span class="hljs-string">&quot;#&quot;</span> + opt.down); <span class="hljs-comment">//向下滚动按钮   </span><br>            <span class="hljs-keyword">var</span> height = opt.height ? <span class="hljs-built_in">parseInt</span>(opt.height, <span class="hljs-number">10</span>) : <span class="hljs-number">100</span>; <span class="hljs-comment">//每次滚动的行数，默认为一屏，即父容器高度</span><br>            <span class="hljs-keyword">var</span> speed = opt.speed ? <span class="hljs-built_in">parseInt</span>(opt.speed, <span class="hljs-number">10</span>) : <span class="hljs-number">600</span>; <span class="hljs-comment">//卷动速度，数值越大，速度越慢（毫秒）</span><br>                    <br>            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">up</span>(<span class="hljs-params"></span>)</span>&#123;<br>                <span class="hljs-keyword">if</span> (!$(<span class="hljs-string">&quot;#scrollDiv&quot;</span>).is(<span class="hljs-string">&quot;:animated&quot;</span>)) &#123;<br>                    $(<span class="hljs-string">&quot;#scrollDiv&quot;</span>).animate(&#123;<span class="hljs-attr">scrollTop</span>:$(<span class="hljs-string">&quot;#scrollDiv&quot;</span>).scrollTop()-height&#125;,speed)<br>                &#125;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">down</span>(<span class="hljs-params"></span>)</span>&#123;<br>                <span class="hljs-keyword">if</span> (!$(<span class="hljs-string">&quot;#scrollDiv&quot;</span>).is(<span class="hljs-string">&quot;:animated&quot;</span>)) &#123;<br>                    $(<span class="hljs-string">&quot;#scrollDiv&quot;</span>).animate(&#123;<span class="hljs-attr">scrollTop</span>:$(<span class="hljs-string">&quot;#scrollDiv&quot;</span>).scrollTop()+height&#125;,speed)<br>                &#125;<br>            &#125;<br><br>            _btnUp.bind(<span class="hljs-string">&quot;click&quot;</span>, down);<br>            _btnDown.bind(<span class="hljs-string">&quot;click&quot;</span>, up);<br>    &#125;<br>    &#125;);<br>&#125;)(jQuery);<br>$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    $(<span class="hljs-string">&quot;#scrollDiv&quot;</span>).Scroll(&#123; <span class="hljs-attr">height</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">speed</span>: <span class="hljs-number">800</span>,<span class="hljs-attr">up</span>: <span class="hljs-string">&quot;btn2&quot;</span>, <span class="hljs-attr">down</span>: <span class="hljs-string">&quot;btn1&quot;</span> &#125;);<br>&#125;);<br><br></code></pre></div></td></tr></table></figure><p><strong>使用方法：</strong></p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scrollDiv&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br></code></pre></div></td></tr></table></figure><p>CSS：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-id">#scrollDiv</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">list-style</span>: none;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">240</span>,<span class="hljs-number">240</span>,<span class="hljs-number">240</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>&#125;<br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">240</span>,<span class="hljs-number">240</span>,<span class="hljs-number">240</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果想要列表默认滚动到某一位置可以在页面加上下面这句话：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    $(<span class="hljs-string">&quot;#scrollDiv&quot;</span>).scrollTop(<span class="hljs-number">615</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网页选择图片并预览显示</title>
    <link href="/2020/04/select-and-show-img/"/>
    <url>/2020/04/select-and-show-img/</url>
    
    <content type="html"><![CDATA[<h2 id="选择图片并显示"><a href="#选择图片并显示" class="headerlink" title="选择图片并显示"></a>选择图片并显示</h2><h2 id="图片旋转和压缩"><a href="#图片旋转和压缩" class="headerlink" title="图片旋转和压缩"></a>图片旋转和压缩</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/27627436">移动端图片上传旋转、压缩的解决方案</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>获取URL地址最后的id值</title>
    <link href="/2020/04/get-url-id/"/>
    <url>/2020/04/get-url-id/</url>
    
    <content type="html"><![CDATA[<p>有时候项目常常要获取id，有的id就在url的最后面，那么问题来了，怎么才能拿到这个id值呢，经过一番思考之后就有了下面这个方法。</p><h2 id="获取方法和思路"><a href="#获取方法和思路" class="headerlink" title="获取方法和思路"></a>获取方法和思路</h2><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GetUrlParam</span>(<span class="hljs-params">paraName</span>) </span>&#123;<br><span class="hljs-keyword">var</span> url = <span class="hljs-built_in">document</span>.location.toString();<br><span class="hljs-keyword">var</span> arrObj = url.split(<span class="hljs-string">&quot;?&quot;</span>);<br>　　　　<span class="hljs-keyword">if</span> (arrObj.length &gt; <span class="hljs-number">1</span>) &#123;<br>　　　　　　<span class="hljs-keyword">var</span> arrPara = arrObj[<span class="hljs-number">1</span>].split(<span class="hljs-string">&quot;&amp;&quot;</span>);<br>　　　　　　<span class="hljs-keyword">var</span> arr;<br>　　　　　　<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arrPara.length; i++) &#123;<br>　　　　　　　　arr = arrPara[i].split(<span class="hljs-string">&quot;=&quot;</span>);<br>　　　　　　　　<span class="hljs-keyword">if</span> (arr != <span class="hljs-literal">null</span> &amp;&amp; arr[<span class="hljs-number">0</span>] == paraName) &#123;<br>　　　　　　　　　　<span class="hljs-keyword">return</span> arr[<span class="hljs-number">1</span>];<br>　　　　　　　　&#125;<br>　　　　　　&#125;<br>　　　　　　<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>　　　　&#125;<br>　　　　<span class="hljs-keyword">else</span> &#123;<br>　　　　　　<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>　　　　&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>思路：</strong></p><p>这个方法通过传入一个参数（通常是”id”）来获取这个参数等号后面的值。步骤是</p><ol><li>先拿到当前页面的 URL并且转成字符串的形式，</li><li>然后用”?”对这个URL字符串进行分割，将分割得到的字符串数组存入一个变量，</li><li>接着再对这个数组中的多个参数进行分割（如果有多个参数的话，没有就返回原值），</li><li>最后就是循环这个经过处理后的数组，找到符合传入参数的那一项数组元素，并将参数后面的值返回。</li></ol><p>使用方法是</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> id = GetUrlParam(<span class="hljs-string">&quot;id&quot;</span>);<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个方法的适用性并不是很大，通常适合<strong><a href="http://localhost:5500/item.html?id=01">http://localhost:5500/item.html?id=01</a></strong>或者是<strong><a href="http://localhost:5500/item.html?list=3&amp;id=01">http://localhost:5500/item.html?list=3&amp;id=01</a></strong>这样的链接，如果内容再复杂一点或格式差距较大的话就需要另外想办法实现。</p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】利用Three.js制作一个3D动画飞行场景</title>
    <link href="/2020/03/three-js-3D-TheAviator/"/>
    <url>/2020/03/three-js-3D-TheAviator/</url>
    
    <content type="html"><![CDATA[<p>一篇关于探讨使用 Three.js 创建 3D 动画场景的基础教程。</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p><a href="http://tympanus.net/Tutorials/TheAviator/">DEMO</a>     <a href="http://tympanus.net/Tutorials/TheAviator/TheAviator.zip">源码下载</a></p><p>今日，我们将使用 Three.js 创建一个简单的 3D 飞机飞行的动画场景。Three.js 是一个 3D 类库，它能让 WebGL 变得更加简单。由于 GSL 语法的复杂性，对于许多开发人员来说 WebGL 是一个未知的领域。但是有了 Three.js，在浏览器中 3D 的实现变得简单。</p><blockquote><p>(译者注：WebGL 是一项利用 JavaScriptAPI 渲染交互式 3D 电脑图形和 2D 图形的技术，可兼容任何的网页浏览器，无需加装插件。通过 WebGL 的技术，只需要编写网页代码即可实现 3D 图像的展示。GLSL-OpenGL Shading Language 也称作 GLslang ，是一个以 C 语言为基础的高阶着色语言。它是由 OpenGL ARB 所建立，提供开发者对绘图管线更多的直接控制，而无需使用汇编语言或硬件规格语言。详细麻烦谷歌或百度一下～)</p></blockquote><p>在本教程中，我们将创建一个简单的 3D 场景, 在两个主要的部分会有一些交互。在<a href="http://tympanus.net/Tutorials/TheAviator/part1.html">第一部分</a>，我们会讲解 Three.js 的基础和如何创建一个简单的场景。<a href="http://tympanus.net/Tutorials/TheAviator/part2.html">第二部分</a>会详细讲述如何优化模型，如何为场景中的不同元素增添气氛以及更流畅的运动效果。</p><p>由于完整的<a href="http://tympanus.net/Tutorials/TheAviator/">游戏</a>超出了本教程的范围，但是你可以下载或 check out 源码。它包含了许多额外有趣的部分如：碰撞，抓硬币和增加得分。</p><p>在本教程中，我们将重点学习 Three.js 中的一些基础概念。这些基础概念将带你走进 WebGL 这新领域！</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>事不宜迟，我们马上开始~</p><h2 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h2><p>本教程主要采用 Three.js 类库，Three.js 让 WebGL 变得易于使用。从<a href="http://threejs.org/">官网</a>或 <a href="https://github.com/mrdoob/three.js/">GitHub repo</a> check out 获取关于 Three.js 更多的信息。</p><p>第一样要做的事情就是在 HTML <header> 标签中引入 Three.js：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/three.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>然后在 HTML 中需要添加一个元素作为容器。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;world&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>你可以像下面那样写一些简单的样式，让它填满整个 viewport：<br> #world {<br> position: absolute;<br> width: 100%;<br> height: 100%;<br> overflow: hidden;<br> background: linear-gradient(#e4e0ba, #f7d9aa);<br> }<br> 正如你所见的一样，背景有些渐变的效果，就像天空。</p><p>以上是标签和样式！</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><hr><p>如果你已经掌握了一些 JavaScript 的基础知识，使用 Three.js 会变得相当简单。来~我们看看实现不同部分的代码。</p><h3 id="The-Color-Palette"><a href="#The-Color-Palette" class="headerlink" title="The Color Palette"></a>The Color Palette</h3><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>在开始场景编码之前，我觉得定义一个调色板是很有用的。因为在整个项目中会经常使用到。在这个项目中，我们会选择以下这些颜色：</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> Colors = &#123;<br>   red:<span class="hljs-number">0xf25346</span>,    <br>   white:<span class="hljs-number">0xd8d0d1</span>,  <br>   brown:<span class="hljs-number">0x59332e</span>,  <br>   pink:<span class="hljs-number">0xF5986E</span>,   <br>   brownDark:<span class="hljs-number">0x23190f</span>,  <br>   blue:<span class="hljs-number">0x68c3c0</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>虽然 JavaScript 代码十分冗长，但是它的结构很简单。我们需要创建所有主要的函数并放入初始函数中：</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, init, <span class="hljs-literal">false</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-comment">// 创建场景，相机和渲染器</span><br>   createScene(); <br>   <span class="hljs-comment">// 添加光源</span><br>   createLights(); <br>   <span class="hljs-comment">// 添加对象 </span><br>   createPlane();   <br>   createSea(); <br>   createSky(); <br>   <span class="hljs-comment">// 调用循环函数，在每帧更新对象的位置和渲染场景</span><br>   loop();<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="创建场景"><a href="#创建场景" class="headerlink" title="创建场景"></a>创建场景</h3><p>创建一个 Three.js 的项目，我们至少需要以下这些：</p><ol><li><strong>场景：</strong>把这看作一个舞台，将需要呈现的对象都添加进去。</li><li><strong>相机：</strong>在这情况下，我们将使用透视相机，但它也可能是正投影相机。</li><li><strong>渲染器：</strong>使用 WebGL 渲染器显示所有的场景。</li><li><strong>渲染一个或多个对象：</strong> 在我们的例子中，我们会创建飞机，大海，天空（一些云）。</li><li><strong>光源：</strong>有不同类型可用的光源。在我们的项目中，我们主要用到营造氛围的半球光和制造阴影的方向光。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>在 createScene 函数中创建场景，相机以及渲染器。</p><blockquote><p>译者注：</p></blockquote><ul><li><p>Three.js 场景只有一种，THREE.Scene 场景是所有物体的容器。</p></li><li><p>相机决定了场景中哪个角度的景色会显示出来。</p></li><li><p>渲染器决定了渲染的结果应该显示在页面的什么元素上，并以怎样的方式绘制。<br> 有了这三样东西，才能使用相机将对象渲染到页面中。</p><p>var scene, camera, fieldOfView, aspectRatio, nearPlane,<br> farPlane, HEIGHT, WIDTH, renderer, container;<br> function createScene() {<br> // 获得屏幕的宽和高，<br> // 用它们设置相机的纵横比<br> // 还有渲染器的大小<br> HEIGHT = window.innerHeight;<br> WIDTH = window.innerWidth;</p><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment">// 创建场景</span><br>scene = <span class="hljs-keyword">new</span> THREE.Scene();       <br>  <br><span class="hljs-comment">// 在场景中添加雾的效果；样式上使用和背景一样的颜色</span><br>scene.fog = <span class="hljs-keyword">new</span> THREE.Fog(<span class="hljs-number">0xf7d9aa</span>, <span class="hljs-number">100</span>, <span class="hljs-number">950</span>);<br>  <br><span class="hljs-comment">// 创建相机</span><br>aspectRatio = WIDTH / HEIGHT;   <br>fieldOfView = <span class="hljs-number">60</span>;   <br>nearPlane = <span class="hljs-number">1</span>;  <br>farPlane = <span class="hljs-number">10000</span>;<br><span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><br><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> PerspectiveCamera 透视相机</span></span><br><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param fieldOfView 视角</span></span><br><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param aspectRatio 纵横比</span></span><br><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param nearPlane 近平面</span></span><br><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @param farPlane 远平面</span></span><br><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span><br>camera = <span class="hljs-keyword">new</span> THREE.PerspectiveCamera(       <br>  fieldOfView,<br>  aspectRatio,<br>  nearPlane,<br>  farPlane<br>  );<br>  <br><span class="hljs-comment">// 设置相机的位置</span><br>camera.position.x = <span class="hljs-number">0</span>;  <br>camera.position.z = <span class="hljs-number">200</span>;    <br>camera.position.y = <span class="hljs-number">100</span>; <br>  <br><span class="hljs-comment">// 创建渲染器</span><br>renderer = <span class="hljs-keyword">new</span> THREE.WebGLRenderer(&#123; <br><span class="hljs-comment">// 在 css 中设置背景色透明显示渐变色</span><br>  alpha: <span class="hljs-keyword">true</span>, <br><span class="hljs-comment">// 开启抗锯齿，但这样会降低性能。</span><br><span class="hljs-comment">// 不过，由于我们的项目基于低多边形的，那还好 :) </span><br>  antialias: <span class="hljs-keyword">true</span> <br>&#125;);<br>  <br><span class="hljs-comment">// 定义渲染器的尺寸；在这里它会填满整个屏幕</span><br>renderer.setSize(WIDTH, HEIGHT); <br>  <br><span class="hljs-comment">// 打开渲染器的阴影地图</span><br>renderer.shadowMap.enabled = <span class="hljs-keyword">true</span>; <br>  <br><span class="hljs-comment">// 在 HTML 创建的容器中添加渲染器的 DOM 元素</span><br>container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;world&#x27;</span>);   <br>container.appendChild(renderer.domElement);<br>  <br><span class="hljs-comment">// 监听屏幕，缩放屏幕更新相机和渲染器的尺寸</span><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;resize&#x27;</span>, handleWindowResize, <span class="hljs-keyword">false</span>);<br></code></pre></div></td></tr></table></figure><p>}</p></li></ul><p>由于屏幕的尺寸改变，我们需要更新渲染器的尺寸和相机的纵横比。</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleWindowResize</span>(<span class="hljs-params"></span>) </span>&#123; <br>   <span class="hljs-comment">// 更新渲染器的高度和宽度以及相机的纵横比</span><br>   HEIGHT = <span class="hljs-built_in">window</span>.innerHeight; <br>   WIDTH = <span class="hljs-built_in">window</span>.innerWidth;           <br>   renderer.setSize(WIDTH, HEIGHT); <br>   camera.aspect = WIDTH / HEIGHT;        <br>   camera.updateProjectionMatrix();<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h3><p>当创建一个场景时，光源是最棘手的一部分。光源可以奠定整个场景的基调，所以要适当地选取。在这部分我们要尽量制造足以让对象可见的光源。</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> hemisphereLight, shadowLight;<br><span class="hljs-function">function <span class="hljs-title">createLights</span>(<span class="hljs-params"></span>)</span> &#123;<br>   <span class="hljs-comment">// 半球光就是渐变的光；</span><br>   <span class="hljs-comment">// 第一个参数是天空的颜色，第二个参数是地上的颜色，第三个参数是光源的强度</span><br>   hemisphereLight = <span class="hljs-keyword">new</span> THREE.HemisphereLight(<span class="hljs-number">0xaaaaaa</span>,<span class="hljs-number">0x000000</span>, <span class="hljs-number">.9</span>);<br><br>   <span class="hljs-comment">// 方向光是从一个特定的方向的照射</span><br>   <span class="hljs-comment">// 类似太阳，即所有光源是平行的</span><br>   <span class="hljs-comment">// 第一个参数是关系颜色，第二个参数是光源强度</span><br>   shadowLight = <span class="hljs-keyword">new</span> THREE.DirectionalLight(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">.9</span>);<br><br>   <span class="hljs-comment">// 设置光源的方向。  </span><br>   <span class="hljs-comment">// 位置不同，方向光作用于物体的面也不同，看到的颜色也不同</span><br>   shadowLight.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">150</span>, <span class="hljs-number">350</span>, <span class="hljs-number">350</span>);<br><br>   <span class="hljs-comment">// 开启光源投影 </span><br>   shadowLight.castShadow = <span class="hljs-literal">true</span>;<br><br>   <span class="hljs-comment">// 定义可见域的投射阴影</span><br>   shadowLight.shadow.camera.left = <span class="hljs-number">-400</span>;<br>   shadowLight.shadow.camera.right = <span class="hljs-number">400</span>;<br>   shadowLight.shadow.camera.top = <span class="hljs-number">400</span>;<br>   shadowLight.shadow.camera.bottom = <span class="hljs-number">-400</span>;<br>   shadowLight.shadow.camera.near = <span class="hljs-number">1</span>;<br>   shadowLight.shadow.camera.far = <span class="hljs-number">1000</span>;<br><br>   <span class="hljs-comment">// 定义阴影的分辨率；虽然分辨率越高越好，但是需要付出更加昂贵的代价维持高性能的表现。</span><br>   shadowLight.shadow.mapSize.width = <span class="hljs-number">2048</span>;<br>   shadowLight.shadow.mapSize.height = <span class="hljs-number">2048</span>;<br><br>   <span class="hljs-comment">// 为了使这些光源呈现效果，只需要将它们添加到场景中</span><br>   scene.<span class="hljs-keyword">add</span>(hemisphereLight);  <br>   scene.<span class="hljs-keyword">add</span>(shadowLight);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>正如你所见，创建光源用到许多参数。不要再犹豫，大胆尝试用不同的颜色，强度的光源。你发现不同的光源在场景中能够营造有趣的氛围和环境。而且你会找到感觉：如何按照你的需求优化它们。</p><h2 id="用-Three-js-创建对象"><a href="#用-Three-js-创建对象" class="headerlink" title="用 Three.js 创建对象"></a>用 Three.js 创建对象</h2><hr><blockquote><p>如果你熟悉使用 3D 建模软件，你可以先在软件中建立物体且能简单地将它们导入到你的 Three.js 项目中。在本教程中不涉及具体的解决方案。为了更好地了解它们具体是如何工作的。我们使用 Three.js 中现成的几何体创建对象。</p></blockquote><p>Three.js 中已经有大量的现成几何体如：立方体，球体，圆环面，圆柱体以及飞机原型。</p><p>对于我们的项目，所有的对象只需要通过这些几何体组合而成。这非常适合低多边形的风格，而且我们可以不必在 3D 建模软件中创建对象。</p><h3 id="用一个圆柱体代表大海"><a href="#用一个圆柱体代表大海" class="headerlink" title="用一个圆柱体代表大海"></a>用一个圆柱体代表大海</h3><p>我们开始创建大海模型，因为它是我们实现中最简单的对象。为了简单起见，我们将大海看作一个简单的圆柱体放置在屏幕的底部。之后我们再深入研究如何改善大海的外观。<br> 接着，让我们使大海看起来更具吸引力，海浪更加逼真。</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">//首先定义一个大海对象</span><br>Sea = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>   <span class="hljs-comment">// 创建一个圆柱几何体</span><br>   <span class="hljs-comment">// 参数为：顶面半径，底面半径，高度，半径分段，高度分段</span><br>   <span class="hljs-keyword">var</span> geom = <span class="hljs-keyword">new</span> THREE.CylinderGeometry(<span class="hljs-number">600</span>,<span class="hljs-number">600</span>,<span class="hljs-number">800</span>,<span class="hljs-number">40</span>,<span class="hljs-number">10</span>);<br><br>   <span class="hljs-comment">// 在 x 轴旋转几何体</span><br>   geom.applyMatrix(<span class="hljs-keyword">new</span> THREE.Matrix4().makeRotationX(-<span class="hljs-built_in">Math</span>.PI/<span class="hljs-number">2</span>));<br><br>   <span class="hljs-comment">// 创建材质</span><br>   <span class="hljs-keyword">var</span> mat = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;<br>       color:Colors.blue,<br>       transparent:<span class="hljs-literal">true</span>,<br>       opacity:<span class="hljs-number">.6</span>,<br>       shading:THREE.FlatShading,<br>   &#125;);<br><br>   <span class="hljs-comment">// 为了在 Three.js 创建一个物体，我们必须创建网格用来组合几何体和一些材质 </span><br>   <span class="hljs-built_in">this</span>.mesh = <span class="hljs-keyword">new</span> THREE.Mesh(geom, mat);<br><br>   <span class="hljs-comment">// 允许大海对象接收阴影</span><br>   <span class="hljs-built_in">this</span>.mesh.receiveShadow = <span class="hljs-literal">true</span>; <br>&#125;<br><br><span class="hljs-comment">//实例化大海对象，并添加至场景</span><br><span class="hljs-keyword">var</span> sea;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSea</span>(<span class="hljs-params"></span>)</span>&#123;<br>   sea = <span class="hljs-keyword">new</span> Sea();<br><br>   <span class="hljs-comment">// 在场景底部，稍微推挤一下</span><br>   sea.mesh.position.y = -<span class="hljs-number">600</span>;<br><br>   <span class="hljs-comment">// 添加大海的网格至场景</span><br>   scene.add(sea.mesh);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>总结一下创建对象，需要什么东西。<br> 我们需要：</p><ol><li>创建几何体</li><li>创建材质</li><li>将它们传入网格</li><li>将网格添加至场景</li></ol><p>通过这些步骤，我们可以创建许多不同种类的几何体。现在，如果我们把它们组合起来，就可以创建更多复杂的形状。</p><p>在以下步骤中，我们将精确地学习如何创建复杂的形状。</p><h3 id="把简单的正方体组合建造复杂的形状"><a href="#把简单的正方体组合建造复杂的形状" class="headerlink" title="把简单的正方体组合建造复杂的形状"></a>把简单的正方体组合建造复杂的形状</h3><p>云的制作会有一点点复杂，因为他们是由若干个正方体组合而成的一个随机形状。</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx">Cloud = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>   <span class="hljs-comment">// 创建一个空的容器放置不同形状的云</span><br>   <span class="hljs-built_in">this</span>.mesh = <span class="hljs-keyword">new</span> THREE.Object3D();<br><br>   <span class="hljs-comment">// 创建一个正方体</span><br>   <span class="hljs-comment">// 这个形状会被复制创建云</span><br>   <span class="hljs-keyword">var</span> geom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">20</span>,<span class="hljs-number">20</span>,<span class="hljs-number">20</span>);<br><br>   <span class="hljs-comment">// 创建材质；一个简单的白色材质就可以达到效果</span><br>   <span class="hljs-keyword">var</span> mat = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;<br>       color:Colors.white,  <br>   &#125;);<br><br>   <span class="hljs-comment">// 随机多次复制几何体</span><br>   <span class="hljs-keyword">var</span> nBlocs = <span class="hljs-number">3</span>+<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">3</span>);<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;nBlocs; i++ )&#123;<br>    <br>       <span class="hljs-comment">// 通过复制几何体创建网格</span><br>       <span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> THREE.Mesh(geom, mat); <br>    <br>       <span class="hljs-comment">// 随机设置每个正方体的位置和旋转角度</span><br>       m.position.x = i*<span class="hljs-number">15</span>;<br>       m.position.y = <span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">10</span>;<br>       m.position.z = <span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">10</span>;<br>       m.rotation.z = <span class="hljs-built_in">Math</span>.random()*<span class="hljs-built_in">Math</span>.PI*<span class="hljs-number">2</span>;<br>       m.rotation.y = <span class="hljs-built_in">Math</span>.random()*<span class="hljs-built_in">Math</span>.PI*<span class="hljs-number">2</span>;<br>    <br>       <span class="hljs-comment">// 随机设置正方体的大小</span><br>       <span class="hljs-keyword">var</span> s = <span class="hljs-number">.1</span> + <span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">.9</span>;<br>       m.scale.set(s,s,s);<br>    <br>       <span class="hljs-comment">// 允许每个正方体生成投影和接收阴影</span><br>       m.castShadow = <span class="hljs-literal">true</span>;<br>       m.receiveShadow = <span class="hljs-literal">true</span>;<br>    <br>       <span class="hljs-comment">// 将正方体添加至开始时我们创建的容器中</span><br>       <span class="hljs-built_in">this</span>.mesh.add(m);<br>   &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在，我们已经创建一朵云，我们通过复制它来创建天空，而且将其放置在 z 轴任意位置。</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// 定义一个天空对象</span><br>Sky = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>   <span class="hljs-comment">// 创建一个空的容器</span><br>   <span class="hljs-built_in">this</span>.mesh = <span class="hljs-keyword">new</span> THREE.Object3D();<br><br>   <span class="hljs-comment">// 选取若干朵云散布在天空中</span><br>   <span class="hljs-built_in">this</span>.nClouds = <span class="hljs-number">20</span>;<br><br>   <span class="hljs-comment">// 把云均匀地散布</span><br>   <span class="hljs-comment">// 我们需要根据统一的角度放置它们</span><br>   <span class="hljs-keyword">var</span> stepAngle = <span class="hljs-built_in">Math</span>.PI*<span class="hljs-number">2</span> / <span class="hljs-built_in">this</span>.nClouds;<br><br>   <span class="hljs-comment">// 创建云对象</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">this</span>.nClouds; i++)&#123;<br>       <span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> Cloud();<br> <br>       <span class="hljs-comment">// 设置每朵云的旋转角度和位置</span><br>       <span class="hljs-comment">// 因此我们使用了一点三角函数</span><br>       <span class="hljs-keyword">var</span> a = stepAngle*i; <span class="hljs-comment">//这是云的最终角度</span><br>       <span class="hljs-keyword">var</span> h = <span class="hljs-number">750</span> + <span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">200</span>; <span class="hljs-comment">// 这是轴的中心和云本身之间的距离</span><br><br>       <span class="hljs-comment">// 三角函数！！！希望你还记得数学学过的东西 :)</span><br>       <span class="hljs-comment">// 假如你不记得: </span><br>       <span class="hljs-comment">// 我们简单地把极坐标转换成笛卡坐标</span><br>       c.mesh.position.y = <span class="hljs-built_in">Math</span>.sin(a)*h;<br>       c.mesh.position.x = <span class="hljs-built_in">Math</span>.cos(a)*h;<br><br>       <span class="hljs-comment">// 根据云的位置旋转它</span><br>       c.mesh.rotation.z = a + <span class="hljs-built_in">Math</span>.PI/<span class="hljs-number">2</span>;<br><br>       <span class="hljs-comment">// 为了有更好的效果，我们把云放置在场景中的随机深度位置</span><br>       c.mesh.position.z = -<span class="hljs-number">400</span>-<span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">400</span>;<br>    <br>       <span class="hljs-comment">// 而且我们为每朵云设置一个随机大小</span><br>       <span class="hljs-keyword">var</span> s = <span class="hljs-number">1</span>+<span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">2</span>;<br>       c.mesh.scale.set(s,s,s);<br><br>       <span class="hljs-comment">// 不要忘记将每朵云的网格添加到场景中</span><br>       <span class="hljs-built_in">this</span>.mesh.add(c.mesh); <br>   &#125;  <br>&#125;<br><br><span class="hljs-comment">// 现在我们实例化天空对象，而且将它放置在屏幕中间稍微偏下的位置。</span><br><br><span class="hljs-keyword">var</span> sky;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSky</span>(<span class="hljs-params"></span>)</span>&#123;<br>   sky = <span class="hljs-keyword">new</span> Sky();<br>   sky.mesh.position.y = -<span class="hljs-number">600</span>;<br>   scene.add(sky.mesh);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="更加复杂的形状：创建飞机模型"><a href="#更加复杂的形状：创建飞机模型" class="headerlink" title="更加复杂的形状：创建飞机模型"></a>更加复杂的形状：创建飞机模型</h3><p>坏消息是：创建飞机模型的代码有点复杂有点长。但是好消息是：为了创建它我们已经学习了所有应该知道的。这里所有都是关于组合和封装形状的代码。</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> AirPlane = function() &#123;<br><br>   <span class="hljs-keyword">this</span>.mesh = <span class="hljs-keyword">new</span> THREE.Object3D();<br><br>   <span class="hljs-comment">// 创建机舱</span><br>   <span class="hljs-keyword">var</span> geomCockpit = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">60</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">var</span> matCockpit = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;<br>       color: Colors.red,<br>       shading: THREE.FlatShading<br>   &#125;);<br>   <span class="hljs-keyword">var</span> cockpit = <span class="hljs-keyword">new</span> THREE.Mesh(geomCockpit, matCockpit);<br>   cockpit.castShadow = <span class="hljs-literal">true</span>;<br>   cockpit.receiveShadow = <span class="hljs-literal">true</span>;<br>   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(cockpit);<br><br>   <span class="hljs-comment">// 创建引擎</span><br>   <span class="hljs-keyword">var</span> geomEngine = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">var</span> matEngine = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;<br>         color: Colors.white,<br>         shading: THREE.FlatShading<br>   &#125;);<br>   <span class="hljs-keyword">var</span> engine = <span class="hljs-keyword">new</span> THREE.Mesh(geomEngine, matEngine);<br>   engine.position.x = <span class="hljs-number">40</span>;<br>   engine.castShadow = <span class="hljs-literal">true</span>;<br>   engine.receiveShadow = <span class="hljs-literal">true</span>;<br>   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(engine);<br><br>   <span class="hljs-comment">// 创建机尾</span><br>   <span class="hljs-keyword">var</span> geomTailPlane = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">var</span> matTailPlane = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;<br>       color: Colors.red,<br>       shading: THREE.FlatShading<br>   &#125;);<br>   <span class="hljs-keyword">var</span> tailPlane = <span class="hljs-keyword">new</span> THREE.Mesh(geomTailPlane, matTailPlane);<br>   tailPlane.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">-35</span>, <span class="hljs-number">25</span>, <span class="hljs-number">0</span>);<br>   tailPlane.castShadow = <span class="hljs-literal">true</span>;<br>   tailPlane.receiveShadow = <span class="hljs-literal">true</span>;<br>   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(tailPlane);<br><br>    <span class="hljs-comment">// 创建机翼</span><br>   <span class="hljs-keyword">var</span> geomSideWing = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">40</span>, <span class="hljs-number">8</span>, <span class="hljs-number">150</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">var</span> matSideWing = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;<br>       color: Colors.red,<br>       shading: THREE.FlatShading<br>   &#125;);<br>   <span class="hljs-keyword">var</span> sideWing = <span class="hljs-keyword">new</span> THREE.Mesh(geomSideWing, matSideWing);<br>   sideWing.castShadow = <span class="hljs-literal">true</span>;<br>   sideWing.receiveShadow = <span class="hljs-literal">true</span>;<br>   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(sideWing);<br><br>   <span class="hljs-comment">// 创建螺旋桨</span><br>   <span class="hljs-keyword">var</span> geomPropeller = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">var</span> matPropeller = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;<br>       color: Colors.brown,<br>       shading: THREE.FlatShading<br>   &#125;);<br>   <span class="hljs-keyword">this</span>.propeller = <span class="hljs-keyword">new</span> THREE.Mesh(geomPropeller, matPropeller);<br>   <span class="hljs-keyword">this</span>.propeller.castShadow = <span class="hljs-literal">true</span>;<br>   <span class="hljs-keyword">this</span>.propeller.receiveShadow = <span class="hljs-literal">true</span>;<br><br>   <span class="hljs-comment">// 创建螺旋桨的桨叶</span><br>   <span class="hljs-keyword">var</span> geomBlade = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">var</span> matBlade = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;<br>       color: Colors.brownDark,<br>       shading: THREE.FlatShading<br>   &#125;);<br><br>   <span class="hljs-keyword">var</span> blade = <span class="hljs-keyword">new</span> THREE.Mesh(geomBlade, matBlade);<br>   blade.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>   blade.castShadow = <span class="hljs-literal">true</span>;<br>   blade.receiveShadow = <span class="hljs-literal">true</span>;<br>   <span class="hljs-keyword">this</span>.propeller.<span class="hljs-keyword">add</span>(blade);<br>   <span class="hljs-keyword">this</span>.propeller.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">this</span>.propeller);<br>&#125;;<br></code></pre></div></td></tr></table></figure><blockquote><p>这飞机看起来很简单吧？<br> 不要担心它现在的样子，接着我们将看到如何改进形状，让飞机更加好看!</p></blockquote><p>现在，我们可以实例化这飞机并添加到场景中：</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> airplane;<br><br><span class="hljs-function">function <span class="hljs-title">createPlane</span>(<span class="hljs-params"></span>)</span>&#123; <br>   airplane = <span class="hljs-keyword">new</span> AirPlane();<br>   airplane.mesh.scale.<span class="hljs-keyword">set</span>(<span class="hljs-number">.25</span>,<span class="hljs-number">.25</span>,<span class="hljs-number">.25</span>);<br>   airplane.mesh.position.y = <span class="hljs-number">100</span>;<br>   scene.<span class="hljs-keyword">add</span>(airplane.mesh);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><hr><p>我们已经创建了几个对象并把它们添加到我们的场景中了，但是为啥运行游戏的时候什么都看不到呢？那是因为我们需要渲染场景，添加一下这句简单的代码：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">renderer<span class="hljs-selector-class">.render</span>(scene, camera);<br></code></pre></div></td></tr></table></figure><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><hr><p>通过使螺旋桨旋转并转动大海和云让我们的场景更具生命力。<br> 因此我们需要一个无限循环函数</p><blockquote><p>译者注：渲染有两种类型：实时渲染和离线渲染</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span>(<span class="hljs-params"></span>)</span>&#123;<br>   <span class="hljs-comment">// 使螺旋桨旋转并转动大海和云</span><br>   airplane.propeller.rotation.x += <span class="hljs-number">0.3</span>;<br>   sea.mesh.rotation.z += <span class="hljs-number">.005</span>;<br>   sky.mesh.rotation.z += <span class="hljs-number">.01</span>;<br><br>   <span class="hljs-comment">// 渲染场景</span><br>   renderer.render(scene, camera);<br><br>   <span class="hljs-comment">// 重新调用 render() 函数</span><br>   requestAnimationFrame(loop);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>正如你看到的一样，我们将渲染器的 render() 函数移动到 loop() 函数中。因为每次修改物体的位置或颜色之类的属性就需要重新调用一次 render() 函数。</p><h2 id="随着鼠标的移动，添加交互"><a href="#随着鼠标的移动，添加交互" class="headerlink" title="随着鼠标的移动，添加交互"></a>随着鼠标的移动，添加交互</h2><hr><p>在这刻，我们已经看见飞机在场景在中间，接下来我们还需要实现什么呢？就是监听鼠标的移动实现交互。</p><p>当文档加载完成，我们就需要为文档添加监听器，检测鼠标是否有移动。因此，我们需要对初始化函数作出以下的修改。</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params">event</span>)</span>&#123;<br>   createScene();<br>   createLights();<br>   createPlane();<br>   createSea();<br>   createSky();<br><br>   <span class="hljs-comment">//添加监听器</span><br>   <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, handleMouseMove, <span class="hljs-literal">false</span>);<br><br>   loop();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>另外，我们创建一个 mousemove 事件的事件处理函数。</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> mousePos=&#123;x:<span class="hljs-number">0</span>, y:<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-comment">// mousemove 事件处理函数</span><br><br><span class="hljs-function">function <span class="hljs-title">handleMouseMove</span>(<span class="hljs-params"><span class="hljs-keyword">event</span></span>)</span> &#123;<br><br>   <span class="hljs-comment">// 这里我把接收到的鼠标位置的值转换成归一化值，在-1与1之间变化 </span><br>   <span class="hljs-comment">// 这是x轴的公式:</span><br><br>   <span class="hljs-keyword">var</span> tx = <span class="hljs-number">-1</span> + (<span class="hljs-keyword">event</span>.clientX / WIDTH)*<span class="hljs-number">2</span>;<br><br>   <span class="hljs-comment">// 对于 y 轴，我们需要一个逆公式</span><br>   <span class="hljs-comment">// 因为 2D 的 y 轴与 3D 的 y 轴方向相反</span><br><br>   <span class="hljs-keyword">var</span> ty = <span class="hljs-number">1</span> - (<span class="hljs-keyword">event</span>.clientY / HEIGHT)*<span class="hljs-number">2</span>;<br>   mousePos = &#123;x:tx, y:ty&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在获得鼠标的 x , y 坐标值，我们可以适当地移动飞机。</p><p>我们需要修改循环函数并添加一个新功能去更新飞机的位置。</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span>(<span class="hljs-params"></span>)</span>&#123;<br>   sea.mesh.rotation.z += <span class="hljs-number">.005</span>;<br>   sky.mesh.rotation.z += <span class="hljs-number">.01</span>;<br><br>   <span class="hljs-comment">// 更新每帧的飞机</span><br>   updatePlane();<br><br>   renderer.render(scene, camera);<br>   requestAnimationFrame(loop);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatePlane</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>   <span class="hljs-comment">// 让我们在x轴上-100至100之间和y轴25至175之间移动飞机</span><br>   <span class="hljs-comment">// 根据鼠标的位置在-1与1之间的范围，我们使用的 normalize 函数实现（如下）</span><br><br>   <span class="hljs-keyword">var</span> targetX = normalize(mousePos.x, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>   <span class="hljs-keyword">var</span> targetY = normalize(mousePos.y, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">25</span>, <span class="hljs-number">175</span>);<br><br>   <span class="hljs-comment">// 更新飞机的位置</span><br>   airplane.mesh.position.y = targetY;<br>   airplane.mesh.position.x = targetX;<br>   airplane.propeller.rotation.x += <span class="hljs-number">0.3</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalize</span>(<span class="hljs-params">v,vmin,vmax,tmin, tmax</span>)</span>&#123;<br><br>   <span class="hljs-keyword">var</span> nv = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.min(v,vmax), vmin);<br>   <span class="hljs-keyword">var</span> dv = vmax-vmin;<br>   <span class="hljs-keyword">var</span> pc = (nv-vmin)/dv;<br>   <span class="hljs-keyword">var</span> dt = tmax-tmin;<br>   <span class="hljs-keyword">var</span> tv = tmin + (pc*dt);<br>   <span class="hljs-keyword">return</span> tv;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>恭喜你！到这里，已经实现了飞机随着鼠标的移动而移动。到目前为止，看看我们已经实现了什么功能：<a href="http://tympanus.net/Tutorials/TheAviator/part1.html">第一部分的 Demo</a></p><h2 id="几乎完成！"><a href="#几乎完成！" class="headerlink" title="几乎完成！"></a>几乎完成！</h2><p>正如你所看见的，使用 Three.js 对创建 WebGL 内容有非常大的帮助。建立一个场景和渲染一些自定义对象不需要懂太多 WebGL 的知识。到目前为止，我们已经学会一些基础概念和你已经可以开始通过调整一些参数类似光源的强度，雾的颜色和物体的大小掌握了一些基本的诀窍。或许现在你已经很熟悉创建一些新的对象了。</p><p><em>如果你想学习更加深入的技术，请继续阅读。因为你将会学习到如何改进 3D 场景，使飞机飞行得更加平稳，并模仿低多边形海浪对大海的影响。</em></p><h2 id="一架更酷的飞机"><a href="#一架更酷的飞机" class="headerlink" title="一架更酷的飞机"></a>一架更酷的飞机</h2><p>好了~我们之前创建了非常基础的飞机。我们现在知道如何创建对象并组合它们，但是我们仍然需要学习如何修改几何体令其更加符合我们的需求。</p><p>例如正方体，可以移动它的顶点。在我们的案例中，我们需要使它更加像驾驶舱。</p><p>让我们看一下驾驶舱这部分的代码，还有看下我们是如何让他的背部变得更窄的：</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// 驾驶舱</span><br><br><span class="hljs-keyword">var</span> geomCockpit = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">80</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">var</span> matCockpit = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;color:Colors.red, shading:THREE.FlatShading&#125;);<br><br><span class="hljs-comment">// 我们可以通过访问形状中顶点数组中一组特定的顶点</span><br><span class="hljs-comment">// 然后移动它的 x, y, z 属性:</span><br>geomCockpit.vertices[<span class="hljs-number">4</span>].y-=<span class="hljs-number">10</span>;<br>geomCockpit.vertices[<span class="hljs-number">4</span>].z+=<span class="hljs-number">20</span>;<br>geomCockpit.vertices[<span class="hljs-number">5</span>].y-=<span class="hljs-number">10</span>;<br>geomCockpit.vertices[<span class="hljs-number">5</span>].z-=<span class="hljs-number">20</span>;<br>geomCockpit.vertices[<span class="hljs-number">6</span>].y+=<span class="hljs-number">30</span>;<br>geomCockpit.vertices[<span class="hljs-number">6</span>].z+=<span class="hljs-number">20</span>;<br>geomCockpit.vertices[<span class="hljs-number">7</span>].y+=<span class="hljs-number">30</span>;<br>geomCockpit.vertices[<span class="hljs-number">7</span>].z-=<span class="hljs-number">20</span>;<br><br><span class="hljs-keyword">var</span> cockpit = <span class="hljs-keyword">new</span> THREE.Mesh(geomCockpit, matCockpit);<br>cockpit.castShadow = <span class="hljs-literal">true</span>;<br>cockpit.receiveShadow = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(cockpit);<br></code></pre></div></td></tr></table></figure><p>这就是如何操纵一个形状以适应我们的需求的一个例子。</p><p><em>如果你看到飞机的完整代码，你会看到几个对象：更像窗口的对象和更美观的螺旋桨。没有什么复杂的东西，试着调整相关的值找找感觉，制造属于你自己的飞机。</em></p><h2 id="但是，是谁在开飞机呢？"><a href="#但是，是谁在开飞机呢？" class="headerlink" title="但是，是谁在开飞机呢？"></a>但是，是谁在开飞机呢？</h2><hr><p>为我们的飞机添加一个飞行员，就好像添加几个盒子一样容易。</p><p>但是我们只需要一个酷酷的飞行员，头发要很飘逸的！感觉它好像很难实现的样子，但是由于我们开始的时候是在低多边形的场景下开始的，所以这就变得简单多了！尝试通过几个盒子模拟创建飘逸的头发，同时会给予一种独特的感觉。</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>让我们看看源码：</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> Pilot = function()&#123;<br>   <span class="hljs-keyword">this</span>.mesh = <span class="hljs-keyword">new</span> THREE.Object3D();<br>   <span class="hljs-keyword">this</span>.mesh.name = <span class="hljs-string">&quot;pilot&quot;</span>;<br><br>   <span class="hljs-comment">// angleHairs是用于后面头发的动画的属性 </span><br>   <span class="hljs-keyword">this</span>.angleHairs=<span class="hljs-number">0</span>;<br><br>   <span class="hljs-comment">// 飞行员的身体</span><br>   <span class="hljs-keyword">var</span> bodyGeom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>);<br>   <span class="hljs-keyword">var</span> bodyMat = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;color:Colors.brown, shading:THREE.FlatShading&#125;);<br>   <span class="hljs-keyword">var</span> body = <span class="hljs-keyword">new</span> THREE.Mesh(bodyGeom, bodyMat);<br>   body.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">2</span>,<span class="hljs-number">-12</span>,<span class="hljs-number">0</span>);<br>   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(body);<br><br>   <span class="hljs-comment">// 飞行员的脸部</span><br>   <span class="hljs-keyword">var</span> faceGeom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);<br>   <span class="hljs-keyword">var</span> faceMat = <span class="hljs-keyword">new</span> THREE.MeshLambertMaterial(&#123;color:Colors.pink&#125;);<br>   <span class="hljs-keyword">var</span> face = <span class="hljs-keyword">new</span> THREE.Mesh(faceGeom, faceMat);<br>   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(face);<br><br>   <span class="hljs-comment">// 飞行员的头发</span><br>   <span class="hljs-keyword">var</span> hairGeom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>);<br>   <span class="hljs-keyword">var</span> hairMat = <span class="hljs-keyword">new</span> THREE.MeshLambertMaterial(&#123;color:Colors.brown&#125;);<br>   <span class="hljs-keyword">var</span> hair = <span class="hljs-keyword">new</span> THREE.Mesh(hairGeom, hairMat);<br>   <span class="hljs-comment">// 调整头发的形状至底部的边界，这将使它更容易扩展。</span><br>   hair.geometry.applyMatrix(<span class="hljs-keyword">new</span> THREE.Matrix4().makeTranslation(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>));<br><br>   <span class="hljs-comment">// 创建一个头发的容器</span><br>   <span class="hljs-keyword">var</span> hairs = <span class="hljs-keyword">new</span> THREE.Object3D();<br><br>   <span class="hljs-comment">// 创建一个头发顶部的容器（这会有动画效果）</span><br>   <span class="hljs-keyword">this</span>.hairsTop = <span class="hljs-keyword">new</span> THREE.Object3D();<br><br>   <span class="hljs-comment">// 创建头顶的头发并放置他们在一个3*4的网格中</span><br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">12</span>; i++)&#123;<br>       <span class="hljs-keyword">var</span> h = hair.clone();<br>       <span class="hljs-keyword">var</span> col = i%<span class="hljs-number">3</span>;<br>       <span class="hljs-keyword">var</span> row = Math.floor(i/<span class="hljs-number">3</span>);<br>       <span class="hljs-keyword">var</span> startPosZ = <span class="hljs-number">-4</span>;<br>       <span class="hljs-keyword">var</span> startPosX = <span class="hljs-number">-4</span>;<br>       h.position.<span class="hljs-keyword">set</span>(startPosX + row*<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, startPosZ + col*<span class="hljs-number">4</span>);<br>       <span class="hljs-keyword">this</span>.hairsTop.<span class="hljs-keyword">add</span>(h);<br>   &#125;<br>   hairs.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">this</span>.hairsTop);<br><br>   <span class="hljs-comment">// 创建脸庞的头发</span><br>   <span class="hljs-keyword">var</span> hairSideGeom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">12</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>);<br>   hairSideGeom.applyMatrix(<span class="hljs-keyword">new</span> THREE.Matrix4().makeTranslation(<span class="hljs-number">-6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>   <span class="hljs-keyword">var</span> hairSideR = <span class="hljs-keyword">new</span> THREE.Mesh(hairSideGeom, hairMat);<br>   <span class="hljs-keyword">var</span> hairSideL = hairSideR.clone();<br>   hairSideR.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">8</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">6</span>);<br>   hairSideL.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">8</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-6</span>);<br>   hairs.<span class="hljs-keyword">add</span>(hairSideR);<br>   hairs.<span class="hljs-keyword">add</span>(hairSideL);<br><br>   <span class="hljs-comment">// 创建后脑勺的头发</span><br>   <span class="hljs-keyword">var</span> hairBackGeom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>);<br>   <span class="hljs-keyword">var</span> hairBack = <span class="hljs-keyword">new</span> THREE.Mesh(hairBackGeom, hairMat);<br>   hairBack.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">-1</span>,<span class="hljs-number">-4</span>,<span class="hljs-number">0</span>)<br>   hairs.<span class="hljs-keyword">add</span>(hairBack);<br>   hairs.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>);<br><br>   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(hairs);<br><br>   <span class="hljs-keyword">var</span> glassGeom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>);<br>   <span class="hljs-keyword">var</span> glassMat = <span class="hljs-keyword">new</span> THREE.MeshLambertMaterial(&#123;color:Colors.brown&#125;);<br>   <span class="hljs-keyword">var</span> glassR = <span class="hljs-keyword">new</span> THREE.Mesh(glassGeom,glassMat);<br>   glassR.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<br>   <span class="hljs-keyword">var</span> glassL = glassR.clone();<br>   glassL.position.z = -glassR.position.z;<br><br>   <span class="hljs-keyword">var</span> glassAGeom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">11</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>);<br>   <span class="hljs-keyword">var</span> glassA = <span class="hljs-keyword">new</span> THREE.Mesh(glassAGeom, glassMat);<br>   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(glassR);<br>   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(glassL);<br>   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(glassA);<br><br>   <span class="hljs-keyword">var</span> earGeom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);<br>   <span class="hljs-keyword">var</span> earL = <span class="hljs-keyword">new</span> THREE.Mesh(earGeom,faceMat);<br>   earL.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-6</span>);<br>   <span class="hljs-keyword">var</span> earR = earL.clone();<br>   earR.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);<br>   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(earL);<br>   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(earR);<br> &#125;<br><br><span class="hljs-comment">// 移动头发</span><br>Pilot.prototype.updateHairs = function()&#123;<br><br>   <span class="hljs-comment">// 获得头发</span><br>   <span class="hljs-keyword">var</span> hairs = <span class="hljs-keyword">this</span>.hairsTop.children;<br><br>   <span class="hljs-comment">// 根据 angleHairs 的角度更新头发</span><br>   <span class="hljs-keyword">var</span> l = hairs.length;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;l; i++)&#123;<br>       <span class="hljs-keyword">var</span> h = hairs[i];<br>       <span class="hljs-comment">// 每根头发将周期性的基础上原始大小的75%至100%之间作调整。</span><br>       h.scale.y = <span class="hljs-number">.75</span> + Math.cos(<span class="hljs-keyword">this</span>.angleHairs+i/<span class="hljs-number">3</span>)*<span class="hljs-number">.25</span>;<br>   &#125;<br>   <span class="hljs-comment">// 在下一帧增加角度</span><br>   <span class="hljs-keyword">this</span>.angleHairs += <span class="hljs-number">0.16</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>现在让头发动起来，只需要在循环函数里添加以下这句代码。</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">airplane<span class="hljs-selector-class">.pilot</span><span class="hljs-selector-class">.updateHairs</span>();<br></code></pre></div></td></tr></table></figure><h2 id="制作海浪"><a href="#制作海浪" class="headerlink" title="制作海浪"></a>制作海浪</h2><hr><p>或许你已经注意到这大海不像真的大海那样，但更像被压路机压平的表面。</p><p>它需要一些海浪。这需要结合我们之前用到的两项技术来完成：</p><ul><li><p>操纵几何体的顶点就像我们处理飞机的驾驶舱那样</p></li><li><p>每个顶点执行循环移动就像我们移动飞行员的头发一样</p><p>为了制造海浪，我们将围绕圆柱体的初始位置对每个顶点旋转。通过给它们一个随机旋转速度和一个随机距离（旋转半径）。很抱歉，这里还是需要用到一些三角函数！</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p></li></ul><p>让我们对大海作出一些修改：</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx">Sea = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>   <span class="hljs-keyword">var</span> geom = <span class="hljs-keyword">new</span> THREE.CylinderGeometry(<span class="hljs-number">600</span>,<span class="hljs-number">600</span>,<span class="hljs-number">800</span>,<span class="hljs-number">40</span>,<span class="hljs-number">10</span>);<br>   geom.applyMatrix(<span class="hljs-keyword">new</span> THREE.Matrix4().makeRotationX(-<span class="hljs-built_in">Math</span>.PI/<span class="hljs-number">2</span>));<br><br>   <span class="hljs-comment">// 重点：通过合并顶点，我们确保海浪的连续性</span><br>   geom.mergeVertices();<br><br>   <span class="hljs-comment">// 获得顶点</span><br>   <span class="hljs-keyword">var</span> l = geom.vertices.length;<br><br>   <span class="hljs-comment">// 创建一个新的数组存储与每个顶点关联的值：</span><br>   <span class="hljs-built_in">this</span>.waves = [];<br><br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;l; i++)&#123;<br>       <span class="hljs-comment">// 获取每个顶点</span><br>       <span class="hljs-keyword">var</span> v = geom.vertices[i];<br><br>       <span class="hljs-comment">// 存储一些关联的数值</span><br>       <span class="hljs-built_in">this</span>.waves.push(&#123;<span class="hljs-attr">y</span>:v.y,<br>                        x:v.x,<br>                        z:v.z,<br>                        <span class="hljs-comment">// 随机角度</span><br>                        ang:<span class="hljs-built_in">Math</span>.random()*<span class="hljs-built_in">Math</span>.PI*<span class="hljs-number">2</span>,<br>                        <span class="hljs-comment">// 随机距离</span><br>                        amp:<span class="hljs-number">5</span> + <span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">15</span>,<br>                        <span class="hljs-comment">// 在0.016至0.048度/帧之间的随机速度</span><br>                        speed:<span class="hljs-number">0.016</span> + <span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">0.032</span><br>       &#125;);<br>   &#125;;<br>   <span class="hljs-keyword">var</span> mat = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;<br>       color:Colors.blue,<br>       transparent:<span class="hljs-literal">true</span>,<br>       opacity:<span class="hljs-number">.8</span>,<br>       shading:THREE.FlatShading,<br>   &#125;);<br><br>   <span class="hljs-built_in">this</span>.mesh = <span class="hljs-keyword">new</span> THREE.Mesh(geom, mat);<br>   <span class="hljs-built_in">this</span>.mesh.receiveShadow = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 现在我们创建一个在每帧可以调用的函数，用于更新顶点的位置来模拟海浪。</span><br><br>Sea.prototype.moveWaves = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br><br>   <span class="hljs-comment">// 获取顶点</span><br>   <span class="hljs-keyword">var</span> verts = <span class="hljs-built_in">this</span>.mesh.geometry.vertices;<br>   <span class="hljs-keyword">var</span> l = verts.length;<br><br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;l; i++)&#123;<br>       <span class="hljs-keyword">var</span> v = verts[i];<br><br>       <span class="hljs-comment">// 获取关联的值</span><br>       <span class="hljs-keyword">var</span> vprops = <span class="hljs-built_in">this</span>.waves[i];<br><br>       <span class="hljs-comment">// 更新顶点的位置</span><br>       v.x = vprops.x + <span class="hljs-built_in">Math</span>.cos(vprops.ang)*vprops.amp;<br>       v.y = vprops.y + <span class="hljs-built_in">Math</span>.sin(vprops.ang)*vprops.amp;<br><br>       <span class="hljs-comment">// 下一帧自增一个角度</span><br>       vprops.ang += vprops.speed;<br>   &#125;<br><br>   <span class="hljs-comment">// 告诉渲染器代表大海的几何体发生改变</span><br>   <span class="hljs-comment">// 事实上，为了维持最好的性能</span><br>   <span class="hljs-comment">// Three.js 会缓存几何体和忽略一些修改</span><br>   <span class="hljs-comment">// 除非加上这句</span><br>   <span class="hljs-built_in">this</span>.mesh.geometry.verticesNeedUpdate=<span class="hljs-literal">true</span>;<br><br>   sea.mesh.rotation.z += <span class="hljs-number">.005</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>就好像我们对飞行员的头发做的那样，我们在循环函数中添加以下这句代码：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">sea<span class="hljs-selector-class">.moveWaves</span>();<br></code></pre></div></td></tr></table></figure><p>现在好好欣赏海浪吧！</p><h2 id="改善场景中的光源"><a href="#改善场景中的光源" class="headerlink" title="改善场景中的光源"></a>改善场景中的光源</h2><hr><p>在教程中的第一部分，我们已经创建了一些光源。但是想为场景添加更好的气氛，并使阴影更加柔和。为了实现它，我们打算使用环境光源。</p><p>在 createLight 函数中，我们添加以下几行代码：</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// 环境光源修改场景中的全局颜色和使阴影更加柔和</span><br>ambientLight = <span class="hljs-keyword">new</span> THREE.AmbientLight(<span class="hljs-number">0xdc8874</span>, <span class="hljs-number">.5</span>);scene.<span class="hljs-keyword">add</span>(ambientLight);<br></code></pre></div></td></tr></table></figure><p>别再犹豫了！调节环境光源的颜色和强度，它会为你的场景增添独特的润色。</p><h2 id="一次平稳的飞行"><a href="#一次平稳的飞行" class="headerlink" title="一次平稳的飞行"></a>一次平稳的飞行</h2><hr><p>我们的小小飞机已经随着我们的鼠标移动。但它总感觉不像真正的飞行。当飞机改变它的飞行高度，如何改变它的位置和方向时更加流畅就完美了。在教程的最后一点，我们将实现它。</p><p>一个简单的方法就是让它移动到目标位置，通过添加一点点距离让它在每一帧与目标位置分离。</p><p>基本上，相关的代码会这样（这是一个通用的公式，不要马上添加到你的代码中）：</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs undefined">currentPosition +&#x3D; (finalPosition - currentPosition)*fraction;<br></code></pre></div></td></tr></table></figure><p>更现实点来说，飞机旋转也可以根据运动的方向。如果飞机很快的向上移动，它应该很快地沿着逆时针方向旋转；如果飞机慢慢向下移动，它应该慢慢地沿着顺时针方向旋转；为了准确地实现它，我们应该把旋转比例值简单地分配给在目标和飞机位置之间的剩余距离。</p><p>在我们的代码里，updatePlane 函数需要像以下这样：</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatePlane</span>(<span class="hljs-params"></span>)</span>&#123;<br>   <span class="hljs-keyword">var</span> targetY = normalize(mousePos.y,-<span class="hljs-number">.75</span>,<span class="hljs-number">.75</span>,<span class="hljs-number">25</span>, <span class="hljs-number">175</span>);<br>   <span class="hljs-keyword">var</span> targetX = normalize(mousePos.x,-<span class="hljs-number">.75</span>,<span class="hljs-number">.75</span>,-<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br><br>   <span class="hljs-comment">// 在每帧通过添加剩余距离的一小部分的值移动飞机</span><br>   airplane.mesh.position.y += (targetY-airplane.mesh.position.y)*<span class="hljs-number">0.1</span>;<br><br>   <span class="hljs-comment">// 剩余的距离按比例转动飞机</span><br>   airplane.mesh.rotation.z = (targetY-airplane.mesh.position.y)*<span class="hljs-number">0.0128</span>;<br>   airplane.mesh.rotation.x = (airplane.mesh.position.y-targetY)*<span class="hljs-number">0.0064</span>;<br><br>   airplane.propeller.rotation.x += <span class="hljs-number">0.3</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在飞机的移动看起来更加自然和真实。通过修改一下小数值，你可以使用飞机随着鼠标的移动响应速度更加快或更加慢。</p><p>看下我们场景中的最后一个阶段：<a href="http://tympanus.net/Tutorials/TheAviator/part2.html">第二部分 Demo</a></p><p>很好！！！</p><h2 id="接着要干嘛呢？"><a href="#接着要干嘛呢？" class="headerlink" title="接着要干嘛呢？"></a>接着要干嘛呢？</h2><hr><p>如果你看到这，你已经学会 Three.js 中的通用的一些技术了，能够让你创建您的第一个场景。现在你知道如何通过原始几何体创建物体，如何激活它们，以及如何设置一个场景中的光源，你已经知道如何改进你的对象的外观和运动，还有如何调整环境氛围。</p><p>下一步已经超出本文范围了，由于它涉及到更多复杂的技术，它是实现一个<a href="http://tympanus.net/Tutorials/TheAviator/">游戏</a>，大概思路是碰撞，收集点数，液位控制。下载源码，看看实现的思路；你会看到到目前为止你学到过的概念和一些高阶的知识点，你可以研究一下和玩一下。请注意这游戏已经优化了以便桌面使用。</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>但愿，这篇教程帮助你熟悉Three.js和激发你实现属于你自己的项目。让我看到你的创造力；我希望看到你做出什么来~</p><p><a href="http://tympanus.net/Tutorials/TheAviator/">DEMO</a>   <a href="http://tympanus.net/Tutorials/TheAviator/TheAviator.zip">源码下载</a></p><p><strong>本文转自</strong> <a href="https://www.jianshu.com/p/92771817c73f">译文：一个采用 Three.js 的 3D 动画场景制作：飞行者</a>，作者：LeeChingYin</p><p><strong>英文原文链接：</strong><a href="https://tympanus.net/codrops/2016/04/26/the-aviator-animating-basic-3d-scene-threejs/">The Making of “The Aviator”: Animating a Basic 3D Scene with Three.js</a></p>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>JS</tag>
      
      <tag>Three.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】恶俗古风自动生成器</title>
    <link href="/2020/03/gufeng/"/>
    <url>/2020/03/gufeng/</url>
    
    <content type="html"><![CDATA[<p>转自 <a href="https://www.jianshu.com/p/f893291674ca">传送门</a></p><p>原 po：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">关键词：朱砂 天下 杀伐 人家 韶华 风华 繁华 血染 墨染 白衣 素衣 嫁衣 倾城 孤城 空城 旧城<br> 旧人 伊人 心疼 春风 古琴 无情 迷离 奈何 断弦 焚尽 散乱 陌路 乱世 笑靥 浅笑 明眸 轻叹 烟火 <br>一生 三生 浮生 桃花 梨花 落花 烟花 离殇 情殇 爱殇 剑殇 灼伤 仓皇 匆忙 陌上 清商 焚香 墨香 <br>微凉 断肠 痴狂 凄凉 黄梁 未央 成双 无恙 虚妄 凝霜 洛阳 长安 江南 忘川 千年 纸伞 烟雨 回眸 <br>公子 红尘 红颜 红衣 红豆 红线 青丝 青史 青冢 白发 白首 白骨 黄土 黄泉 碧落 紫陌情深缘浅 情深不寿 <br>莫失莫忘 阴阳相隔 如花美眷 似水流年 眉目如画 曲终人散 繁华落尽 不诉离殇 一世长安<br>基本句式：<br><span class="hljs-number">1</span><span class="hljs-selector-class">.xx</span>，xx，xx了xx。 <br><span class="hljs-number">2</span><span class="hljs-selector-class">.xxxx</span>，xxxx，不过是一场xxxx。<br><span class="hljs-number">3</span>.你说xxxx，我说xxxx，最后不过xxxx。<br><span class="hljs-number">4</span><span class="hljs-selector-class">.xx</span>，xx，许我一场xxxx。<br><span class="hljs-number">5</span>一x一x一xx，半x半x半xx。<br><span class="hljs-number">6</span>.你说xxxx xxxx，后来xxxx xxxx。<br><span class="hljs-number">7</span><span class="hljs-selector-class">.xxxx</span>，xxxx，终不敌xxxx。<br>注意事项：<br><span class="hljs-number">1</span>.使用一个句式时一定要多重复几次，形成看起来异常高端的排比句。<br><span class="hljs-number">2</span>.［殇］这个字恶俗到爆，一定要多用。<br><span class="hljs-number">3</span>.不要随意用连词，就让这些动词名词形容词堆在一起，发生奇妙的反应。<br><span class="hljs-number">4</span>.填句子千万不能有逻辑性！填句子千万不能有逻辑性！填句子千万不能有逻辑性！重要的事情说三遍。<br>例句：<br><span class="hljs-number">1</span>.江南烟雨，陌上白衣，不过是一场情深缘浅。伊人回眸，繁华落尽，不过是一场烟火迷离。浮生微凉，白骨成双，不过是一场三世离殇。<br><span class="hljs-number">2</span>.旧城，未央，许我一场墨染清商。乱世，无情，许我一场白衣仓皇。忘川，千年，许我一场奈何成双。<br>end<br>【简直丧心病狂精神污染，po主去吐一吐。】<br></code></pre></div></td></tr></table></figure><p>考虑到，不要逻辑，那么最适合随机函数了。<br> 于是我们得到了一位 Ruby 古风诗人（共 22 行），他每秒都能生产一句古风句子</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby"><span class="hljs-variable">@two_chars_words</span> = %w<span class="hljs-string">&quot;朱砂 天下 杀伐 人家 韶华 风华 繁华 血染 墨染 白衣 素衣 嫁衣 倾城 孤城 空城 旧城 旧人 伊人 心疼 春风 古琴 无情 迷离 奈何 断弦 焚尽 散乱 陌路 乱世 笑靥 浅笑 明眸 轻叹 烟火 一生 三生 浮生 桃花 梨花 落花 烟花 离殇 情殇 爱殇 剑殇 灼伤 仓皇 匆忙 陌上 清商 焚香 墨香 微凉 断肠 痴狂 凄凉 黄梁 未央 成双 无恙 虚妄 凝霜 洛阳 长安 江南 忘川 千年 纸伞 烟雨 回眸 公子 红尘 红颜 红衣 红豆 红线 青丝 青史 青冢 白发 白首 白骨 黄土 黄泉 碧落 紫陌&quot;</span><br><span class="hljs-variable">@four_chars_words</span> = %w<span class="hljs-string">&quot;情深缘浅 情深不寿 莫失莫忘 阴阳相隔 如花美眷 似水流年 眉目如画 曲终人散 繁华落尽 不诉离殇 一世长安&quot;</span><br><span class="hljs-variable">@sentence_model</span> = %w<span class="hljs-string">&quot;xx，xx，xx了xx。 xxxx，xxxx，不过是一场xxxx。 你说xxxx，我说xxxx，最后不过xxxx。 xx，xx，许我一场xxxx。 一x一x一xx，半x半x半xx。 你说xxxxxxxx，后来xxxxxxxx。 xxxx，xxxx，终不敌xxxx。&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_sentence</span></span><br>  model = <span class="hljs-variable">@sentence_model</span>.sample(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>].clone<br>  <span class="hljs-keyword">while</span> model.<span class="hljs-keyword">include</span>?<span class="hljs-string">&#x27;xxxx&#x27;</span><br>    model.sub!(<span class="hljs-regexp">/xxxx/</span>, <span class="hljs-variable">@four_chars_words</span>.sample(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>])<br>  <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">while</span> model.<span class="hljs-keyword">include</span>?<span class="hljs-string">&#x27;xx&#x27;</span><br>    model.sub!(<span class="hljs-regexp">/xx/</span>, <span class="hljs-variable">@two_chars_words</span>.sample(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>])<br>  <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">while</span> model.<span class="hljs-keyword">include</span>?<span class="hljs-string">&#x27;x&#x27;</span><br>    model.sub!(<span class="hljs-regexp">/x/</span>, <span class="hljs-variable">@two_chars_words</span>.sample(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>][rand(<span class="hljs-number">0</span>..<span class="hljs-number">1</span>)])<br>  <span class="hljs-keyword">end</span><br>  puts model<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span><br>  get_sentence<br>  sleep <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>我们来欣赏一些例句：</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs undefined">你说一世长安情深不寿，后来莫失莫忘莫失莫忘。<br>你说繁华落尽似水流年，后来阴阳相隔曲终人散。<br>心疼，繁华，许我一场一世长安。<br>空城，无恙，墨染了忘川。<br>白首，乱世，许我一场繁华落尽。<br>你说阴阳相隔，我说一世长安，最后不过一世长安。<br>如花美眷，情深缘浅，终不敌一世长安。<br>千年，红颜，旧城了灼伤。<br>你说如花美眷，我说情深缘浅，最后不过情深不寿。<br>莫失莫忘，曲终人散，不过是一场繁华落尽。<br>情深不寿，如花美眷，终不敌一世长安。<br>奈何，灼伤，离殇了一生。<br>奈何，空城，红豆了陌上。<br>轻叹，纸伞，梨花了梨花。<br>繁华落尽，曲终人散，不过是一场莫失莫忘。<br>你说一世长安眉目如画，后来如花美眷阴阳相隔。<br>你说情深缘浅，我说不诉离殇，最后不过如花美眷。<br>不诉离殇，不诉离殇，终不敌繁华落尽。<br>繁华落尽，一世长安，终不敌情深缘浅。<br>繁华落尽，莫失莫忘，不过是一场一世长安。<br>轻叹，明眸，明眸了白发。<br>似水流年，曲终人散，终不敌曲终人散。<br>你说阴阳相隔不诉离殇，后来眉目如画繁华落尽。<br>朱砂，嫁衣，许我一场繁华落尽。<br>你说不诉离殇，我说莫失莫忘，最后不过如花美眷。<br>一伤一首一明眸，半伞半繁半陌上。<br>你说繁华落尽眉目如画，后来情深缘浅眉目如画。<br>眉目如画，曲终人散，不过是一场如花美眷。<br>一灼一人一焚香，半迷半衣半散乱。<br>阴阳相隔，莫失莫忘，终不敌莫失莫忘。<br>白衣，红豆，青史了天下。<br>伊人，奈何，奈何了公子。<br>你说情深不寿，我说莫失莫忘，最后不过似水流年。<br>你说不诉离殇莫失莫忘，后来如花美眷情深不寿。<br>白发，浅笑，许我一场不诉离殇。<br>似水流年，莫失莫忘，终不敌似水流年。<br>情深不寿，一世长安，终不敌情深不寿。<br>一世长安，繁华落尽，终不敌莫失莫忘。<br>如花美眷，情深缘浅，不过是一场情深不寿。<br>你说繁华落尽如花美眷，后来如花美眷情深不寿。<br>黄泉，陌上，许我一场似水流年。<br>眉目如画，眉目如画，不过是一场曲终人散。<br>曲终人散，繁华落尽，终不敌曲终人散。<br>你说曲终人散，我说眉目如画，最后不过繁华落尽。<br></code></pre></div></td></tr></table></figure><p>其实句式是次要的，词才是关键。刚导入了一些句式，发现意外地合拍，比如「情殇的素衣，比人家不知道砂到灼伤去了。」「说现在已经黄土了，就把我心疼一番。」「陌里不觉城已年，未央岂是为无情。」「青为什么这么忘川，城和微凉红过多少次了啊」</p><p><em><strong>PS：原链接好像也是转载的，但是找不到原po了，等有时间自己整一个JS版的玩玩。</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>奇奇怪怪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>奇奇怪怪</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行内div之间有缝隙的解决办法</title>
    <link href="/2020/02/div-blank/"/>
    <url>/2020/02/div-blank/</url>
    
    <content type="html"><![CDATA[<p>如果把div的样式设置为<code>display:inline-block</code>并且标签换行的话，同一行内排列的div之间就会出现一道缝隙，不管你设置<code>margin:0;padding:0;border:0;</code>缝隙都不会消失。</p><p>就像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p><p><strong>解决办法1</strong></p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span>&#123;<span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;<span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;<span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;&#125;<br></code></pre></div></td></tr></table></figure><p>就是给div加上一条CSS<code>font-size: 0;</code></p><p>但是此时会出现新问题，就是div内的字体会消失，这个的解决办法就是在这个div内添加子元素，然后为子元素加font-size属性。</p><p><strong>解决办法2</strong></p><p>在每个div后面加上注释</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: blue;&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            1--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: darkorange;&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            2--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: violet;&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            3--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: seagreen;&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            4--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: blue;&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript OOP proto与prototype原型图</title>
    <link href="/2020/02/js-OOP/"/>
    <url>/2020/02/js-OOP/</url>
    
    <content type="html"><![CDATA[<p>1.prototype(函数的原型):函数才有prototype.prototype是一个对象，指向了当前构造函数的引用地址。</p><p>2._proto_(对象的原型对象)：所有对象都有_proto_属性。当用构造函数实例化一个对象时，会将新对象的_proto_属性指上构造函数的prototype.<br> zhangsan._proto_==Person.prototype<br> 所有对象，最终都会指向Object()的prototype</p><p><strong>【原型链】</strong><br> 1.通过构造函数 new出的对象，新对象的_proto_指向构造函数的prototype<br> 2.所有函数的_proto_指上Function的prototype<br> 3.非构造函数 new出的对象（{} new Object() 对象的prototype）的_proto_指向Object的prototype<br> 4.Object的_proto_指向null</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS中this详解</title>
    <link href="/2020/02/js-this/"/>
    <url>/2020/02/js-this/</url>
    
    <content type="html"><![CDATA[<h2 id="this详解"><a href="#this详解" class="headerlink" title="this详解"></a>this详解</h2><p>1、谁最终调用函数，this指向谁，<strong>this指向永远只可能是对象</strong>，不可能是函数<br>this指向谁不取决于this写在哪，而且取决于函数在哪调用<br>this指向的对象，我们称之为函数的上下文context，也叫函数的调用者</p><p>2、<strong>this指向的规律</strong>（与<strong>函数调用的方式</strong>息息相关）<br>this指向的情况，取决于函数调用的方式有哪些：<br>①通过函数名（）直接调用:this指向window</p><p>②通过对象.函数名（）调用:this指向这个对象</p><p>③函数作为数组的一个元素，通过数组下标调用的：this指向这个数组</p><p>④函数作为window内置函数的回调函数调用：this指向window<br><strong>例如setInterval、setTimeout等</strong></p><p>⑤函数作为构造函数，用new关键字调用时，this指向新new出的对象</p><p><strong>不同情况举例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//通过函数名()直接调用,this指向window</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    func();<br>    <br><span class="hljs-comment">//通过对象.函数名（）调用:this指向这个对象</span><br>    <span class="hljs-comment">//狭义对象</span><br>    <span class="hljs-keyword">var</span> obj = &#123;<br>        name:<span class="hljs-string">&quot;obj&quot;</span>,<br>        func1 : func,<br>    &#125;; <span class="hljs-comment">//this 指向obj</span><br>    obj.func1();<br>    <span class="hljs-comment">//广义对象</span><br>        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;div&quot;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.style.backgroundColor = <span class="hljs-string">&quot;red&quot;</span>;<br>    &#125;  <span class="hljs-comment">//this指向div</span><br>        <br><span class="hljs-comment">//函数作为数组的一个元素，通过数组下标调用的：this指向这个数组</span><br>    <span class="hljs-keyword">var</span> arr = [func,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    arr[<span class="hljs-number">0</span>](); <span class="hljs-comment">//this指向arr</span><br>        <br><span class="hljs-comment">//函数作为window内置函数的回调函数调用：this指向window</span><br>    <span class="hljs-built_in">setTimeout</span>(func,<span class="hljs-number">1000</span>);  <span class="hljs-comment">//this指向window</span><br>        <br><span class="hljs-comment">//函数作为构造函数，用new关键字调用时，this指向新new出的对象</span><br>    <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> func();  <span class="hljs-comment">//this指向新new出的obj</span><br>        <br>            <br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS面向对象基础</title>
    <link href="/2020/02/js-object/"/>
    <url>/2020/02/js-object/</url>
    
    <content type="html"><![CDATA[<h2 id="OOP-面向对象编程-基础"><a href="#OOP-面向对象编程-基础" class="headerlink" title="OOP(面向对象编程)基础"></a>OOP(面向对象编程)基础</h2><p><strong>语言的分类：</strong><br>1、面向机器：汇编语言<br>2、面向过程：C语言<br>3、面向对象：java、C++、PHP等<br>面向过程与面向对象<strong>区别：</strong><br><strong>面向过程：</strong>专注于如何去解决一个问题的过程，编程特点是用一个个函数去实现过程操作，没有类与对象的概念<br><strong>面向对象：</strong>专注于由哪一个对象实体去解决这个问题，编程特点是出现了类，由类生成对象<br>面向对象的三大特征：<strong>继承、封装、多态</strong></p><h2 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h2><p><strong>类：</strong><br>一群有相同特征（属性）和行为（方法）的集合 ；</p><p><strong>对象</strong> ：<br>从类中，拿出的具有确定属性值和方法(行为)的个体</p><p><strong>类和对象的关系：</strong><br>类是对象的抽象化，对象是类的具体化；类是抽象的，对象是具体的<br>通俗来说： 类是一个抽象概念，表示具有相同属性和行为的集合，但是类仅仅表明这类群体具有相同的属性，但是没有具体的属性值,而对象是对类的属性进行具体赋值后，而得到的一个具体的个体</p><p><strong>使用类来创建对象</strong></p><p>1、创建一个类（构造函数），类名必须每个单词的首字母大写</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> 类名(<span class="hljs-params">属性<span class="hljs-number">1</span></span>)</span>&#123;<br>  <span class="hljs-built_in">this</span>.属性 = 属性<span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">this</span>.方法 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>  <span class="hljs-comment">//this 指向即将调用当前构造函数的对象</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>2、同过类实例化出一个新的对象：（实例化对象时会执行构造函数）<br><code>var obj = new 类名(属性1value);</code><br>原构造函数中this指向新创建的obj对象<br>obj.方法(); 调用方法<br>obj.属性(); 调用属性</p><p><strong>两个重要的属性：</strong><br>1、constructor：<br>返回当前对象的构造函数，（只有对象才有，返回的是构造函数-类）<br><code>zhangsan.constructor == Person true</code><br>对象的constructor，位于__proto__原型对象上<br>2、instanceof<br>用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。<br><code>object(要检测的对象).constructor(某个构造函数)</code></p><h2 id="广义对象和狭义对象"><a href="#广义对象和狭义对象" class="headerlink" title="广义对象和狭义对象"></a>广义对象和狭义对象</h2><p>狭义对象：只有属性、方法，除此之外没有任何东西<br><code>var obj = &#123;&#125;; var obj = new Object();</code><br>广义对象：除了用字面量声明的基本数据类型之外，换句话说，能够添加属性与方法的变量，就是对象;<br><code>var s = &quot;1&quot;;</code> 不是对象，  <code>var s = new String(&quot;1&quot;);</code> 是对象</p><p><strong>【成员属性与成员方法】</strong><br>在构造函数中，通过”this.属性”声明，或者实例化出对象后，通过”对象.属性”追加的，都属于成员属性或成员方法，成员属性/方法,是属于实例化出的这个对象，通过”对象.属性”调用<br><strong>【静态属性与静态方法】</strong><br>通过”类名.属性名”，”类名.方法名”声明的变量，称为静态属性、静态方法，也叫类属性、类方法<br>成员属性是属于实例化出的对象的，会出现在新对象的属性上，类属性是属于构造函数自己的，不会出现在新对象属性上</p><h2 id="JS中的对象"><a href="#JS中的对象" class="headerlink" title="JS中的对象"></a>JS中的对象</h2><p>JS提供的内置对象有 array、boolean、number、string、date、math、regexp 。通常我们认为JavaScript的对象是键值对的容器。</p><p>虽然JavaScript 是面向对象的语言，但 JavaScript 不使用类。在 JavaScript 中，不会创建类，也不会通过类来创建对象（就像在其他面向对象的语言中那样）。<br>JavaScript 基于 prototype，而不是基于类的。</p><p>JS创建新对象有两种不同的方法：</p><ul><li>定义并创建对象的实例</li><li>使用函数来定义对象，然后创建新的对象实例</li></ul><h3 id="直接创建对象实例"><a href="#直接创建对象实例" class="headerlink" title="直接创建对象实例"></a>直接创建对象实例</h3><p>有两种方式直接创建对象，一种是使用字符通过键值对的方式创建：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>    name:<span class="hljs-string">&quot;鲲虚菜&quot;</span>,<br>    age:<span class="hljs-number">20</span>,<br>    sex:<span class="hljs-string">&quot;男&quot;</span>,<br>    hobby:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;喜欢唱跳rap，打篮球&quot;</span>;<br>      &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>另一种是先创建对象，然后再添加属性和属性值：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">person=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>person.name=<span class="hljs-string">&quot;鲲虚菜&quot;</span>;<br>person.age=<span class="hljs-number">20</span>;<br>person.sex=<span class="hljs-string">&quot;男&quot;</span>;<br>person.hobby=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;喜欢唱跳rap，打篮球&quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="通过函数构造对象"><a href="#通过函数构造对象" class="headerlink" title="通过函数构造对象"></a>通过函数构造对象</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">person</span>(<span class="hljs-params">name,age,sex,hobby</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name=name;<br>    <span class="hljs-built_in">this</span>.age=age;<br>    <span class="hljs-built_in">this</span>.sex=sex;<br>    <span class="hljs-built_in">this</span>.hobby=hobby;<br>    <br>    <span class="hljs-built_in">this</span>.changeHobby=changeHobby;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeHobby</span>(<span class="hljs-params">hobby</span>)</span>&#123;<br>      <span class="hljs-built_in">this</span>.hobby=hobby;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> xkc=<span class="hljs-keyword">new</span> person(<span class="hljs-string">&quot;鲲虚菜&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;男&quot;</span>);<br>xkc.changeHobby(<span class="hljs-string">&quot;喜欢唱跳rap，打篮球&quot;</span>);<br></code></pre></div></td></tr></table></figure><h3 id="对象属性和方法的访问"><a href="#对象属性和方法的访问" class="headerlink" title="对象属性和方法的访问"></a>对象属性和方法的访问</h3><p>对象属性访问方式有两种，一种是对象名.属性名，还有一种是对象名[属性名]，例：<code>person.name;</code>，<code>person[&quot;name&quot;];</code></p><h3 id="JS对象的循环遍历"><a href="#JS对象的循环遍历" class="headerlink" title="JS对象的循环遍历"></a>JS对象的循环遍历</h3><p>可以使用 for…in 语句循环遍历对象的属性。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>点击下面的按钮，循环遍历对象 &quot;person&quot; 的属性。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;showPerson()&quot;</span>&gt;</span>点击这里<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showPerson</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> x;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> txt=<span class="hljs-string">&quot;&quot;</span>;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> person = &#123;</span><br><span class="javascript">    name:<span class="hljs-string">&quot;鲲虚菜&quot;</span>,</span><br>    age:20,<br><span class="javascript">    sex:<span class="hljs-string">&quot;男&quot;</span>,</span><br>  &#125;;<br>  for (x in person)&#123;<br>     txt=txt + person[x];<br>  &#125;<br><span class="javascript">  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML=txt;</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="JS对象属性的删除"><a href="#JS对象属性的删除" class="headerlink" title="JS对象属性的删除"></a>JS对象属性的删除</h3><p>对象无需手动删除，JS提供了一种主动释放对象内存的方法(即对象无用后，自动删除)<br>删除对象的属性：<code>delete 对象名.属性名</code></p><h2 id="对象是引用数据类型"><a href="#对象是引用数据类型" class="headerlink" title="对象是引用数据类型"></a>对象是引用数据类型</h2><p>也就是说，当new出一个对象时，这个obj变量存储的实际上是对象的地址，在对象赋值时，赋的也是地址。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-keyword">var</span> zhangsan = <span class="hljs-keyword">new</span> Person(); <span class="hljs-comment">//zhangsan对象实际存的是地址</span><br><span class="hljs-keyword">var</span> lisi = zhangsan; <span class="hljs-comment">//赋值时，实际是将zhangsan存的地址给了lisi</span><br>lisi.name = <span class="hljs-string">&quot;李四&quot;</span>; <span class="hljs-comment">//李四通过地址修改了对象</span><br><span class="hljs-built_in">console</span>.log(zhangsan.name); <span class="hljs-comment">//张三再通过地址打开对象，实际已经改变了</span><br></code></pre></div></td></tr></table></figure><p>引用数据类型，赋值时传递的是引用（地址）；基本数据类型，赋值时传递的是数据（值）</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript事件</title>
    <link href="/2020/02/js-event/"/>
    <url>/2020/02/js-event/</url>
    
    <content type="html"><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>JavaScript事件其实是发生在HTML元素上的事件，可以是浏览器行为，也可以是用户行为。</p><p>以下是 HTML 事件的实例：</p><ul><li>HTML 页面完成加载</li><li>HTML input 的内容被更改时</li><li>HTML 按钮被点击</li></ul><p>在事件触发时，可以用JavaScript 执行一些代码。<br>HTML 元素中可以添加事件属性，事件通常与函数结合使用，函数不会在事件发生前被执行 (如用户点击按钮)。<br>HTML的事件有鼠标事件、键盘事件、表单事件、动画事件、拖动事件等等很多种，更多事件可以去<a href="https://www.runoob.com/jsref/dom-obj-event.html">这里</a>查看。</p><p>下面说一下关于<strong>键盘事件</strong>的几个问题：</p><p>1、执行顺序：keydown-keypress-keyup<br>2、长按时，会循环执行keydown-keypress<br>3、有keydown事件，不一定有keyup事件（事件触发过程中，鼠标移走点击别的地方，可能没有keyup事件）<br>4、keypress事件只能捕获字母、数字、符号键（空格和回车也是），不能捕获功能键，<br>keydown和keyup基本可以捕获所有功能键（特殊除外）<br>keypress 区分大小写，keydown和keyup不区分；<br>keydown和keyup区分主键盘和小键盘，keypress不区分<br>keypress 只能捕获单键，keydown和keyup可以捕获组合键</p><p><strong>确定键盘触发按键的方法：</strong><br>在触发函数中，传入参数e，代表按键事件；<br>通过e.keyCode确认按键ASCII码值，进而确定按键；<br>兼容浏览器系统的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> evn = e||event; <span class="hljs-comment">//取到键盘事件</span><br><span class="hljs-keyword">var</span> code = evn.keyCode||evn.which||evn.charCode; <span class="hljs-comment">//取到按键编码</span><br></code></pre></div></td></tr></table></figure><h2 id="DOM模型与事件"><a href="#DOM模型与事件" class="headerlink" title="DOM模型与事件"></a>DOM模型与事件</h2><h3 id="DOM模型："><a href="#DOM模型：" class="headerlink" title="DOM模型："></a>DOM模型：</h3><p>在HTML中，每个元素都是一个节点，文档的所有节点组成了DOM 树，DOM又分为几个级别，分别是：</p><p>DOM1：DOM1 级由两个模块组成：DOM核心（DOM Core）和DOM HTML。</p><p>DOM2：<br>在DOM1的基础上扩充了:<br>1、鼠标和用户界面事件、范围、遍历等细分模块<br>2、通过对象接口增加了对CSS（Cascading Style Sheets，层叠样式表）的支持<br>3、DOM核心模块也经过扩展开始支持XML 命名空间</p><p>DOM3：<br>1、以统一方式加载和保存文档的方法——在DOM 加载和保存（DOM Load and Save）模块中定义<br> 2、验证文档的方法——在DOM 验证（DOM Validation）模块中定义<br> 3、开始支持XML 1.0 规范</p><p>DOM0：首先确定的是在DOM标准中并没有DOM 0级的。我们所说的DOM0事件模型其实就是指的是还没有DOM规范的时候给起 的一个名字，DOM0通过on来绑定事件；而DOM2通过addEventListener来绑定事件，DOM2有捕获、目标、冒泡三个事件阶段。</p><p>下面具体说一下DOM0事件模型和DOM2事件模型：</p><h3 id="DOM0事件模型"><a href="#DOM0事件模型" class="headerlink" title="DOM0事件模型"></a>DOM0事件模型</h3><p>DOM0模型分为两种：</p><p>一种是<strong>内联模型：</strong>直接将函数名作为html标签的某个事件属性的属性值<br>eg：<code>&lt;button onclick=&quot;func()&quot;&gt;&lt;/button&gt;</code><br><strong>缺点：</strong>违反了W3C关于html与JS分离的基本原则<br>另一种是<strong>脚本模型：</strong>在JS脚本中通过事件属性进行绑定<br>eg：<code>window.onload = function()&#123;&#125;</code><br>局限性：同一节点只能绑定一个同类型事件</p><h3 id="DOM2事件模型"><a href="#DOM2事件模型" class="headerlink" title="DOM2事件模型"></a>DOM2事件模型</h3><p><strong>1、添加事件绑定：</strong><br>IE10之前：<code>btn.attachEvent(&quot;onclick&quot;,函数);</code><br>其他浏览器：<code>btn.addEventListener(&quot;click&quot;,函数,true/false)</code><br>　　其中，第一个参数为事件<br>　　第三个参数：false为默认，表示事件冒泡；true表示事件捕获<br>兼容写法：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(btn.attachEvent)&#123;<br>　　btn.attachEvent();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>　　btn.addEventListener();<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>优点：同一节点可以添加多个同类型事件的监听器</strong><br><strong>2、取消事件绑定：</strong><br>注：如果要取消事件绑定，那么在绑定事件时，<br>回调函数必须使用有名函数，而不能使用匿名函数，<br>因为在取消事件绑定时，需要传入函数名：<br><code>.removeEventListener(&quot;click&quot;,函数名)</code><br><code>.datachEvent(&quot;onclick&quot;,函数名)</code></p><p>由此可以看出，DOM0和DOM2一个很大区别是DOM0模型的元素绑定多个click最后只执行最后一个click，前面的会被后面的覆盖掉；而DOM2模型的元素绑定可以多个click，不会被覆盖，都会被执行。</p><h2 id="JS中的事件流"><a href="#JS中的事件流" class="headerlink" title="JS中的事件流"></a>JS中的事件流</h2><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>这里有六个套在一起的div，下面解释冒泡和捕获时会用到：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 600px;width: 600px;background-color: aqua;&quot;</span>&gt;</span>第一层<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div2&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 500px;width: 500px;background-color: blueviolet;&quot;</span>&gt;</span>第二层<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div3&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 400px;width: 400px;background-color: chartreuse;&quot;</span>&gt;</span>第三层<br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div4&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 300px;width: 300px;background-color: darkorange;&quot;</span>&gt;</span>第四层<br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div5&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 200px;width: 200px;background-color: firebrick;&quot;</span>&gt;</span>第五层<br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div6&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 100px;width: 100px;background-color: gray;&quot;</span>&gt;</span>第六层<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>1、<strong>事件冒泡：</strong><br>当某DOM元素触发某事件时，会从当前DOM元素开始，逐个触发其祖先元素的同类型事件，直到DOM根节点<br>DOM0模型均为事件冒泡，IE中使用<code>.attachEvent()</code>添加的事件均为冒泡；<br>其他浏览器使用<code>.addEventListener()</code>添加的事件当第三个参数为false时，为冒泡</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;script&gt;<br>  <span class="hljs-keyword">var</span> div1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div1&#x27;</span>),<br>  div2 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div2&#x27;</span>),<br>  div3 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div3&#x27;</span>),<br>  div4 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div4&#x27;</span>),<br>  div5 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div5&#x27;</span>),<br>  div6 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div6&#x27;</span>);<br>  div1.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第一层&quot;</span>)<br>  &#125;, <span class="hljs-literal">false</span>);<br>  div2.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第二层&quot;</span>)<br>  &#125;, <span class="hljs-literal">false</span>);<br>  div3.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第三层&quot;</span>)<br>  &#125;, <span class="hljs-literal">false</span>);<br>  div4.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第四层&quot;</span>)<br>  &#125;, <span class="hljs-literal">false</span>);<br>  div5.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第五层&quot;</span>)<br>  &#125;, <span class="hljs-literal">false</span>);<br>  div6.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第六层&quot;</span>)<br>  &#125;, <span class="hljs-literal">false</span>);<br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure><p>点击中间最小的第六层div时，控制台打印出的结果是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>2、<strong>事件捕获：</strong><br>当某DOM元素触发某事件时，会从DOM根节点开始，逐个触发器祖先元素的同类型事件，直到触发到当前元素为止<br>只有使用<code>.addEventListener()</code>添加事件并设置第三个参数为true时才为捕获</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;script&gt;<br>  <span class="hljs-keyword">var</span> div1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div1&#x27;</span>),<br>  div2 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div2&#x27;</span>),<br>  div3 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div3&#x27;</span>),<br>  div4 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div4&#x27;</span>),<br>  div5 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div5&#x27;</span>),<br>  div6 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div6&#x27;</span>);<br>  div1.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第一层&quot;</span>)<br>  &#125;, <span class="hljs-literal">true</span>);<br>  div2.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第二层&quot;</span>)<br>  &#125;, <span class="hljs-literal">true</span>);<br>  div3.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第三层&quot;</span>)<br>  &#125;, <span class="hljs-literal">true</span>);<br>  div4.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第四层&quot;</span>)<br>  &#125;, <span class="hljs-literal">true</span>);<br>  div5.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第五层&quot;</span>)<br>  &#125;, <span class="hljs-literal">true</span>);<br>  div6.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第六层&quot;</span>)<br>  &#125;, <span class="hljs-literal">true</span>);<br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure><p>点击中间最小的第六层div时，控制台打印出的结果是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>3、<strong>阻断事件冒泡\捕获：</strong><br>阻断捕获只会触发根节点；<br>IE浏览器中将<code>e.cancleBubble</code>属性设为<code>true</code>，<br>其他浏览器调用<code>e.stopPropagation();</code>方法<br>兼容写法:</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myParagraphEventHandler</span>(<span class="hljs-params">e</span>) </span>&#123;<br>　　e = e || <span class="hljs-built_in">window</span>.event;<br>　　<span class="hljs-keyword">if</span> (e.stopPropagation) &#123;<br>　　e.stopPropagation(); <span class="hljs-comment">//IE以外 </span><br>　　&#125; <span class="hljs-keyword">else</span> &#123;<br>　　e.cancelBubble = <span class="hljs-literal">true</span>; <span class="hljs-comment">//IE </span><br>　　&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>4、取消事件的默认行为：</strong><br>IE浏览器中：将<code>e.returnValue</code>属性设为<code>false</code>；<br>其他浏览器：调用<code>e.preventDefault();</code>方法<br>兼容写法：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eventHandler</span>(<span class="hljs-params">e</span>) </span>&#123;<br>　　e = e || <span class="hljs-built_in">window</span>.event;<br>　　<span class="hljs-comment">// 防止默认行为 </span><br>　　<span class="hljs-keyword">if</span> (e.preventDefault) &#123;<br>　　e.preventDefault(); <span class="hljs-comment">//IE以外 </span><br>　　&#125; <span class="hljs-keyword">else</span> &#123;<br>　　e.returnValue = <span class="hljs-literal">false</span>; <span class="hljs-comment">//IE </span><br>　　&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>参考链接：</p><p><a href="https://www.jianshu.com/p/eee5e4a54048">DOM分级详解</a></p><p><a href="https://www.cnblogs.com/greedymonkey/p/6704249.html">JS中的事件</a></p><p><a href="https://www.cnblogs.com/soyxiaobi/p/9498357.html">彻底弄懂JS事件委托的概念和作用</a></p><p><a href="https://www.jb51.net/article/99094.htm">DOM 事件的深入浅出（一）</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网页移动开发的一些知识</title>
    <link href="/2020/02/mobile-develop/"/>
    <url>/2020/02/mobile-develop/</url>
    
    <content type="html"><![CDATA[<h2 id="关于像素的部分基础知识"><a href="#关于像素的部分基础知识" class="headerlink" title="关于像素的部分基础知识"></a>关于像素的部分基础知识</h2><p>移动网页开发中提到的像素主要有三种：CSS像素、物理像素、设备无关像素</p><ul><li>设备物理像素：设备上一个像素点</li><li>设备无关像素：可以与物理像素通过dpr转换。当dpr为1时，设备无关像素=设备物理像素。</li><li>CSS像素：CSS中使用的抽象概念。当页面没有缩放时，CSS像素=设备无关像素。</li></ul><p>其中，dpr（设备像素比） = 物理像素/设备无关像素（逻辑像素宽度*倍率 = 物理像素宽度）</p><h2 id="Viewport"><a href="#Viewport" class="headerlink" title="Viewport"></a>Viewport</h2><h3 id="什么是-Viewport"><a href="#什么是-Viewport" class="headerlink" title="什么是 Viewport?"></a>什么是 Viewport?</h3><p>viewport 是用户网页的可视区域。viewport 翻译为中文可以叫做”视区、视口”。</p><p>手机浏览器是把页面放在一个虚拟的”窗口”（viewport）中，通常这个虚拟的”窗口”（viewport）比屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分。</p><h3 id="设置Viewport"><a href="#设置Viewport" class="headerlink" title="设置Viewport"></a>设置Viewport</h3><ul><li>width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width （为设备的宽度，单位为缩放为 100% 时的 CSS 的像素）。</li><li>height：和 width 相对应，指定高度。</li><li>initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。initial-scale=1.0：默认缩放比为1（目的：让CSS像素=设备无关像素）</li><li>maximum-scale：允许用户缩放到的最大比例。</li><li>minimum-scale：允许用户缩放到的最小比例。</li><li>user-scalable：用户是否可以手动缩放。（貌似在iOS10中的sarifi浏览器失效）</li></ul><p>一个常用的针对移动网页优化过的页面的 viewport meta 标签大致如下：</p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no&quot;/&gt;</code></p><img src="https://images2015.cnblogs.com/blog/1118132/201703/1118132-20170321091710799-377512174.png" srcset="/img/loading.gif" lazyload class="viewport" width="650" height="350" title="viewport 的属性具体介绍" alt="viewport 的属性具体介绍"><center>viewport 的属性具体介绍</center><p>附上一个比较的详细viewport讲解：<a href="https://www.runoob.com/w3cnote/viewport-deep-understanding.html">viewport 深入理解</a></p><h2 id="其他移动端开发可能会用到标签设置"><a href="#其他移动端开发可能会用到标签设置" class="headerlink" title="其他移动端开发可能会用到标签设置"></a>其他移动端开发可能会用到标签设置</h2><p><strong>禁止设备将疑似手机号/邮箱,进行识别。取消点击拨打电话等事件</strong></p><p><code>&lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no,email=no&quot;/&gt;</code></p><p><strong>iOS 添加到主屏幕时，WebAPP的标题</strong></p><p><code>&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;我的第一个WebAPP&quot;&gt;</code></p><p><strong>iOS 添加到主屏幕时，WebAPP的icon图标</strong></p><p><code>&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;图片链接地址&quot; /&gt;</code></p><p><strong>iOS 添加到主屏幕时，启用WebAPP全屏模式，删除顶端地址栏和底部工具栏</strong></p><p><code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;</code></p><p><strong>iOS 添加到主屏幕时，WebAPP顶部状态的样式</strong><br>可选值：<br>black：黑色；default：默认值，白色；black-translucent(半透明)：网页内容充满整个屏幕，顶部状态栏会遮挡网页头部。</p><p><code>&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot;&gt;</code></p><p><strong>设置浏览器使用最新的IE和chrome去编译</strong> </p><p>不是手机端专用，PC网页一般也需要设置</p><p><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;</code></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用GitHub+JsDelivr+PicGo实现免费图床</title>
    <link href="/2020/01/github-jsdelivr-picgo/"/>
    <url>/2020/01/github-jsdelivr-picgo/</url>
    
    <content type="html"><![CDATA[<p>前言<br>微博开始防盗链；各路小众图床晚上基本慢，还有挂掉的风险；大厂图床呢，又是要备案，要实名什么的，还有各种限制，可能还贵。</p><p>但是，由于一些众所周知的原因，GitHub 在大陆的访问速度一直不是很理想，如果你也像我一样将博客，图床等放在 GitHub 托管的话，很可能会有同学投诉访问速度，特别是初次打开的时候，速度着实堪忧。那有没有什么低成本的方案，来加速我们的网站打开速度呢？当然是有的。</p><p>CDN 简介<br>内容分发网络（英语：Content Delivery Network或Content Distribution Network，缩写：CDN）是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。<br>—— Wikipedia<br>简而言之就是让服务器距离大陆较远的 GitHub ，将托管在那里的静态资源缓存到一个近一点的服务器，从而加快访问。</p><p>看了这样的解释你应该能够理解，CDN 虽然能缓解互联压力，可也是要耗费一定的资源的，从而市面上的 CDN 大多是收费的。Cloudflare 虽然有免费 CDN ，可是国内节点致开放给专业版用户使用，价格偏高，而海外的节点又类似负优化，可能还会降低速度。</p><p>jsDelivr<br>jsDelivr是一款公共免费 CDN ，调用多家 CDN 保证全球服务质量、拥有多层缓存和灾后保障 SLA 100 。也是为数不多的有 ICP 备案，提供许多中国节点的海外 CDN 服务商。</p><p>有搜索引擎，支持一键复制文件 URL 和标签，支持分发 NPM、GitHub、WordPress SVN 的文件</p>]]></content>
    
    
    <categories>
      
      <category>GitHub</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 常见循环、分支、嵌套练习</title>
    <link href="/2020/01/js-practice/"/>
    <url>/2020/01/js-practice/</url>
    
    <content type="html"><![CDATA[<h2 id="数字判断："><a href="#数字判断：" class="headerlink" title="数字判断："></a>数字判断：</h2><h3 id="给出一个不低于两位的数字，判断是否是正整数，如果是将此数字反向输出"><a href="#给出一个不低于两位的数字，判断是否是正整数，如果是将此数字反向输出" class="headerlink" title="给出一个不低于两位的数字，判断是否是正整数，如果是将此数字反向输出"></a>给出一个不低于两位的数字，判断是否是正整数，如果是将此数字反向输出</h3><p><strong>思路：</strong><br>判断是否为一个数字：Number(num)结果不为NaN，说明为数字<br>判断一个数字为正数：Number(num)&gt;0为正数<br>判断一个数字为整数：parseInt(num)==parseFloat(num)，不是小数</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>  num=prompt(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//        Number(num)&gt;0  肯定为正数</span><br><span class="hljs-comment">//        parseInt(num)==parseFloat(num)  肯定不是小数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Number</span>(num)&gt;<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-built_in">parseInt</span>(num)==<span class="hljs-built_in">parseFloat</span>(num)) &#123;<br>     <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">while</span> (num&gt;<span class="hljs-number">0</span>)&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">parseInt</span>(num%<span class="hljs-number">10</span>);<br>  <span class="hljs-built_in">document</span>.write(a);<br>  num=<span class="hljs-built_in">parseInt</span>(num/<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="日期判断："><a href="#日期判断：" class="headerlink" title="日期判断："></a>日期判断：</h2><h3 id="判断是否是闰年"><a href="#判断是否是闰年" class="headerlink" title="判断是否是闰年"></a>判断是否是闰年</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> year=prompt(<span class="hljs-string">&quot;输入年份&quot;</span>);<br><span class="hljs-built_in">document</span>.write(year%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;year%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>||year%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>?<span class="hljs-string">&quot;是闰年&quot;</span>:<span class="hljs-string">&quot;不是闰年&quot;</span>);<br></code></pre></div></td></tr></table></figure><h3 id="输入年月日，判断这一天是这一年的第几天"><a href="#输入年月日，判断这一天是这一年的第几天" class="headerlink" title="输入年月日，判断这一天是这一年的第几天"></a>输入年月日，判断这一天是这一年的第几天</h3><p>下面两种方法都假设当年是平年，即2月28天。</p><p>方法一：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> year = <span class="hljs-built_in">parseInt</span>(prompt(<span class="hljs-string">&quot;请输入年份&quot;</span>));<br><span class="hljs-keyword">var</span> month = <span class="hljs-built_in">parseInt</span>(prompt(<span class="hljs-string">&quot;请输入月份&quot;</span>));<br><span class="hljs-keyword">var</span> day = <span class="hljs-built_in">parseInt</span>(prompt(<span class="hljs-string">&quot;请输入日期&quot;</span>));<br>  <span class="hljs-comment">/*假设都是平年，2月28天*/</span><br><span class="hljs-keyword">var</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>;i&lt;month;i++)&#123;<br>  <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>||i==<span class="hljs-number">3</span>||i==<span class="hljs-number">5</span>||i==<span class="hljs-number">7</span>||i==<span class="hljs-number">8</span>||i==<span class="hljs-number">10</span>||i==<span class="hljs-number">12</span>)&#123;<br>    sum+=<span class="hljs-number">31</span>;<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">4</span>||i==<span class="hljs-number">6</span>||i==<span class="hljs-number">9</span>||i==<span class="hljs-number">11</span>)&#123;<br>    sum+=<span class="hljs-number">30</span>;<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">2</span>)&#123;<br>    sum+=<span class="hljs-number">28</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">if</span>((year%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;year%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>||year%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>)&amp;&amp;month&gt;<span class="hljs-number">2</span>)&#123;<br>  sum+=(day+<span class="hljs-number">1</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  sum+=day;<br>&#125;<br><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;您输入的&quot;</span>+year+<span class="hljs-string">&quot;-&quot;</span>+month+<span class="hljs-string">&quot;-&quot;</span>+day+<span class="hljs-string">&quot;为该年的第&quot;</span>+sum+<span class="hljs-string">&quot;天&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>方法二：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> year = <span class="hljs-built_in">parseInt</span>(prompt(<span class="hljs-string">&quot;请输入年份&quot;</span>));<br><span class="hljs-keyword">var</span> month = <span class="hljs-built_in">parseInt</span>(prompt(<span class="hljs-string">&quot;请输入月份&quot;</span>));<br><span class="hljs-keyword">var</span> day = <span class="hljs-built_in">parseInt</span>(prompt(<span class="hljs-string">&quot;请输入日期&quot;</span>));<br>    <span class="hljs-comment">/*假设都是平年，2月28天*/</span><br><span class="hljs-keyword">var</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">switch</span> (month-<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:          <span class="hljs-comment">//每个case后没有break，可以实现天数的累加</span><br>      sum+=<span class="hljs-number">30</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>      sum+=<span class="hljs-number">31</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>      sum+=<span class="hljs-number">30</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>      sum+=<span class="hljs-number">31</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>      sum+=<span class="hljs-number">31</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>      sum+=<span class="hljs-number">30</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>      sum+=<span class="hljs-number">31</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>      sum+=<span class="hljs-number">30</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>      sum+=<span class="hljs-number">31</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      sum+=<span class="hljs-number">28</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>      sum+=<span class="hljs-number">31</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>      sum+=<span class="hljs-number">0</span>;<br>&#125;         <br><span class="hljs-keyword">if</span>((year%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;year%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>||year%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>)&amp;&amp;month&gt;<span class="hljs-number">2</span>)&#123;<br>    sum+=(day+<span class="hljs-number">1</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    sum+=day;<br>&#125;<br><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;您输入的&quot;</span>+year+<span class="hljs-string">&quot;-&quot;</span>+month+<span class="hljs-string">&quot;-&quot;</span>+day+<span class="hljs-string">&quot;为该年的第&quot;</span>+sum+<span class="hljs-string">&quot;天&quot;</span>);<br></code></pre></div></td></tr></table></figure><h2 id="图形输出："><a href="#图形输出：" class="headerlink" title="图形输出："></a>图形输出：</h2><h3 id="利用嵌套循环输出以下图形："><a href="#利用嵌套循环输出以下图形：" class="headerlink" title="利用嵌套循环输出以下图形："></a>利用嵌套循环输出以下图形：</h3><table><thead><tr><th align="center">长方形</th><th align="center">直角三角形</th><th align="center">平行四边形</th><th align="center">菱形</th></tr></thead><tbody><tr><td align="center">****<br />****<br />****<br />****<br />****<br /></td><td align="center">*<br/>**<br/>***<br/>****<br/>*****</td><td align="center">*****<br/>&nbsp;*****<br/>&nbsp;&nbsp;*****<br/>&nbsp;&nbsp;&nbsp;*****<br/>&nbsp;&nbsp;&nbsp;&nbsp;*****</td><td align="center">&nbsp;&nbsp;&nbsp;&nbsp;*<br/>&nbsp;&nbsp;&nbsp;***<br/>&nbsp;&nbsp;*****<br/>*******<br/>&nbsp;&nbsp;*****<br/>&nbsp;&nbsp;&nbsp;***<br/>&nbsp;&nbsp;&nbsp;&nbsp;*</td></tr></tbody></table><p><strong>思路：</strong><br>1、确定图形一共几行，即为外层的循环次数<br>2、确定每行有几种元素，代表有几个内层循环<br>3、确定每种元素的个数，即为每个内层循环的次数</p><p><strong>通常，找出每种元素个数，与行号的关系式，即为当前内层循环的最大值（从1开始循环）</strong></p><p><strong>长方形：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;长方形&quot;</span>+<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>);<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++) &#123;<br>  <span class="hljs-keyword">for</span> (j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">4</span>;j++) &#123;<br>    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;*&quot;</span>);<br>  &#125;<br>  <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>直角三角形：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;三角形&quot;</span>+<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>);<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++) &#123;<br>  <span class="hljs-keyword">for</span> (j=<span class="hljs-number">1</span>;j&lt;=i;j++) &#123;<br>    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;*&quot;</span>);<br>  &#125;<br>  <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>平行四边形：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;平行四边形&quot;</span>+<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>);<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++) &#123;<br>  <span class="hljs-keyword">for</span> (n=<span class="hljs-number">1</span>;n&lt;=i;n++) &#123;<br>    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&amp;nbsp;&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">5</span>;j++) &#123;<br>    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;*&quot;</span>);<br>  &#125;<br>  <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>菱形：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;菱形&quot;</span>+<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">4</span>;i++) &#123;<br>  <span class="hljs-comment">//输出空格</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">4</span>-i;k++)&#123;<br>    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;span style=&#x27;display: inline-block;width: 7px;&#x27;&gt;&lt;/span&gt;&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">//输出*</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>*i-<span class="hljs-number">1</span>;j++)&#123;<br>    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;*&quot;</span>);<br>  &#125;<br>  <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++) &#123;<br>  <span class="hljs-comment">//输出空格</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k=<span class="hljs-number">1</span>;k&lt;=i;k++)&#123;<br>    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;span style=&#x27;display: inline-block;width: 7px;&#x27;&gt;&lt;/span&gt;&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">//输出*</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">7</span>-<span class="hljs-number">2</span>*i;j++)&#123;<br>    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;*&quot;</span>);<br>  &#125;<br>  <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="打印数字等边三角形："><a href="#打印数字等边三角形：" class="headerlink" title="打印数字等边三角形："></a>打印数字等边三角形：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;121<br>&nbsp;&nbsp;&nbsp;&nbsp;12321<br>&nbsp;&nbsp;&nbsp;1234321<br>&nbsp;&nbsp;123454321<br>12345654321</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">4</span>;i++)&#123;<br>  <span class="hljs-comment">// 空格</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">4</span>-i;k++)&#123;<br>    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;span style=&#x27;display: inline-block;width: 8px;&#x27;&gt;&lt;/span&gt;&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 递增</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>    <span class="hljs-built_in">document</span>.write(n);<br>    n++;<br>  &#125;<br>  n-=<span class="hljs-number">2</span>;<br>  <span class="hljs-comment">// 递减</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> m=<span class="hljs-number">1</span>;m&lt;=i-<span class="hljs-number">1</span>;m++)&#123;<br>    <span class="hljs-built_in">document</span>.write(n);<br>    n--;<br>  &#125;<br>  <span class="hljs-comment">// 换行</span><br>  <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>);<br> &#125;<br></code></pre></div></td></tr></table></figure><h3 id="九九乘法表："><a href="#九九乘法表：" class="headerlink" title="九九乘法表："></a>九九乘法表：</h3><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;table width=&#x27;700&#x27;&gt;&quot;</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<br>  <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;tr&gt;&quot;</span>)<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;td&gt;&quot;</span>+i+<span class="hljs-string">&quot;*&quot;</span>+j+<span class="hljs-string">&quot;=&quot;</span>+i*j+<span class="hljs-string">&quot;&lt;/td&gt;&quot;</span>);<br>  &#125;<br>  <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;/tr&gt;&quot;</span>)<br>&#125;<br><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;/table&gt;&quot;</span>)<br><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&quot;</span>);<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub-hosts</title>
    <link href="/2020/01/github-hosts/"/>
    <url>/2020/01/github-hosts/</url>
    
    <content type="html"><![CDATA[<h3 id="修改hosts访问GH"><a href="#修改hosts访问GH" class="headerlink" title="修改hosts访问GH"></a>修改hosts访问GH</h3><p>GitHub有时候不知道为什么会抽风打不开，为了能愉快地上去瞎逛，我特意在此记下通过修改hosts来打开网站：</p><figure class="highlight accesslog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs accesslog"><br># GitHub Start<br><span class="hljs-number">13.250.177.223</span> github.com<br><span class="hljs-number">192.30.253.112</span> github.com<br><span class="hljs-number">192.30.253.119</span> gist.github.com<br><span class="hljs-number">151.101.100.133</span> assets-cdn.github.com<br><span class="hljs-number">151.101.100.133</span> raw.githubusercontent.com<br><span class="hljs-number">151.101.100.133</span> gist.githubusercontent.com<br><span class="hljs-number">151.101.100.133</span> cloud.githubusercontent.com<br><span class="hljs-number">151.101.100.133</span> camo.githubusercontent.com<br><span class="hljs-number">151.101.100.133</span> avatars0.githubusercontent.com<br><span class="hljs-number">151.101.100.133</span> avatars1.githubusercontent.com<br><span class="hljs-number">151.101.100.133</span> avatars2.githubusercontent.com<br><span class="hljs-number">151.101.100.133</span> avatars3.githubusercontent.com<br><span class="hljs-number">151.101.100.133</span> avatars4.githubusercontent.com<br><span class="hljs-number">151.101.100.133</span> avatars5.githubusercontent.com<br><span class="hljs-number">151.101.100.133</span> avatars6.githubusercontent.com<br><span class="hljs-number">151.101.100.133</span> avatars7.githubusercontent.com<br><span class="hljs-number">151.101.100.133</span> avatars8.githubusercontent.com<br><br># GitHub End<br></code></pre></div></td></tr></table></figure><p><strong>PS：</strong>有时候上面的hosts也不好用，要自己现去查一下网站的IP，然后把原来的注释掉添加上新查的。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>gist.github.com 被墙无法访问解决办法</strong><br>windows下 打开C:\Windows\System32\drivers\etc\hosts文件<br>编辑器打开，在最后行添加192.30.253.118 gist.github.com</p><h3 id="另一个不记得出处的方法"><a href="#另一个不记得出处的方法" class="headerlink" title="另一个不记得出处的方法"></a>另一个不记得出处的方法</h3><h4 id="2-1-复制下面的内容"><a href="#2-1-复制下面的内容" class="headerlink" title="2.1 复制下面的内容"></a>2.1 复制下面的内容</h4><figure class="highlight accesslog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs accesslog"># GitHub520 Host Start<br><span class="hljs-number">185.199.108.154</span>               github.githubassets.com<br><span class="hljs-number">199.232.68.133</span>                camo.githubusercontent.com<br><span class="hljs-number">199.232.68.133</span>                github.map.fastly.net<br><span class="hljs-number">199.232.69.194</span>                github.global.ssl.fastly.net<br><span class="hljs-number">140.82.112.3</span>                  github.com<br><span class="hljs-number">140.82.114.5</span>                  api.github.com<br><span class="hljs-number">199.232.68.133</span>                raw.githubusercontent.com<br><span class="hljs-number">199.232.68.133</span>                user-images.githubusercontent.com<br><span class="hljs-number">199.232.68.133</span>                favicons.githubusercontent.com<br><span class="hljs-number">199.232.68.133</span>                avatars5.githubusercontent.com<br><span class="hljs-number">199.232.68.133</span>                avatars4.githubusercontent.com<br><span class="hljs-number">199.232.68.133</span>                avatars3.githubusercontent.com<br><span class="hljs-number">199.232.68.133</span>                avatars2.githubusercontent.com<br><span class="hljs-number">199.232.68.133</span>                avatars1.githubusercontent.com<br><span class="hljs-number">199.232.68.133</span>                avatars0.githubusercontent.com<br># Star me GitHub url: https://github.com/521xueweihan/GitHub520<br># GitHub520 Host End<br></code></pre></div></td></tr></table></figure><p>上面内容会自动定时更新，保证最新有效。数据更新时间：2020-08-14T08:37:38+08:00（内容无变动不会更新）</p><h4 id="2-1-手动方式"><a href="#2-1-手动方式" class="headerlink" title="2.1 手动方式"></a>2.1 手动方式</h4><h5 id="2-1-1-修改-hosts-文件"><a href="#2-1-1-修改-hosts-文件" class="headerlink" title="2.1.1 修改 hosts 文件"></a>2.1.1 修改 hosts 文件</h5><p>hosts 文件在每个系统的位置不一，详情如下：</p><ul><li>Windows 系统：<code>C:\Windows\System32\drivers\etc\hosts</code></li><li>Linux 系统：<code>/etc/hosts</code></li><li>Mac（苹果电脑）系统：<code>/etc/hosts</code></li><li>Android（安卓）系统：<code>/system/etc/hosts</code></li><li>iPhone（iOS）系统：<code>/etc/hosts</code></li></ul><p>修改方法，把第一步的内容复制到文本末尾：</p><ol><li>Windows 使用记事本。</li><li>Linux、Mac 使用 Root 权限：<code>sudo vi /etc/hosts</code>。</li><li>iPhone、iPad 须越狱、Android 必须要 root。</li></ol><h5 id="2-1-2-激活生效"><a href="#2-1-2-激活生效" class="headerlink" title="2.1.2 激活生效"></a>2.1.2 激活生效</h5><p>大部分情况下是直接生效，如未生效可尝试下面的办法，刷新 DNS：</p><ol><li>Windows：在 CMD 窗口输入：<code>ipconfig /flushdns</code></li><li>Linux 命令：<code>sudo rcnscd restart</code></li><li>Mac 命令：<code>sudo killall -HUP mDNSResponder</code></li></ol><p>Tips： 上述方法无效可以尝试重启机器。</p><h4 id="2-2-自动方式"><a href="#2-2-自动方式" class="headerlink" title="2.2 自动方式"></a>2.2 自动方式</h4><p>Tip：推荐 <a href="https://github.com/oldj/SwitchHosts">SwitchHosts</a> 工具管理 hosts</p><p>以 SwitchHosts 为例，看一下怎么使用的，配置参考下面：</p><ul><li>Title: 随意</li><li>Type: <code>Remote</code></li><li>URL: <code>https://gitee.com/xueweihan/codes/6g793pm2k1hacwfbyesl464/raw?blob_name=GitHub520.yml</code></li><li>Auto Refresh: 最好选 <code>1 hour</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS预处理语言less和Sass基础教程</title>
    <link href="/2020/01/less-sass/"/>
    <url>/2020/01/less-sass/</url>
    
    <content type="html"><![CDATA[<p>因为CSS是一门描述性语言，代码中基本没有逻辑性，所以会存在大量重复代码，不便于维护和扩展。因此CSS预处理器就诞生了：less和Sass都是CSS的预处理语言，先用预编译语言进行样式设计，然后再进行编译，生成CSS文件来使用，这些语言的出现让CSS编写起来更加方便快捷，更易于维护。</p><h2 id="less的基础教程"><a href="#less的基础教程" class="headerlink" title="less的基础教程"></a>less的基础教程</h2><p>Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。<br>Less 可以运行在 Node 或浏览器端。</p><h3 id="less变量"><a href="#less变量" class="headerlink" title="less变量"></a>less变量</h3><p>声明变量：使用@变量名: 变量值<br>使用变量：@变量名<br>举例：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less">$length: 100px;<br>$color: red;<br></code></pre></div></td></tr></table></figure><p><strong>less中变量的类型：</strong></p><ul><li>数字类：10px；10</li><li>字符串：<br>​        有引号字符串：”red”<br>​        无引号字符串：哈哈</li><li>颜色类：<br>  颜色名称，如red；<br>  RGB格式，rgb(0,0,0)；<br>  十六进制，如#ffffff</li><li>值列表类型：用逗号或空格分隔</li></ul><p><strong>变量使用原则</strong>：多次频繁出现的值设为变量，还有需要修改的值也可设为变量</p><p> <strong>混合（Mixins）：</strong></p><ul><li>无参混合<br>声明：.name{} ；选择器中调用：.name</li><li>带参混合<br>无默认值声明：.name(@param){} 调用：.name(paramValue);<br>有默认值声明： .name(@param:value){} 调用：.name(paramValue);paramValue可省略</li></ul><p>如果声明时没有默认值，则调用时必须赋值，否则报错<br>无参混合会在css中编译出同名的class选择器，有参的不会</p><p><strong>示例</strong>：</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-class">.class</span>&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><span class="hljs-variable">@mixin</span> hong&#123;<br>    <span class="hljs-attribute">color</span>: blue;<br>&#125;<br>#div1&#123;<br>    width: $length;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-variable">@extend</span>.class;<br>    border-#&#123;$left&#125;:10px solid blue ;<br>    <span class="hljs-variable">@include</span> hong;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="less匹配模式"><a href="#less匹配模式" class="headerlink" title="less匹配模式"></a>less匹配模式</h3><p>使用混合进行匹配，类似if结构：<br><strong>声明：</strong>.name(条件一，参数){} .name(条件二，参数){} .name(条件三，参数){}<br><strong>调用：</strong>.name(条件值，参数值)<br><strong>匹配规则</strong>：根据调用时提供的条件值，寻找与之匹配的Mixins执行，其中@_表示永远需要执行的部分</p><h3 id="less的运算与嵌套"><a href="#less的运算与嵌套" class="headerlink" title="less的运算与嵌套"></a>less的运算与嵌套</h3><p><strong>LESS中的运算</strong>：<br>使用运算符+、-、/、* 计算，可以带单位也可不带<br> 进行颜色（十六进制形式）运算时，红绿蓝分开计算，即每组两位之间可以进位，组间不可进位<br><strong>LESS中的嵌套</strong>：<br>保留html中的代码结构，嵌套默认是后代选择器，如果需要子代选择器，则在子代前面加&gt;<br>&amp;表示上一层，&amp;:hover表示上一层的hover事件，&amp;主要用来进行伪类事件的设置</p><p><strong>代码嵌套示例</strong>：</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">section</span>&#123;<br>    <span class="hljs-selector-tag">p</span>&#123;<br>        <span class="hljs-attribute">color</span>: red;<br>        <span class="hljs-attribute">background-color</span>: cyan;<br>    &#125;<br>    <span class="hljs-selector-tag">ul</span>&#123;<br>        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">list-style</span>: none;<br>        <span class="hljs-selector-tag">li</span>&#123;<br>            <span class="hljs-attribute">float</span>: left;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>            <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>            <span class="hljs-attribute">border</span>: &#123;<br>                <span class="hljs-attribute">color</span>: green;<br>                style:solid;<br>                <span class="hljs-attribute">width</span>: <span class="hljs-number">5px</span>;<br>            &#125;;<br>            <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>                <span class="hljs-attribute">background-color</span>: yellow;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="less注释方式"><a href="#less注释方式" class="headerlink" title="less注释方式"></a>less注释方式</h3><p>less的注释方式有两种：<br>一种是使用双斜杠（//）来注释，使用这种方式注释的内容不会被编译<br>另一种是使用/**/，但可以被编译</p><h2 id="Sass的基础教程"><a href="#Sass的基础教程" class="headerlink" title="Sass的基础教程"></a>Sass的基础教程</h2><blockquote><p>世界上最成熟、最稳定、最强大的专业级CSS扩展语言</p></blockquote><p>sass是最早的css预处理语言，有比less更为强大的功能。但因其一开始的缩进式语法并不能被开发者们接受，所以使用率不高，不过由于其强大的功能和Ruby on Rails 的大力推动，逐渐被更多开发者使用。</p><p>sass是采用的Ruby语言编写的一款css预处理语言，它诞生于2007年，是最早成熟css预处理语言。最初它是为了配合haml而设计的，因此有着和haml一样的缩进式风格。</p><p>sass从第三代开始，放弃了缩进式风格，并且完全向下兼容普通的css代码，这一代的sass也被称为scss。</p><p><strong>特色功能 (Features)</strong></p><ul><li>完全兼容 CSS3</li><li>在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能</li><li>通过<em>函数</em>进行颜色值与属性值的运算</li><li>提供*控制指令 (control directives)*等高级功能</li><li>自定义输出格式</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>使用$变量名:变量值 来声明变量，即变量以$开头<br>如果变量需要在字符串中嵌套，则需要使用#{}包括，如</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss"><span class="hljs-variable">$left</span><span class="hljs-selector-pseudo">:left</span>;<br><span class="hljs-selector-class">.div1</span> &#123;<br>    <span class="hljs-attribute">border</span>-#&#123;<span class="hljs-variable">$left</span>&#125;-radius: <span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">margin</span>: (<span class="hljs-number">14px</span>/<span class="hljs-number">2</span>);<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50px</span> + <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-variable">$var</span> * <span class="hljs-number">10%</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>需要注意的是，计算时会将单位也进行运算，所以使用时需注意<strong>最终单位</strong>：100px*10px = 1000 px<sup>2</sup></p><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><ul><li><p><strong>选择器嵌套</strong>　<code>ul&#123; li&#123;&#125; &#125;</code> 后代选择、<code>ul&#123; &gt;li&#123;&#125; &#125;</code> 子代选择、</p><p>&amp;表示外层的父选择器 <code>div&#123; ul&#123; li&#123; &amp;==&quot;div ul li&quot; &#125; &#125; &#125;</code></p></li><li><p><strong>属性嵌套</strong>　　<code>p&#123;border:&#123;color: green;style:solid;width: 5px;&#125;&#125;</code>，注意里面的border要加上冒号</p></li><li><p><strong>伪类嵌套</strong>　　<code>ul&#123; li&#123; &amp;:hover&#123;&#125; &#125; &#125;</code></p></li></ul><h3 id="混合、继承、占位符"><a href="#混合、继承、占位符" class="headerlink" title="混合、继承、占位符"></a>混合、继承、占位符</h3><p><strong>混合宏</strong>：<br>声明：@mixin name($param:value){} 调用：@include name(value);<br> 声明时可以有参可以无参，可以带默认值也可不带，但调用时必须符合声明规范，同less<br>优点：可以传参；缺点：会将混合宏中代码，copy到对应的选择器中，产生冗余代码<br><strong>继承</strong>：<br>声明：.class{} 调用:@extend .class;<br>优点：继承的相同代码，会提取到并集选择器中，减少冗余代码；<br>缺点：无法进行传参，会在CSS中生成一个同名class<br><strong>占位符</strong>：<br>声明：%class{} 调用：@extend %class;<br>优点：继承的相同代码，会提取到并集选择器中，减少冗余代码，不会在CSS中生成一个同名class；<br>缺点：无法进行传参<br><strong>综上，当需要传递参数时用混合宏，当有现成class时用继承，当不需要参数也不需要class时用占位符</strong></p><h3 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h3><p><strong>if条件结构</strong>：<br> <code>@if条件&#123;&#125; @else&#123;&#125;</code><br><strong>for 循环结构</strong>:<br><code> @for $i from 1 to/through 10;</code> (to不包括10，through包括10 )<br><strong>whlie 循环结构</strong>：</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss"><span class="hljs-variable">$j</span>;<br><span class="hljs-keyword">@while</span> <span class="hljs-variable">$j</span>&lt;<span class="hljs-number">10</span>&#123;<span class="hljs-selector-class">.while</span> #&#123;<span class="hljs-variable">$j</span>&#125;&#123;<br><span class="hljs-attribute">background-color</span>: red;<br>&#125;<span class="hljs-variable">$j</span>:<span class="hljs-variable">$j</span>+<span class="hljs-number">1</span>;&#125;<br></code></pre></div></td></tr></table></figure><p><strong>each循环遍历</strong><br><code>@each item in a,b,c,d&#123;&#125;</code></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Sass允许用户自己编写函数使用</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">　　<span class="hljs-keyword">@function</span> double(<span class="hljs-variable">$n</span>) &#123;<br>　　　　<span class="hljs-keyword">@return</span> <span class="hljs-variable">$n</span> * <span class="hljs-number">2</span>;<br>　　&#125;<br>　　<span class="hljs-selector-id">#sidebar</span> &#123;<br>　　　　<span class="hljs-attribute">width</span>: double(<span class="hljs-number">5px</span>);<br>　　&#125;<br></code></pre></div></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Sass和less一样，有两种注释方法</p><p>一种是单行注释，<code>//注释一</code> 不会被输出到编译后的CSS文件中；<br>另一种是多行注释，<code>/*注释二*/</code> 这种注释会保留在编译后的文件中；<br>另外还有一种算是多行注释的升级版，<code>/*!注释三 重要注释*/</code> 这种注释即使是压缩模式编译，也会被保留，通常可以用于声明版权信息。</p><h2 id="两种预处理语言的编译方式"><a href="#两种预处理语言的编译方式" class="headerlink" title="两种预处理语言的编译方式"></a>两种预处理语言的编译方式</h2><p>less和Sass的编译方式大同小异，他们可以通过下面几种方式进行编译：</p><h3 id="1、命令行方式"><a href="#1、命令行方式" class="headerlink" title="1、命令行方式"></a>1、命令行方式</h3><p>使用这种方式编译需要先安装less和Sass，less可以通过npm安装，Sass的安装方式比较多，不仅可以通过npm安装，也可以通过Ruby安装，更多安装方式可以去<a href="https://sass-lang.com/install">官网</a>查看。安装成功后就能使用命令行直接编译文件了。</p><p>less的编译命令</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">lessc styles.<span class="hljs-keyword">less</span> styles.css<br></code></pre></div></td></tr></table></figure><p>Sass的编译命令</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">sass <span class="hljs-keyword">test</span>.scss <span class="hljs-keyword">test</span>.css<br></code></pre></div></td></tr></table></figure><p>SASS提供四个<a href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#output_style">编译风格</a>的选项：</p><ul><li>nested：嵌套缩进的css代码，它是默认值。</li><li>expanded：没有缩进的、扩展的css代码。</li><li>compact：简洁格式的css代码。</li><li>compressed：压缩后的css代码。</li></ul><p>生产环境当中，一般使用最后一个选项。</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">sass --style compressed <span class="hljs-keyword">test</span>.sass <span class="hljs-keyword">test</span>.css<br></code></pre></div></td></tr></table></figure><p>命令行方式也可以对某个文件或者目录进行监听，在源文件产生变动时自动生成编译后版本，less可以通过安装一个插件watcher-lessc来监听编译，Sass直接使用命令行就能实现：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">　　<span class="hljs-regexp">//</span> 监听一个文件<br>　　sass --watch input.scss:output.css<br><br>　　<span class="hljs-regexp">//</span> 监听一个文件夹目录<br>　　sass --watch app<span class="hljs-regexp">/sass:public/</span>stylesheets<br></code></pre></div></td></tr></table></figure><h3 id="2、使用编译软件Koala编译"><a href="#2、使用编译软件Koala编译" class="headerlink" title="2、使用编译软件Koala编译"></a>2、使用编译软件Koala编译</h3><p>Koala是一个国产免费前端预处理器语言图形编译工具，支持Less、Sass、Compass、CoffeeScript，帮助web开发者更高效地使用它们进行开发。跨平台运行，完美兼容windows、linux、mac。</p><p>前往<a href="http://koala-app.com/index-zh.html">官网</a>下载安装，安装完成打开显示如下界面：</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/banner01.gif" srcset="/img/loading.gif" lazyload alt="img"></p><p>点击左侧的+号添加需要编译的文件夹，也可以直接将文件夹拖动进来，添加完成后就可以对文件进行编译了，点击一个文件可以设置编译选项。编译时软件默认是将less文件编译到同级目录下，如果想要改变可以在文件上进行单个文件的改变；缺点是不能实现批量的改变。使用koala的好处是有错误提示，可以比较方便的获取错误信息。</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/banner01.gif" srcset="/img/loading.gif" lazyload alt="img"></p><h3 id="3、使用开发工具编译"><a href="#3、使用开发工具编译" class="headerlink" title="3、使用开发工具编译"></a>3、使用开发工具编译</h3><p>可以使用一些常用的开发工具或开发工具中的某些插件来直接自动编译，如webstorm、sublime插件SASS-Build、vscode插件easy sass等等，具体操作方法自行搜索。</p><h3 id="4、使用JS文件"><a href="#4、使用JS文件" class="headerlink" title="4、使用JS文件"></a>4、使用JS文件</h3><p>这一条针对的是less文件，因为less基于js。去官网下载less.js文件，然后在文件中引入，或者直接使用CDN引入：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;less/test.less&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/less&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//cdnjs.cloudflare.com/ajax/libs/less.js/2.5.3/less.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>使用时注意以下几点：<br>link引入的是less文件，路径直接是less所在位置即可；<br>link内一定要注明type类型，因为默认为css；<br>顺序一定要是引入的less文件在less.js文件上面。</p><h3 id="5、其他编译方式"><a href="#5、其他编译方式" class="headerlink" title="5、其他编译方式"></a>5、其他编译方式</h3><p>前端自动化软件codekit、Grunt打造前端自动化工作流grunt-sass、Gulp打造前端自动化工作流gulp-ruby-sass等，具体用法自行搜索。</p><h2 id="less与Sass的区别"><a href="#less与Sass的区别" class="headerlink" title="less与Sass的区别"></a>less与Sass的区别</h2><table><thead><tr><th align="center">区别</th><th align="center">Sass</th><th align="center">less</th></tr></thead><tbody><tr><td align="center">环境</td><td align="center">Sass基于Ruby，需要安装Ruby。属于服务端处理。</td><td align="center">Less和Sass在Ruby中构建相似，但它已被移植到JavaScript中。less编译通过引入less.js文件或通过编译软件编译成css文件再将css文件放入项目中。属于客户端处理。</td></tr><tr><td align="center">声明变量</td><td align="center">Sass使用$</td><td align="center">Less使用@</td></tr><tr><td align="center">输出格式</td><td align="center">nested：嵌套缩进的css代码；expanded：展开的多行css代码；compact：简洁格式的css代码；compressed：压缩后的css代码</td><td align="center">Less无输出格式</td></tr><tr><td align="center">继承</td><td align="center">sass的继承：@extend</td><td align="center">less的继承：类似于mixins .block</td></tr></tbody></table><p>以上是部分Sass和less的区别，仅供参考。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://lesscss.org/">less官网</a></p><p><a href="https://less.bootcss.com/">less中文网</a></p><p><a href="http://koala-app.com/index-zh.html">Koala官网</a></p><p><a href="https://www.sass.hk/">Sass中文网</a></p><p><a href="http://www.ruanyifeng.com/blog/2012/06/sass.html">SASS用法指南 - 阮一峰的网络日志</a></p><p><a href="https://www.jianshu.com/p/96430f2e5161">sass和less的区别</a></p><p><a href="https://blog.csdn.net/gaomengwang/article/details/80573915">Sass与Less区别</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】弹性盒子（Flex Box）布局语法教程</title>
    <link href="/2020/01/flex-layout/"/>
    <url>/2020/01/flex-layout/</url>
    
    <content type="html"><![CDATA[<p>网页布局（layout）是 CSS 的一个重点应用。</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/">垂直居中</a>就不容易实现。</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>Flex 布局将成为未来布局的首选方案。本文介绍它的语法，<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">下一篇文章</a>给出常见布局的 Flex 写法。网友 <a href="http://vgee.cn/">JailBreak</a> 为本文的所有示例制作了 <a href="http://static.vgee.cn/static/index.html">Demo</a>，也可以参考。</p><p>以下内容主要参考了下面两篇文章：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">A Complete Guide to Flexbox</a> 和 <a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties">A Visual Guide to CSS3 Flexbox Properties</a>。</p><h2 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为 Flex 布局。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><p>行内元素也可以使用 Flex 布局。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>  <span class="hljs-attribute">display</span>: inline-flex;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>  <span class="hljs-attribute">display</span>: -webkit-flex; <span class="hljs-comment">/* Safari */</span><br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h2 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h2><p>以下6个属性设置在容器上。</p><blockquote><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul></blockquote><h3 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><p><img src="https://github.com/greedymonkey/image/blob/master/flex/bg2015071005.png?raw=true" srcset="/img/loading.gif" lazyload alt="img"></p><p>它可能有4个值。</p><blockquote><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul></blockquote><h3 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><blockquote><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>  <span class="hljs-attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><p>它可能取三个值。</p><p>（1）<code>nowrap</code>（默认）：不换行。</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>（2）<code>wrap</code>：换行，第一行在上方。</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>（3）<code>wrap-reverse</code>：换行，第一行在下方。</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><h3 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><blockquote><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></blockquote><h3 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><blockquote><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul></blockquote><h3 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>该属性可能取6个值。</p><blockquote><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul></blockquote><h2 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h2><p>以下6个属性设置在项目上。</p><blockquote><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul></blockquote><h3 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">order</span>: &lt;integer&gt;;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><h3 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-grow</span>: &lt;number&gt;; <span class="hljs-comment">/* default 0 */</span><br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-shrink</span>: &lt;number&gt;; <span class="hljs-comment">/* default 1 */</span><br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="hljs-comment">/* default auto */</span><br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex</span>: none | [ &lt;<span class="hljs-string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="hljs-string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="hljs-string">&#x27;flex-basis&#x27;</span>&gt; ]<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;<br>&#125;<br></code></pre></div></td></tr></table></figure></blockquote><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p><p>（完）</p><p><strong>转自</strong> </p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">阮一峰的语法日志——Flex 布局教程：语法篇</a></p><p><strong>附</strong> </p><p>英文版flex布局教程 <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">A Complete Guide to Flexbox</a></p><p> <a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">Flex 布局教程：实例篇</a> </p>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>Web</tag>
      
      <tag>Flex Box</tag>
      
      <tag>弹性布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>banner图滚动的两种方式</title>
    <link href="/2020/01/banner/"/>
    <url>/2020/01/banner/</url>
    
    <content type="html"><![CDATA[<h2 id="利用CSS动画效果制作循环滚动的动画"><a href="#利用CSS动画效果制作循环滚动的动画" class="headerlink" title="利用CSS动画效果制作循环滚动的动画"></a>利用CSS动画效果制作循环滚动的动画</h2><h3 id="设置图片宽度"><a href="#设置图片宽度" class="headerlink" title="设置图片宽度"></a>设置图片宽度</h3><p>以1920px的图片为例，首先要用一个div将滚动的banner图包起来，比如像下面这样：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;banner&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/banner.jpg&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>接下来对图片宽度和高度进行调整：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">&lt;style type=&quot;text/css&quot; &gt;<br>*&#123;<br><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-id">#banner</span>&#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;  <span class="hljs-comment">/*宽度为浏览器的100%*/</span><br><span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;  <span class="hljs-comment">/*原则上,高度=图片高度*/</span><br><span class="hljs-attribute">overflow</span>:hidden;<br><span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-id">#banner</span> <span class="hljs-selector-tag">img</span>&#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">1920px</span>; <span class="hljs-comment">/*宽度为图片的实际宽度*/</span><br><span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/*高度充满父容器*/</span><br>                <br><span class="hljs-comment">/*使用绝对定位,让图片在父容器中绝对居中*/</span><br><span class="hljs-attribute">position</span>: absolute;<br><span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br><span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">960px</span>;<br>&#125;<br>&lt;/style&gt;<br></code></pre></div></td></tr></table></figure><h3 id="使用动画实现滚动功能"><a href="#使用动画实现滚动功能" class="headerlink" title="使用动画实现滚动功能"></a>使用动画实现滚动功能</h3><p>下面是使用动画实现滚动的示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/banner01.gif" srcset="/img/loading.gif" lazyload alt="动画滚动"></p><p>具体实现方法如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;banner&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;banner_in&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/banner1.png&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!--为了去掉图片之间的缝隙--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/banner2.png&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!--为了去掉图片之间的缝隙--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/banner3.png&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!--为了去掉图片之间的缝隙--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/banner1.png&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>注意：</strong>上面代码中，每个img标签后面都加了一个注释，原因是为了去掉图片之间的缝隙，把所有的img标签写在同一行也可以达到效果。</p><p>下面是CSS代码：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">&lt;style type=&quot;text/css&quot;&gt;<br>*&#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span>;<br>&#125;<br><span class="hljs-selector-id">#banner</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-id">#banner_in</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">7680px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">position</span>: relative;<br>    -webkit-<span class="hljs-attribute">animation</span>: banner <span class="hljs-number">8s</span> ease infinite;<br>&#125;<br><br><span class="hljs-keyword">@-webkit-keyframes</span> banner&#123;<br>    <span class="hljs-number">0%</span>&#123;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">0px</span>;<br>    &#125;<br>    <span class="hljs-number">10%</span>&#123;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">0px</span>;<br>    &#125;<br>    <span class="hljs-number">30%</span>&#123;<br>        <span class="hljs-attribute">left</span>: -<span class="hljs-number">1920px</span>;<br>    &#125;<br>    <span class="hljs-number">40%</span>&#123;<br>        <span class="hljs-attribute">left</span>: -<span class="hljs-number">1920px</span>;<br>    &#125;<br>    <span class="hljs-number">70%</span>&#123;<br>        <span class="hljs-attribute">left</span>: -<span class="hljs-number">3840px</span>;<br>    &#125;<br>    <span class="hljs-number">80%</span>&#123;<br>        <span class="hljs-attribute">left</span>: -<span class="hljs-number">3840px</span>;<br>    &#125;<br>    <span class="hljs-number">100%</span>&#123;<br>        <span class="hljs-attribute">left</span>: -<span class="hljs-number">5760px</span>;<br>    &#125;<br>&#125;<br>&lt;/style&gt;<br></code></pre></div></td></tr></table></figure><p>至此，一个使用动画功能做出来的banner滚动就实现了，如果要暂停滚动可以利用鼠标hover事件设置动画的状态属性，以达到暂停banner滚动的目的。</p><h2 id="利用CSS和JavaScript实现banner滚动和点击切换"><a href="#利用CSS和JavaScript实现banner滚动和点击切换" class="headerlink" title="利用CSS和JavaScript实现banner滚动和点击切换"></a>利用CSS和JavaScript实现banner滚动和点击切换</h2><p>​       上面利用CSS使banner滚动的方法虽然比较简单，但是如果想看其中一张banner的时候，只能等他慢慢滚动显示出来，不能直接切换，但是如果用CSS+JS的方法就可以直接跳转到想看的banner了。</p><p>先上HTML代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;banner&quot;</span>&gt;</span><br>　　<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;inside&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/banner1.png&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img1&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/banner2.png&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img2&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/banner3.png&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img3&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/banner4.png&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img4&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/banner1.png&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img5&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!--切换banner按钮--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bannerNum&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;changeBanner(1)&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;changeBanner(2)&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;changeBanner(3)&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;changeBanner(4)&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>再稍微调整一下样式：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">&lt;style type=&quot;text/css&quot;&gt;<br>  *&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span>;<br>  &#125;<br>  <span class="hljs-selector-id">#banner</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">white-space</span>: nowrap;<br>    <span class="hljs-attribute">position</span>: relative;<br>  &#125;<br>  <span class="hljs-selector-id">#banner</span> <span class="hljs-selector-id">#inside</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">9600px</span>;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">960px</span>;<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;<br>  &#125;<br>  <span class="hljs-selector-id">#banner</span> <span class="hljs-selector-tag">img</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">1920px</span>;<br>  &#125;<br>  <span class="hljs-selector-id">#bannerNum</span>&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span>;<br>    <span class="hljs-attribute">list-style</span>: none;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">160px</span>;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">50px</span>;<br>  &#125;<br>  <span class="hljs-selector-id">#bannerNum</span> <span class="hljs-selector-tag">li</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">background-color</span>: white;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span> <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">cursor</span>: pointer;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></div></td></tr></table></figure><h3 id="实现滚动和切换"><a href="#实现滚动和切换" class="headerlink" title="实现滚动和切换"></a>实现滚动和切换</h3><p>接下来用JS使图片滚动起来，并且可以自由切换当前显示的图片。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;script&gt;<br>　　<span class="hljs-keyword">var</span> n = <span class="hljs-number">1</span>;<br>　　<span class="hljs-keyword">var</span> inside;<br>　　<span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　inside = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;inside&quot;</span>);<br><br>　　<span class="hljs-keyword">var</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　　　inside.style.transition = <span class="hljs-string">&quot;all 1s ease&quot;</span>;<br>　　　　n++;<br>　　　　<span class="hljs-keyword">switch</span> (n)&#123;<br>　　　　<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>　　　　inside.style.transition = <span class="hljs-string">&quot;none&quot;</span>;<br>　　　　inside.style.marginLeft = (-<span class="hljs-number">960</span>)+<span class="hljs-string">&quot;px&quot;</span>;<br>　　　　<span class="hljs-keyword">break</span>;<br>　　　　<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>　　　　inside.style.marginLeft = (-<span class="hljs-number">960</span>-<span class="hljs-number">1920</span>)+<span class="hljs-string">&quot;px&quot;</span>;<br>　　　　<span class="hljs-keyword">break</span>;<br>　　　　<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>　　　　inside.style.marginLeft = (-<span class="hljs-number">960</span>-<span class="hljs-number">1920</span>*<span class="hljs-number">2</span>)+<span class="hljs-string">&quot;px&quot;</span>;<br>　　　　<span class="hljs-keyword">break</span>;<br>　　　　<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>　　　　inside.style.marginLeft = (-<span class="hljs-number">960</span>-<span class="hljs-number">1920</span>*<span class="hljs-number">3</span>)+<span class="hljs-string">&quot;px&quot;</span>;<br>　　　　<span class="hljs-keyword">break</span>;<br>　　　　<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>　　　　inside.style.marginLeft = (-<span class="hljs-number">960</span>-<span class="hljs-number">1920</span>*<span class="hljs-number">4</span>)+<span class="hljs-string">&quot;px&quot;</span>;<br>　　　　n = <span class="hljs-number">0</span>;<br>　　　　<span class="hljs-keyword">break</span>;<br>　　　　<span class="hljs-keyword">default</span>:<br>　　　　<span class="hljs-keyword">break</span>;<br>　　　　&#125;<br>　　　　&#125;,<span class="hljs-number">2000</span>);<br>　　&#125;<br><br>　　<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeBanner</span>(<span class="hljs-params">num</span>)</span>&#123;<br>　　　　inside.style.transition = <span class="hljs-string">&quot;none&quot;</span>;<br>　　　　<span class="hljs-keyword">switch</span> (num)&#123;<br>　　　　<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>　　　　inside.style.marginLeft = (-<span class="hljs-number">960</span>)+<span class="hljs-string">&quot;px&quot;</span>;<br>　　　　<span class="hljs-keyword">break</span>;<br>　　　　<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>　　　　inside.style.marginLeft = (-<span class="hljs-number">960</span>-<span class="hljs-number">1920</span>)+<span class="hljs-string">&quot;px&quot;</span>;<br>　　　　<span class="hljs-keyword">break</span>;<br>　　　　<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>　　　　inside.style.marginLeft = (-<span class="hljs-number">960</span>-<span class="hljs-number">1920</span>*<span class="hljs-number">2</span>)+<span class="hljs-string">&quot;px&quot;</span>;<br>　　　　<span class="hljs-keyword">break</span>;<br>　　　　<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>　　　　inside.style.marginLeft = (-<span class="hljs-number">960</span>-<span class="hljs-number">1920</span>*<span class="hljs-number">3</span>)+<span class="hljs-string">&quot;px&quot;</span>;<br>　　　　<span class="hljs-keyword">break</span>;<br>　　　　<span class="hljs-keyword">default</span>:<br>　　　　<span class="hljs-keyword">break</span>;<br>　　　　&#125;<br><br>　　   n = num-<span class="hljs-number">1</span>;<br>　　&#125;<br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure><p>下面是我用div代替图片做的一个简单demo：</p><p>在线查看：<a href="">滚动效果</a></p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/banner02.gif" srcset="/img/loading.gif" lazyload></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo的基本操作</title>
    <link href="/2020/01/hexo-operate/"/>
    <url>/2020/01/hexo-operate/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的Hexo博客搭建（三）—— 博客进阶设置、在其他电脑发布博客</title>
    <link href="/2020/01/blog-advance/"/>
    <url>/2020/01/blog-advance/</url>
    
    <content type="html"><![CDATA[<h2 id="添加其他样式"><a href="#添加其他样式" class="headerlink" title="添加其他样式"></a>添加其他样式</h2><p>主要添加自定义样式。首先编辑主题配置文件，然后在站点根目录的<code>source</code>文件夹内新建你配置的文件夹和文件：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">custom_js:</span>   <span class="hljs-comment"># 指定自定义 js 文件路径，路径是相对 source 目录，如 /js/custom.js 对应存放目录 source/js/custom.js，支持列表</span><br><span class="hljs-attr">custom_css:</span>  <span class="hljs-string">/css/custom.css</span> <span class="hljs-comment"># 指定自定义 css 文件路径，路径是相对 source 目录，如 /css/custom.css 同上，支持列表</span><br><span class="hljs-attr">custom_html:</span> <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-comment"># 自定义底部 HTML 内容（位于 footer 上方），也可用于外部引入 js css 这些操作，注意不要和 post.custom 配置冲突</span><br></code></pre></div></td></tr></table></figure><h3 id="修改鼠标样式"><a href="#修改鼠标样式" class="headerlink" title="修改鼠标样式"></a>修改鼠标样式</h3><p>在前面新建的CSS文件中添加如下代码：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/*鼠标样式 */</span><br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">cursor</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/img/huaji.cur&quot;</span>),auto <span class="hljs-meta">!important</span><br>  &#125;<br>  <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>      <span class="hljs-attribute">cursor</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/img/laji.png&quot;</span>),auto <span class="hljs-meta">!important</span><br>  &#125;<br></code></pre></div></td></tr></table></figure><p>上面代码中<code>url</code>的地址是在source目录下的文件，也可以写其他的图片地址。</p><h3 id="修改网页背景"><a href="#修改网页背景" class="headerlink" title="修改网页背景"></a>修改网页背景</h3><p>还是在前面新建的CSS文件中修改，添加如下代码：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;<br>    <span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">/images/bg.jpg</span>);<br>    <span class="hljs-attribute">background-size</span>:cover;<br>    <span class="hljs-attribute">background-repeat</span>:no-repeat;<br>    <span class="hljs-attribute">background-attachment</span>:fixed;<br>    <span class="hljs-attribute">background-position</span>:center;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>还可以配置动态背景：</p><h2 id="添加其他功能"><a href="#添加其他功能" class="headerlink" title="添加其他功能"></a>添加其他功能</h2><p>本篇主要添加一些主题中没有提供的功能。</p><h3 id="添加网页看板娘（Live2D）"><a href="#添加网页看板娘（Live2D）" class="headerlink" title="添加网页看板娘（Live2D）"></a>添加网页看板娘（Live2D）</h3><p>首先安装Live2D插件，在站点根目录下运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install --save hexo-helper-live2d<br></code></pre></div></td></tr></table></figure><p>然后选择自己喜欢的模型，复制名字。</p><p>Epsilon2.1</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>Gantzert_Felixander</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>haru</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>miku</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>ni-j</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>nico</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>nietzche</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>nipsilon</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>nito</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>shizuku</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>tsumiki</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>wanko</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>z16</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>hibiki</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>koharu</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>haruto</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>Unitychan</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>tororo</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>hijiki</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>将下面的代码添加到站点配置文件<code>_config.yml</code>中，修改&lt;模型名字&gt;（有教程说放在主题配置文件中，但是实际测试放在主题文件中并不好用，不管使用哪个模型网页中都不生效，都显示默认的<code>shizuku</code>这个模型，但是把代码放在站点配置文件中就好用了，不知道是什么原因）</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Live2D</span><br><span class="hljs-comment">## https://github.com/EYHN/hexo-helper-live2d</span><br><span class="hljs-attr">live2d:</span><br>  <span class="hljs-comment"># enable: true</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">scriptFrom:</span> <span class="hljs-string">local</span> <span class="hljs-comment"># 默认</span><br>  <span class="hljs-attr">pluginRootPath:</span> <span class="hljs-string">live2dw/</span> <span class="hljs-comment"># 插件在站点上的根目录(相对路径)</span><br>  <span class="hljs-attr">pluginJsPath:</span> <span class="hljs-string">lib/</span> <span class="hljs-comment"># 脚本文件相对与插件根目录路径</span><br>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span> <span class="hljs-comment"># 模型文件相对与插件根目录路径</span><br>  <span class="hljs-comment"># scriptFrom: jsdelivr # jsdelivr CDN</span><br>  <span class="hljs-comment"># scriptFrom: unpkg # unpkg CDN</span><br>  <span class="hljs-comment"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span><br>  <span class="hljs-attr">tagMode:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br>  <span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 调试, 是否在控制台输出日志</span><br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-&lt;模型名字&gt;</span> <span class="hljs-comment"># npm-module package name</span><br>    <span class="hljs-comment"># use: wanko # 博客根目录/live2d_models/ 下的目录名</span><br>    <span class="hljs-comment"># use: ./wives/wanko # 相对于博客根目录的路径</span><br>    <span class="hljs-comment"># use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url</span><br>    <span class="hljs-attr">scale:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">hHeadPos:</span> <span class="hljs-number">0.5</span><br>    <span class="hljs-attr">vHeadPos:</span> <span class="hljs-number">0.618</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">superSample:</span> <span class="hljs-number">2</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">250</span><br>    <span class="hljs-attr">height:</span> <span class="hljs-number">500</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">right</span><br>    <span class="hljs-attr">hOffset:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">vOffset:</span> <span class="hljs-number">-20</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">scale:</span> <span class="hljs-number">0.5</span><br>  <span class="hljs-attr">react:</span><br>    <span class="hljs-attr">opacity:</span> <span class="hljs-number">0.7</span><br>  <span class="hljs-attr">dialog:</span> <br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">hitokoto:</span> <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><p>安装你选择的模型，在命令行运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install --save live2d-widget-model-&lt;你选择的模型名字&gt;<br></code></pre></div></td></tr></table></figure><p>然后在命令行运行以下命令，在浏览器里访问<code>localhost:4000</code>查看效果</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></div></td></tr></table></figure><h3 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h3><p>当想要写一些不想让人随便看到的博客时，可以通过密码验证的方式阻挡别人的浏览，之前有一款文章加密的插件，但是好像效果不是很好，因为密码就被写在了网页源码里，只要打开网页源码就能看到。现在又找到另外一个（也可能是原来的升级了？主要不记得原来的插件名字了）加密插件，似乎并不会将密码泄露到网页中，可以尝试使用这款插件。</p><p><strong>安装方式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install --save hexo-blog-encrypt<br></code></pre></div></td></tr></table></figure><p>或</p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">yarn <span class="hljs-built_in">add</span> hexo-blog-<span class="hljs-built_in">encrypt</span> (需要Yarn)<br></code></pre></div></td></tr></table></figure><p>最简单的使用方式就是将 “password” 字段添加到文章的信息头上：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">---<br>title: Hello World<br>date: 2020-01-03 15:43:38<br>password: 123456<br>---<br></code></pre></div></td></tr></table></figure><p><strong>高级设置：</strong></p><p>两种设置方式：</p><ul><li>在文章信息头添加加密信息：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">World</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">作为日记加密</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2020-01-03 15:43:38</span><br><span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br><span class="hljs-attr">abstract:</span> <span class="hljs-string">有东西被加密了,</span> <span class="hljs-string">请输入密码查看.</span><br><span class="hljs-attr">message:</span> <span class="hljs-string">您好,</span> <span class="hljs-string">这里需要密码.</span><br><span class="hljs-attr">wrong_pass_message:</span> <span class="hljs-string">抱歉,</span> <span class="hljs-string">这个密码看着不太对,</span> <span class="hljs-string">请再试试.</span><br><span class="hljs-attr">wrong_hash_message:</span> <span class="hljs-string">抱歉,</span> <span class="hljs-string">这个文章不能被校验,</span> <span class="hljs-string">不过您还是能看看解密后的内容.</span><br><span class="hljs-meta">---</span><br></code></pre></div></td></tr></table></figure><ul><li>在站点文件<code>_config.yml</code>内配置加密信息：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Security</span><br><span class="hljs-attr">encrypt:</span> <span class="hljs-comment"># hexo-blog-encrypt</span><br>  <span class="hljs-attr">abstract:</span> <span class="hljs-string">有东西被加密了,</span> <span class="hljs-string">请输入密码查看.</span><br>  <span class="hljs-attr">message:</span> <span class="hljs-string">您好,</span> <span class="hljs-string">这里需要密码.</span><br>  <span class="hljs-attr">tags:</span><br>  <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">tagName</span>, <span class="hljs-attr">password:</span> <span class="hljs-string">密码A</span>&#125;<br>  <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">tagName</span>, <span class="hljs-attr">password:</span> <span class="hljs-string">密码B</span>&#125;<br>  <span class="hljs-attr">template:</span> <span class="hljs-string">&lt;div</span> <span class="hljs-string">id=&quot;hexo-blog-encrypt&quot;</span> <span class="hljs-string">data-wpm=&quot;&#123;&#123;hbeWrongPassMessage&#125;&#125;&quot;</span> <span class="hljs-string">data-whm=&quot;&#123;&#123;hbeWrongHashMessage&#125;&#125;&quot;&gt;&lt;div</span> <span class="hljs-string">class=&quot;hbe-input-container&quot;&gt;&lt;input</span> <span class="hljs-string">type=&quot;password&quot;</span> <span class="hljs-string">id=&quot;hbePass&quot;</span> <span class="hljs-string">placeholder=&quot;&#123;&#123;hbeMessage&#125;&#125;&quot;</span> <span class="hljs-string">/&gt;&lt;label&gt;&#123;&#123;hbeMessage&#125;&#125;&lt;/label&gt;&lt;div</span> <span class="hljs-string">class=&quot;bottom-line&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script</span> <span class="hljs-string">id=&quot;hbeData&quot;</span> <span class="hljs-string">type=&quot;hbeData&quot;</span> <span class="hljs-string">data-hmacdigest=&quot;&#123;&#123;hbeHmacDigest&#125;&#125;&quot;&gt;&#123;&#123;hbeEncryptedData&#125;&#125;&lt;/script&gt;&lt;/div&gt;</span><br>  <span class="hljs-attr">wrong_pass_message:</span> <span class="hljs-string">抱歉,</span> <span class="hljs-string">这个密码看着不太对,</span> <span class="hljs-string">请再试试.</span><br>  <span class="hljs-attr">wrong_hash_message:</span> <span class="hljs-string">抱歉,</span> <span class="hljs-string">这个文章不能被校验,</span> <span class="hljs-string">不过您还是能看看解密后的内容.</span><br></code></pre></div></td></tr></table></figure><p><strong>注意！！！</strong>在站点配置文件配置上述内容时，如果把tags下面的内容都注释掉的话编译生成的时候会报错，要改成这样才行：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">tags:</span> [] <span class="hljs-comment">#在后面加一对方括号，表示是个数组，不然报错 Cannot read property &#x27;forEach&#x27; of null</span><br>  <span class="hljs-comment"># - &#123;name: tagName, password: 密码A&#125;</span><br>  <span class="hljs-comment"># - &#123;name: tagName, password: 密码B&#125;</span><br></code></pre></div></td></tr></table></figure><p><em><strong>以后有类似的配置遇到问题也可以尝试这样解决。</strong></em></p><p><strong>加密优先级</strong>是 文章信息头 &gt; 按标签加密。</p><p><strong>配置优先级</strong>是 文章信息头 &gt; <code>_config.yml</code> (站点根目录下的) &gt; 默认配置。</p><p><strong>其他问题</strong></p><p>在部分博客中, 解密后部分元素可能无法正常显示或者表现, 这属于已知问题. 目前的解决办法是通过自行查阅自己的博客中的代码, 了解到在 onload 事件发生时调用了哪些函数, 并将这些函数挑选后写入到博客内容中. 如:</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Callback</span> <span class="hljs-string">Test</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-12-21 11:54:07</span><br><span class="hljs-attr">tags:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Encrypted</span><br><span class="hljs-meta">---</span><br><br><span class="hljs-attr">This is a blog to test Callback functions. You just need to add code at the last of your post like following:</span><br><br><span class="hljs-string">It</span> <span class="hljs-string">will</span> <span class="hljs-string">be</span> <span class="hljs-string">called</span> <span class="hljs-string">after</span> <span class="hljs-string">the</span> <span class="hljs-string">blog</span> <span class="hljs-string">decrypted.</span><br><br><span class="hljs-string">&lt;script&gt;</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">添加一个</span> <span class="hljs-string">script</span> <span class="hljs-string">tag</span> <span class="hljs-string">与代码在文章末尾.</span><br>    <span class="hljs-string">alert(&quot;Hello</span> <span class="hljs-string">World&quot;);</span><br><span class="hljs-string">&lt;/script&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>对 TOC 进行加密</strong></p><p>如果你有一篇文章使用了 TOC，你需要修改模板的部分代码。这里用 landscape 作为例子：</p><ul><li>你可以在 hexo/themes/landscape/layout/_partial/article.ejs 找到 article.ejs。</li><li>然后找到 &lt;% post.content %&gt; 这段代码，通常在30行左右。</li><li>使用如下的代码来替代它:</li></ul><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;% if(post.toc &#x3D;&#x3D; true)&#123; %&gt;<br>  &lt;div id&#x3D;&quot;toc-div&quot; class&#x3D;&quot;toc-article&quot; &lt;% if (post.encrypt &#x3D;&#x3D; true) &#123; %&gt;style&#x3D;&quot;display:none&quot; &lt;% &#125; %&gt;&gt;<br>    &lt;strong class&#x3D;&quot;toc-title&quot;&gt;Index&lt;&#x2F;strong&gt;<br>      &lt;% if (post.encrypt &#x3D;&#x3D; true) &#123; %&gt;<br>        &lt;%- toc(post.origin, &#123;list_number: true&#125;) %&gt;<br>      &lt;% &#125; else &#123; %&gt;<br>        &lt;%- toc(post.content, &#123;list_number: true&#125;) %&gt;<br>      &lt;% &#125; %&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;% &#125; %&gt;<br>&lt;%- post.content %&gt;<br></code></pre></div></td></tr></table></figure><h2 id="利用GitHub备份博客源文件并且在不同电脑操作"><a href="#利用GitHub备份博客源文件并且在不同电脑操作" class="headerlink" title="利用GitHub备份博客源文件并且在不同电脑操作"></a>利用GitHub备份博客源文件并且在不同电脑操作</h2><p>在你换电脑或者重装系统的时候万一不小心把博客的站点文件夹删了或者弄丢了那就什么都没了，所以为了防止发生这样的情况，就可以用GitHub来保存博客的源文件。</p><h3 id="用命令行操作"><a href="#用命令行操作" class="headerlink" title="用命令行操作"></a>用命令行操作</h3><p>具体操作是在你的GitHub中新建一个仓库或者在你的博客仓库内新建一个分支，个人推荐新建一个仓库，和博客的静态文件分开管理比较好，然后在本地找一个空文件夹，运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:你的git账户名/你的博客仓库名<br></code></pre></div></td></tr></table></figure><p>就是如下图所示这个链接：</p><p><img src="" srcset="/img/loading.gif" lazyload></p><p>复制粘帖到<code>git clone</code>后面即可。</p><p><strong>更新：</strong>我在过了不知道多久之后回来整理吃灰博客的时候碰到的两个问题</p><p>一是用于太久没用ssh，github自动把ssh删掉了，然后在我克隆仓库的时候就出现了<code>git@github.com:Permission denied (publickey). fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.</code>这个错误。这个时候首先使用<code>ls ~/.ssh/</code>这个命令检查你电脑上的之前创建的ssh文件是否还在，如果存在的话把之前创建的公钥再复制到github里就行，如果没有ssh就要重新创建ssh密钥然后再添加到github上。</p><p>二是如果你电脑上有设置了多个Git帐号的话，上面的代码就要修改一下了。</p><p>根据你ssh文件夹下的config文件，把<code>git@github.com:</code>这部分中<code>@</code>和<code>：</code>之间的<code>github.com</code>改成config文件中host对应的名称，否则拉取仓库的时候也会报上面的错。</p><p>把仓库克隆到本地，然后把你的博客源文件全部复制过来，除了<code>.deploy_git</code>，注意复制过来的文件里面应该有一个叫<code>.gitignore</code>的文件，用来忽略一些不要提交到Git的文件，如果没有可以自己新建一个，在里面加上下面的内容：</p><figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">.DS_Store</span><br>Thumbs<span class="hljs-number">.</span><span class="hljs-built_in">db</span><br><span class="hljs-built_in">db</span><span class="hljs-number">.</span>json<br>*.log<br>node_modules/<br><span class="hljs-meta">public</span>/<br><span class="hljs-meta">.deploy</span>*/<br></code></pre></div></td></tr></table></figure><p>如果还有其他自己不想提交的文件也可以加到这个文件中。</p><p>然后再在命令行中执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git add .<br>git commit –m <span class="hljs-string">&quot;commit message&quot;</span><br>git push <br></code></pre></div></td></tr></table></figure><p>可以在网页中查看是否上传成功。</p><p>当你换了电脑或者重装系统后想把博客下回来怎么操作？</p><p>首先前面的都一样，下载安装node，Git，然后设置git全局邮箱和用户名，设置SHH，安装hexo，然后在任意一个文件夹内，执行<code>git clone git@你的博客源文件仓库地址</code>，进入克隆下来的文件夹，运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install<br>npm install hexo-deployer-git --save<br></code></pre></div></td></tr></table></figure><p>然后就可以继续写博客了，写完之后运行<code>hexo g &amp;&amp; hexo d</code>，就可以部署到GitHub Pages上了。而且现在可以每次写完博客都把源文件备份一下了：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git add .<br>git commit –m <span class="hljs-string">&quot;commit message&quot;</span><br>git push <br></code></pre></div></td></tr></table></figure><h3 id="用GitHub-Desktop操作"><a href="#用GitHub-Desktop操作" class="headerlink" title="用GitHub Desktop操作"></a>用GitHub Desktop操作</h3><p>下载安装GitHub Desktop然后登陆GitHub，把对应的作为保存博客源文件的仓库克隆到本地，然后把除了<code>.deploy_git</code>以外的博客源文件复制进来，注意有没有<code>.gitignore</code>这个文件，没有按上面方法加上，然后再写上备注信息，，提交推送到Git上就行了。</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://www.simon96.online/2018/10/12/hexo-tutorial/">【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析</a></p><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">hexo史上最全搭建教程</a></p><p><a href="https://uchuhimo.me/2017/04/11/genesis/">如何使用 Hexo 和 GitHub Pages 搭建这个博客</a></p><p><a href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的Hexo博客搭建（二）—— 网站设置和主题优化</title>
    <link href="/2020/01/blog-config/"/>
    <url>/2020/01/blog-config/</url>
    
    <content type="html"><![CDATA[<p>本篇文章主要来对网站做进一步的设置和美化，这里的美化主要针对我用的主题-<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a>，对于其他主题不一定完全适用。</p><h2 id="站点设置"><a href="#站点设置" class="headerlink" title="站点设置"></a>站点设置</h2><h3 id="设置网站信息"><a href="#设置网站信息" class="headerlink" title="设置网站信息"></a>设置网站信息</h3><p>在<strong>站点</strong>配置文件<code>_config.yml</code>中修改：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">你的博客名称</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">副标题（可不设置）</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">描述，通常由于搜索引擎搜索，SEO优化等（如果没有搜索引擎爬取收录的需要可不设置）</span><br><span class="hljs-attr">keywords:</span> <span class="hljs-string">关键字，通常由于搜索引擎搜索，SEO优化等（可不设置）</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">作者</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN（设置语言）</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">时区（可不设置）</span><br></code></pre></div></td></tr></table></figure><h3 id="修改永久链接的路径"><a href="#修改永久链接的路径" class="headerlink" title="修改永久链接的路径"></a>修改永久链接的路径</h3><p>在站点配置文件<code>_config.yml</code>中修改：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:title/</span><br></code></pre></div></td></tr></table></figure><h3 id="跳过渲染某些文件"><a href="#跳过渲染某些文件" class="headerlink" title="跳过渲染某些文件"></a>跳过渲染某些文件</h3><p>在站点配置文件<code>_config.yml</code>中修改，为了显示某个自己做的网页，或者为了显示readme说明文件等等：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Directory</span><br><span class="hljs-attr">skip_render:</span> <br> <span class="hljs-bullet">-</span> <span class="hljs-string">README.md</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">test/*</span><br> <span class="hljs-comment"># 跳过文件夹下所有文件</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;文件夹名/*&quot;</span>  <br> <span class="hljs-comment"># 跳过子文件夹</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;文件夹名/子文件夹名/*&quot;</span><br> <span class="hljs-comment"># 跳过文件夹下所有子文件夹和文件</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;文件夹名/**&quot;</span>   <br></code></pre></div></td></tr></table></figure><h2 id="主题美化设置"><a href="#主题美化设置" class="headerlink" title="主题美化设置"></a>主题美化设置</h2><p>主题配置我使用了覆盖配置，将<strong>主题配置文件</strong>放置在 fluid 目录之外，避免在更新主题时丢失自定义的配置。</p><p>使用该功能必须保证 Hexo 版本不低于 3.0，因为该功能利用了 <a href="https://hexo.io/zh-cn/docs/data-files.html">Hexo 数据文件</a> 功能。</p><p><strong>使用方式：</strong></p><ol><li>进入<strong>博客根目录</strong>（不是主题目录）的 source 目录下，创建 <code>_data</code> 目录（和 <code>_post</code> 目录同级）；</li><li>在 <code>_data</code> 目录下创建 <code>fluid_config.yml</code> 文件，将 <code>/theme/fluid/_config.yml</code> 中全部配置（或部分配置）复制到 <code>fluid_config.yml</code> 中；</li><li>以后配置都在 <code>fluid_config.yml</code> 中修改，配置会在 <code>hexo g</code> 时自动覆盖。</li></ol><p><strong>注意：</strong></p><ul><li><p>存在于 <code>fluid_config.yml</code> 的配置都是高优先级，修改原 <code>_config.yml</code> 是无效的。</p></li><li><p>如果想将某些配置覆盖为空，注意不要把主键删掉，不然是无法覆盖的，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">icons:</span>  <span class="hljs-comment"># 不要把 icon 注释掉，否则无法覆盖配置</span><br>    <span class="hljs-comment"># - &#123; class: &#x27;iconfont icon-github-fill&#x27;, link: &#x27;https://github.com&#x27; &#125;</span><br>    <span class="hljs-comment"># - &#123; class: &#x27;iconfont icon-wechat-fill&#x27;, qrcode: &#x27;/img/favicon.png&#x27; &#125;</span><br></code></pre></div></td></tr></table></figure></li></ul><h3 id="修改网页标签icon"><a href="#修改网页标签icon" class="headerlink" title="修改网页标签icon"></a>修改网页标签icon</h3><p>打开主题配置文件<code>themes/fluid/_config.yml</code>，找到下面的代码修改：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">favicon:</span> <span class="hljs-string">/img/favicon.png</span> <span class="hljs-comment"># 网站标签页的 icon</span><br></code></pre></div></td></tr></table></figure><p>上面的路径位于source文件夹下，而且必须位于source下，文件夹名称可以修改为别的，同时source文件夹在主题目录和站点目录各有一个，但是主题的source目录最终会合并到站点目录下，而主题目录在版本更新的时候可能会造成内容被覆盖或丢失，<strong>所以推荐放在博客站点的source文件夹下</strong>，文章后续提到的资源路径也均是放在站点source文件夹内。</p><h3 id="设置标题的打字机效果"><a href="#设置标题的打字机效果" class="headerlink" title="设置标题的打字机效果"></a>设置标题的打字机效果</h3><p>还是在主题配置文件<code>themes/fluid/_config.yml</code>里面修改：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">typing:</span> <span class="hljs-comment"># 为 subtitle 添加打字机效果</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">typeSpeed:</span> <span class="hljs-number">70</span>  <span class="hljs-comment"># 打印速度，数字越大越慢</span><br>    <span class="hljs-attr">cursorChar:</span> <span class="hljs-string">&quot;_&quot;</span> <span class="hljs-comment"># 游标字符</span><br>    <span class="hljs-attr">loop:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否循环播放效果</span><br></code></pre></div></td></tr></table></figure><h3 id="添加鼠标点击特效"><a href="#添加鼠标点击特效" class="headerlink" title="添加鼠标点击特效"></a>添加鼠标点击特效</h3><p>修改主题配置文件<code>themes/fluid/_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">mouse_click:</span>  <span class="hljs-comment"># 鼠标点击动效</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">style:</span> <span class="hljs-string">values</span> <span class="hljs-comment"># 目前设置两个值：values（价值观词汇） | love（爱心）</span><br></code></pre></div></td></tr></table></figure><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>修改主题配置文件<code>themes/fluid/_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">lazyload:</span> <span class="hljs-comment"># 对页面中的图片进行懒加载处理，可见范围外的图片不会加载</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">onlypost:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 仅在文章页使用懒加载，开启后如果自定义页面需要使用，可以在 Front-matter 里指定 `lazyload: true`</span><br></code></pre></div></td></tr></table></figure><p>更多可修改信息在配置文件中查看。</p><h3 id="设置音乐播放器"><a href="#设置音乐播放器" class="headerlink" title="设置音乐播放器"></a>设置音乐播放器</h3><p>编辑主题配置文件<code>themes/fluid/_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">aplayer:</span>  <span class="hljs-comment"># 音乐播放器，注意不能与 hexo-tag-aplayer 插件共用</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">autoplay:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 音频自动播放</span><br>  <span class="hljs-attr">loop:</span> <span class="hljs-string">&#x27;all&#x27;</span>  <span class="hljs-comment"># 音频循环播放, 可选值: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;none&#x27;</span><br>  <span class="hljs-attr">order:</span> <span class="hljs-string">&#x27;random&#x27;</span>  <span class="hljs-comment"># 播放顺序，可选值: &#x27;list&#x27;, &#x27;random&#x27;</span><br>  <span class="hljs-attr">theme:</span> <span class="hljs-string">&#x27;#b7daff&#x27;</span>  <span class="hljs-comment"># 主题色</span><br>  <span class="hljs-attr">songs:</span>  <span class="hljs-comment"># 歌曲列表，必须传入下列各参数，其中 url 与 cover 在本地需存于 source 目录，更多参数见文档：https://aplayer.js.org/#/zh-Hans/?id=%E5%8F%82%E6%95%B0</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-attr">artist:</span> <span class="hljs-string">&#x27;artist&#x27;</span>, <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;/songs/test.mp3&#x27;</span>, <span class="hljs-attr">cover:</span> <span class="hljs-string">&#x27;/img/cover.jpg&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-attr">artist:</span> <span class="hljs-string">&#x27;artist&#x27;</span>, <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;https://...url.mp3&#x27;</span>, <span class="hljs-attr">cover:</span> <span class="hljs-string">&#x27;https://...cover.jpg&#x27;</span> &#125;<br></code></pre></div></td></tr></table></figure><h3 id="设置右上角导航菜单"><a href="#设置右上角导航菜单" class="headerlink" title="设置右上角导航菜单"></a>设置右上角导航菜单</h3><p>编辑主题配置文件<code>themes/fluid/_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">menu:</span>  <span class="hljs-comment"># 可自行增减，key 用来关联 languages/*.yml，如不存在关联则显示 key 本身的值；icon 是 css class，可以省略；增加 name 可以强制显示指定名称</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;home&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-home-fill&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;archive&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/archives/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-archive-fill&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;category&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/categories/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-category-fill&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;tag&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/tags/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-tags-fill&#x27;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;about&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/about/&#x27;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-user-fill&#x27;</span> &#125;<br>    <span class="hljs-comment">#- &#123; key: &#x27;links&#x27;, link: &#x27;/links/&#x27;, icon: &#x27;iconfont icon-link-fill&#x27; &#125;  # 友链页，把前面#去掉即可展示</span><br></code></pre></div></td></tr></table></figure><p>另外二级菜单写法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">menu:</span><br>  <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;文档&#x27;</span>,<br>      <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;iconfont icon-books&#x27;</span>,<br>      <span class="hljs-attr">submenu:</span> [<br>        &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;配置指南&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/docs/guide/&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;操作示例&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/docs/example/&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;图标用法&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;https://hexo.fluid-dev.com/docs/icon/&#x27;</span> &#125;<br>      ]<br>  &#125;<br></code></pre></div></td></tr></table></figure><h3 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h3><p>编辑主题配置文件<code>themes/fluid/_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">search:</span> <span class="hljs-comment"># 搜索栏，基于 hexo-generator-search 插件，若已安装其他搜索插件请关闭此功能，以避免生成多余的索引文件。</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">/local-search.xml</span> <span class="hljs-comment"># 文件引用地址，默认是下方生成位置，也可以将生成后的 local-search.xml 上传到其它位置引用，如：https://www.example.com/local-search.xml</span><br>  <span class="hljs-attr">generate_path:</span> <span class="hljs-string">/local-search.xml</span> <span class="hljs-comment"># 文件生成位置，必须为相对位置</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">post</span><br>  <span class="hljs-attr">content:</span> <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><p>更多配置可以查看主题配置文件以及<a href="https://hexo.fluid-dev.com/docs/">官方配置指南</a>。</p><h3 id="自定义网页背景"><a href="#自定义网页背景" class="headerlink" title="自定义网页背景"></a>自定义网页背景</h3><p>首先在站点根目录的<code>source\_data</code>文件夹内新建一个名为<code>styles.styl</code>的文件，然后编辑主题配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">custom_file_path:</span><br>  <span class="hljs-attr">style:</span> <span class="hljs-string">source/_data/styles.styl</span><br></code></pre></div></td></tr></table></figure><p><strong>我们所有自定义的样式都会在<code>styles.styl</code>这个文件里添加</strong>。</p><p>编辑<code>styles.styl</code>，添加如下代码，把URL里面的地址改为你的背景图片的链接即可：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;<br>    <span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">/images/bg.jpg</span>);<br>    <span class="hljs-attribute">background-size</span>:cover;<br>    <span class="hljs-attribute">background-repeat</span>:no-repeat;<br>    <span class="hljs-attribute">background-attachment</span>:fixed;<br>    <span class="hljs-attribute">background-position</span>:center;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="自定义鼠标样式"><a href="#自定义鼠标样式" class="headerlink" title="自定义鼠标样式"></a>自定义鼠标样式</h3><p>还是在<code>styles.styl</code>里编辑，添加下面的代码：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">// 鼠标样式<br>  * &#123;<br>      <span class="hljs-attribute">cursor</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;鼠标图标地址&quot;</span>),auto<span class="hljs-meta">!important</span><br>  &#125;<br>  <span class="hljs-selector-pseudo">:active</span> &#123;<br>      <span class="hljs-attribute">cursor</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;鼠标图标地址&quot;</span>),auto<span class="hljs-meta">!important</span><br>  &#125;<br></code></pre></div></td></tr></table></figure><h3 id="点击出现爱心效果"><a href="#点击出现爱心效果" class="headerlink" title="点击出现爱心效果"></a>点击出现爱心效果</h3><p>在主题文件夹内的<code>/source/js/src</code>下新建文件<code>click-effect.js</code>，接着把下面的内容复制粘贴到<code>click-effect.js</code>文件中。<br>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e,t,a</span>)</span>&#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>)</span>&#123;c(<span class="hljs-string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>),o(),r()&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">r</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> e=<span class="hljs-number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="hljs-number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="hljs-number">1</span>)):(d[e].y--,d[e].scale+=<span class="hljs-number">.004</span>,d[e].alpha-=<span class="hljs-number">.013</span>,d[e].el.style.cssText=<span class="hljs-string">&quot;left:&quot;</span>+d[e].x+<span class="hljs-string">&quot;px;top:&quot;</span>+d[e].y+<span class="hljs-string">&quot;px;opacity:&quot;</span>+d[e].alpha+<span class="hljs-string">&quot;;transform:scale(&quot;</span>+d[e].scale+<span class="hljs-string">&quot;,&quot;</span>+d[e].scale+<span class="hljs-string">&quot;) rotate(45deg);background:&quot;</span>+d[e].color+<span class="hljs-string">&quot;;z-index:99999&quot;</span>);requestAnimationFrame(r)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">o</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">var</span> t=<span class="hljs-string">&quot;function&quot;</span>==<span class="hljs-keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">i</span>(<span class="hljs-params">e</span>)</span>&#123;<span class="hljs-keyword">var</span> a=t.createElement(<span class="hljs-string">&quot;div&quot;</span>);a.className=<span class="hljs-string">&quot;heart&quot;</span>,d.push(&#123;<span class="hljs-attr">el</span>:a,<span class="hljs-attr">x</span>:e.clientX-<span class="hljs-number">5</span>,<span class="hljs-attr">y</span>:e.clientY-<span class="hljs-number">5</span>,<span class="hljs-attr">scale</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">alpha</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params">e</span>)</span>&#123;<span class="hljs-keyword">var</span> a=t.createElement(<span class="hljs-string">&quot;style&quot;</span>);a.type=<span class="hljs-string">&quot;text/css&quot;</span>;<span class="hljs-keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="hljs-keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>].appendChild(a)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span><span class="hljs-string">&quot;rgb(&quot;</span>+~~(<span class="hljs-number">255</span>*<span class="hljs-built_in">Math</span>.random())+<span class="hljs-string">&quot;,&quot;</span>+~~(<span class="hljs-number">255</span>*<span class="hljs-built_in">Math</span>.random())+<span class="hljs-string">&quot;,&quot;</span>+~~(<span class="hljs-number">255</span>*<span class="hljs-built_in">Math</span>.random())+<span class="hljs-string">&quot;)&quot;</span>&#125;<span class="hljs-keyword">var</span> d=[];e.requestAnimationFrame=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;<span class="hljs-built_in">setTimeout</span>(e,<span class="hljs-number">1e3</span>/<span class="hljs-number">60</span>)&#125;&#125;(),n()&#125;(<span class="hljs-built_in">window</span>,<span class="hljs-built_in">document</span>);<br></code></pre></div></td></tr></table></figure><p>在主题文件夹的<code>\layout\_layout.swig</code>文件末尾添加：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 页面点击出现小桃心 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/src/clicklove.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://hexo.fluid-dev.com/docs/">fluid官方配置指南</a></p><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">hexo史上最全搭建教程</a></p><p><a href="https://uchuhimo.me/2017/04/11/genesis/">如何使用 Hexo 和 GitHub Pages 搭建这个博客</a></p><p><a href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的Hexo博客搭建（一）—— 搭建博客并部署到github</title>
    <link href="/2020/01/blog-create/"/>
    <url>/2020/01/blog-create/</url>
    
    <content type="html"><![CDATA[<p>事情的起因是这样的，在上网查东西的时候经常看见一些文章在个人博客网站发布，于是决定自己也捣鼓个博客装装逼，然后就在网上搜了一圈，发现现在市面上的博客平台还是有不少的，比方说博客园、简书、CSDN啥的，这些平台功能完善，注册给账号就能开始写文章，也不用去进行什么复杂的配置，简单点说就是你只管写文章就行，剩下的平台帮你处理。而且这些平台基本上都有社区论坛之类的，用户交流也很方便。<span id="more"></span></p><p>这么一看，好像在这几个平台直接注册账号开始写文章就挺八错了，但是呢，前面提到的这几个平台，博客园我有用过，CSDN注册了账号就没有以后了，简书虽然没用过，但是经常会看上面的文章，然后就发现这些平台都或多或少有一些限制，比方说想自己放点奇奇怪怪的东西上去就不太行了，而且除了博客园以外，其他的平台不能自定义网站的外观，最多可以换换主题。所以思来想去还是自己搭一个博客网站吧，但是又一想自己搭网站不仅要买服务器买域名还有备案，而且还要自己设计制作网站，网站上线以后还要定期进行维护，像我这么懒得人说不定过几天就扔一边了，这样一想不行太亏，只能再考虑考虑别的方式。然后机智如我又想到了一个办法，就是把网站放到GitHub page上面，套上Hexo这个博客框架，前期设置好了后期基本上不太需要维护，所以用这个方法很容易就能做出一个好看又装逼的博客网站了，啰嗦了这么多下面就来说说具体怎么操作吧。</p><h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a><strong>Hexo简介</strong></h2><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。官网对Hexo的介绍是快速、简洁且高效的博客框架。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><strong>安装Node.js</strong></p><p>Node.js 为大多数平台提供了官方的安装程序。可以去官网<a href="https://nodejs.org/zh-cn/download/">下载 | Node.js</a>下载</p><p>安装完成后打开命令行查看是否安装成功：</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br>npm -v<br></code></pre></div></td></tr></table></figure><p><strong>安装Git</strong></p><p>Git是目前世界上最先进的分布式版本控制系统，我们用它来管理Hexo博客文章，上传到GitHub。去<a href="https://git-scm.com/downloads">官网下载</a>对应系统的Git安装程序或者通过命令行的方式安装。</p><p><strong>安装Hexo</strong></p><p>在Node.js和Git都安装完成之后，安装Hexo，用命令行运行以下命令 <code>npm install -g hexo-cli</code>，之后可以用<code>hexo -v</code>查看版本来检查是否安装成功。</p><h2 id="初始化Hexo并设置主题"><a href="#初始化Hexo并设置主题" class="headerlink" title="初始化Hexo并设置主题"></a>初始化Hexo并设置主题</h2><h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p> Hexo 安装完成后，用命令行依次执行以下命令，Hexo 将会在指定文件夹中新建所需要的文件，其中&lt;folder&gt;就是你想要作为博客初始化的文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo init &lt;folder&gt;<br></code></pre></div></td></tr></table></figure><p>或者通过<strong>git bash</strong>操作，在你想新建博客的<strong>空文件夹</strong>中右键，选择<code>git bash here</code>，然后在打开的命令窗口直接输入<code>hexo init</code>就能初始化。</p><p>其中，<code>hexo init &lt;folder&gt;</code> 的&lt;folder&gt;是可选项，代表你想要初始化的文件夹，如果不写则默认在你当前打开的文件夹内初始化，比如你在<code>blog</code>文件夹内用<code>Git bash here</code> 打开命令行，再运行<code>hexo init</code> 这个命令，就会直接在<code>blog</code>这个文件夹内初始化，如果加上参数<code>hexo init hexo</code> 则会在<code>blog</code>文件夹内新建一个名为<code>hexo</code>的文件夹，然后在<code>hexo</code>这个文件夹内初始化。另外不管在哪个位置初始化，都要求你初始化的文件夹是空文件夹，否则初始化失败，命令行会打印错误提示文件夹不为空。</p><p><strong>还要注意的一点是：</strong>如果使用<strong>cmd命令行</strong>操作，会直接在<strong>我的文档（如Administrator）</strong>下新建文件夹进行初始化，如果不想新建在我的文档内，需要先用命令行切换到你想新建的位置下然后再初始化，如：</p><figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">d:</span><br>cd hexo-blog<br>hexo init <br></code></pre></div></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight sqf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sqf">.<br>├── .gitignore<br>├── <span class="hljs-variable">_config</span>.yml<br>├── package.json<br>├── package-<span class="hljs-built_in">lock</span>.json<br>├── node_modules<br>├── scaffolds<br>├── source<br>|   ├── <span class="hljs-variable">_drafts</span><br>|   └── <span class="hljs-variable">_posts</span><br>└── themes<br></code></pre></div></td></tr></table></figure><p>这时你可以在这个文件夹下使用命令<code>hexo server</code>来运行博客，在浏览器中访问<code>http://localhost:4000/</code>查看效果。</p><p>默认显示页面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>更多关于hexo的命令和设置可以去<a href="https://hexo.io/zh-cn/docs/">官网</a>查看。</p><h3 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h3><p>Hexo默认的主题是landscape，更多主题可以去<a href="https://hexo.io/themes/">官网</a>查看挑选。</p><p>主题的安装方式通常有两种：</p><p>一种是去主题的GitHub项目上下载到本地，然后将主题文件夹复制到站点目录的<code>themes</code>文件夹下。<br>另一种方式是用命令行安装：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> &lt;your-hexo-folder&gt;<br>git <span class="hljs-built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next<br></code></pre></div></td></tr></table></figure><p>虽然两种安装方式不同，但主题的配置方式是一样的，都是在博客的<strong>站点目录</strong>下的配置文件<code>_config.yml</code>中修改：</p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">&lt;主题文件夹的名称&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>重点：</strong>这里需要注意的是，站点配置文件和主题配置文件是两个不同的配置文件。假设你的博客站点文件夹名字是<code>blog</code>，那么你的站点配置文件路径就是<code>blog\_config.yml</code>，而主题配置文件的路径则是<code>blog\themes\主题文件夹名\_config.yml</code>，修改配置时要注意区分。</p><h2 id="部署博客到GithubPages"><a href="#部署博客到GithubPages" class="headerlink" title="部署博客到GithubPages"></a>部署博客到GithubPages</h2><h3 id="创建GitHub仓库并添加SHH-key"><a href="#创建GitHub仓库并添加SHH-key" class="headerlink" title="创建GitHub仓库并添加SHH key"></a>创建GitHub仓库并添加SHH key</h3><p><strong>创建仓库</strong></p><p>创建仓库之前，你要有一个GitHub账号，如果没有先去注册一个，之后在你的&lt;Github账号名称&gt;.github.io页面右上角头像点开下拉菜单，找到<code>Your repository</code>点开，然后点<code>new</code>按钮创建一个名为<code>&lt;你的Github账号名称&gt;.github.io</code>的仓库，并且设置为公开（public），再进行下一步。</p><p><strong>添加SSH key</strong></p><p>创建SSH key是为了将博客推送到GitHub上 ，在命令行运行以下命令，创建过程中需要根据提示按三下回车：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;你的邮箱地址&quot;</span><br></code></pre></div></td></tr></table></figure><p>创建完成后在电脑上找到生成的秘钥，比如<code>C:\Users\Administrator\.ssh\id_rsa.pub</code>，打开这个文件，注意是带<code>pub</code>后缀名的这个文件，将里面内容复制出来，然后打开GitHub，点击你的头像，在setting中找到<code>SSH and GPG keys </code>这个选项，然后点击<code>New SSH key</code>把你刚刚复制的内容放进去，可以给这个SSH Key起一个名字方便知道是做什么用途的。（操作中更具体的内容可以在另一篇文章中查看。）</p><p>测试是否添加成功。在命令行中依次输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ssh -T git@github.com<br>yes<br></code></pre></div></td></tr></table></figure><p>当看到返回<code>You’ve successfully authenticated</code>即为成功。</p><h3 id="将本地博客推送到GitHub仓库"><a href="#将本地博客推送到GitHub仓库" class="headerlink" title="将本地博客推送到GitHub仓库"></a>将本地博客推送到GitHub仓库</h3><p>安装hexo-deployer-git插件。在命令行运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install -g hexo-deployer-git --save<br></code></pre></div></td></tr></table></figure><p>然后打开<strong>站点配置文件</strong><code>_config.yml</code>，把文件的最后修改为如下内容：</p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:&lt;你的Github用户名&gt;/&lt;你的Github用户名&gt;.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></div></td></tr></table></figure><p>接下来就可以把博客推送到GitHub Pages了，在命令行（位置已经跳转到博客目录下）输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></div></td></tr></table></figure><p>其中<code> hexo clean</code>命令是清除缓存文件和已生成的静态文件，也可以不加。<br><code>hexo generate</code> 生成静态文章，可以用缩写 hexo g。<br><code>hexo deploy </code>是部署网站，就是把博客推送到GitHub上，可以用缩写hexo d。</p><p>注意deploy时可能要你输入username和password。</p><p>返回<code>INFO Deploy done: git</code>即推送成功了，稍等几分钟就可以在浏览器访问<code>http://你的GitHub用户名.github.io</code></p><p>到这里，你的Hexo博客就已经在GitHub Pages部署完成，可以开始发博客了。</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>这部分先跳过，目前并没有绑定域名的打算，所以没有做深入了解，如果想绑定，可以看看下面的参考链接。</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://www.simon96.online/2018/10/12/hexo-tutorial/">【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析</a></p><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">hexo史上最全搭建教程</a></p><p><a href="https://uchuhimo.me/2017/04/11/genesis/">如何使用 Hexo 和 GitHub Pages 搭建这个博客</a></p><p><a href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/12/hello-world/"/>
    <url>/2019/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo server<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo generate<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客搭建</title>
    <link href="/2019/12/hexo/"/>
    <url>/2019/12/hexo/</url>
    
    <content type="html"><![CDATA[<p><strong>此篇废弃，移步至另一篇<a href="https://dogelasvegas.github.io/2020/01/blog-create/">从零开始的Hexo博客搭建（一）</a></strong></p><p>现在市面上的博客平台有很多，比方说博客园、简书、CSDN等等，功能完善，专注写作即可，而且还有社区，用户交流也很方便，但是这些平台都或多或少有一定限制，还有各种广告。由此，我们可以自己搭建一个博客网站，但是自己搭建又要买服务器还有域名，还要自己制作网站，而且还要定期进行维护，不光花钱还费时间，不过还有一个办法，就是把博客放到GitHub page上面，这样只要专注写作就行了，不需要定期维护，然后再套上Hexo这个博客框架，可以直接生成一个漂亮的网站，这样搭建一个博客就容易多了。</p><p><strong>Hexo简介</strong><br>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。官网对Hexo的介绍是快速、简洁且高效的博客框架。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p><strong>安装Node.js</strong></p><p>Node.js 为大多数平台提供了官方的安装程序。可以去官网<a href="https://nodejs.org/zh-cn/download/">下载 | Node.js</a>下载</p><p>安装完成后打开命令行查看是否安装成功：</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br>npm -v<br></code></pre></div></td></tr></table></figure><p><strong>安装Git</strong></p><p>Git是目前世界上最先进的分布式版本控制系统，我们用它来管理Hexo博客文章，上传到GitHub。去<a href="https://git-scm.com/downloads">官网下载</a>对应系统的Git安装程序或查看命令行进行安装。</p><p><strong>安装Hexo</strong></p><p>在Node.js和Git都安装完成之后，安装Hexo，用命令行运行以下命令 <code>npm install -g hexo-cli</code>，之后可以用<code>hexo -v</code>查看版本来检查是否安装成功。</p><h3 id="初始化Hexo并设置主题"><a href="#初始化Hexo并设置主题" class="headerlink" title="初始化Hexo并设置主题"></a>初始化Hexo并设置主题</h3><h4 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h4><p>安装 Hexo 完成后，依次执行以下命令，Hexo 将会在指定文件夹中新建所需要的文件，其中&lt;folder&gt;就是你想要作为博客初始化的文件夹。</p><p><strong>注意</strong>：如果使用<strong>cmd命令行</strong>操作，会直接在<strong>我的文档（如Administrator）</strong>下新建这个文件夹进行初始化，如果不想新建在我的文档内，需要先用命令行切换到你想新建的位置下如<code>cd d:</code>，<code>cd hexo-blog</code>，然后再进行下面的初始化操作。如果是使用<strong>git bash</strong>进行的命令行操作，则可以直接在想要作为博客初始化的文件夹内右键，在弹出的菜单中点击<code>git bash here</code>进行操作即可。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo init &lt;folder&gt;<br><span class="hljs-built_in">cd</span> &lt;folder&gt;<br>npm install<br></code></pre></div></td></tr></table></figure><p><code>hexo init &lt;folder&gt;</code> 中的&lt;folder&gt;是可选项，代表你想要初始化的文件夹，如果不写则默认在你当前打开的文件夹内初始化，比如你在<code>blog</code>文件夹内用<code>Git bash here</code> 打开命令行，再运行<code>hexo init</code> 这个命令，就会直接在<code>blog</code>这个文件夹内初始化，如果加上参数<code>hexo init hexo</code> 则会在<code>blog</code>文件夹内新建一个名为<code>hexo</code>的文件夹，然后在<code>hexo</code>这个文件夹内初始化。</p><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight sqf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sqf">.<br>├── <span class="hljs-variable">_config</span>.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── <span class="hljs-variable">_drafts</span><br>|   └── <span class="hljs-variable">_posts</span><br>└── themes<br></code></pre></div></td></tr></table></figure><p>这时你可以在这个文件夹下用命令行<code>hexo server</code>来运行博客，在浏览器中访问<code>http://localhost:4000/</code>来查看效果。</p><p>默认显示页面如下：</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>更多关于hexo的命令和设置可以去<a href="https://hexo.io/zh-cn/docs/">官网</a>查看。</p><h4 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h4><p>Hexo默认的主题是landscape，更多主题可以去<a href="https://hexo.io/themes/">官网</a>挑选。</p><p>主题的安装方式有两种：</p><p>一种是去主题的GitHub项目上下载到本地，然后将主题文件夹复制到站点目录的<code>themes</code>文件夹下。<br>另一种方式是用命令行安装：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> &lt;your-hexo-folder&gt;<br>git <span class="hljs-built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next<br></code></pre></div></td></tr></table></figure><p>虽然两种安装方式不同，但主题的配置方式是一样的，都是在博客的站点目录下的配置文件<code>_config.yml</code>中修改：</p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">&lt;主题文件夹的名称&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>重点：</strong>这里需要注意，站点配置文件和主题配置文件是两个不同的配置文件。假设你的博客站点文件夹名字是<code>blog</code>，那么你的站点配置文件路径就是<code>blog\_config.yml</code>，而主题配置文件的路径则是<code>blog\themes\主题文件夹名\_config.yml</code>，修改配置时注意区分。</p><h3 id="部署博客到GithubPages"><a href="#部署博客到GithubPages" class="headerlink" title="部署博客到GithubPages"></a>部署博客到GithubPages</h3><h4 id="创建GitHub仓库并添加SHH-key"><a href="#创建GitHub仓库并添加SHH-key" class="headerlink" title="创建GitHub仓库并添加SHH key"></a>创建GitHub仓库并添加SHH key</h4><p><strong>创建仓库</strong></p><p>创建仓库之前，你要有一个GitHub账号，如果没有先去注册一个，之后在页面里找到<code>New repository</code>按钮，创建一个和你GitHub用户名一样的仓库，然后进行下一步。</p><p><strong>添加SSH key</strong></p><p>首先创建一个SSH key ，在命令行运行以下命令，创建过程中需要根据提示按三下回车：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;你的邮箱地址&quot;</span><br></code></pre></div></td></tr></table></figure><p>创建完成后在电脑上找到生成的秘钥，比如<code>C:\Users\Administrator\.ssh\id_rsa.pub</code>，打开这个文件，将里面内容复制出来，然后打开GitHub，点击你的头像，在setting中找到<code>SSH and GPG keys </code>这个选项，然后点击<code>New SSH key</code>把你刚刚复制的内容放进去。</p><p>测试是否添加成功。在命令行中依次输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ssh -T git@github.com<br>yes<br></code></pre></div></td></tr></table></figure><p>当看到返回<code>You’ve successfully authenticated</code>即为成功。</p><h4 id="将本地博客推送到GitHub仓库"><a href="#将本地博客推送到GitHub仓库" class="headerlink" title="将本地博客推送到GitHub仓库"></a>将本地博客推送到GitHub仓库</h4><p>安装hexo-deployer-git插件。在命令行运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></div></td></tr></table></figure><p>然后打开站点配置文件<code>_config.yml</code>，把文件的最后修改为如下内容：</p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:&lt;你的Github用户名&gt;/&lt;你的Github用户名&gt;.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></div></td></tr></table></figure><p>接下来就可以把博客推送到GitHub Pages了，在命令行输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></div></td></tr></table></figure><p>其中 hexo clean是清除缓存文件和已生成的静态文件，也可以不加。<br>hexo generate 生成静态文章，可以用缩写 hexo g。<br>hexo deploy 部署网站，可以用缩写hexo d。</p><p>注意deploy时可能要你输入username和password。</p><p>返回<code>INFO Deploy done: git</code>即推送成功了，稍等几分钟就可以在浏览器访问<code>http://你的GitHub用户名.github.io</code></p><p>至此，你的Hexo博客就已经搭建在GitHub Pages了。</p><h4 id="绑定域名（可选）"><a href="#绑定域名（可选）" class="headerlink" title="绑定域名（可选）"></a>绑定域名（可选）</h4><p>略，具体操作看下面的参考链接。</p><h3 id="网站设置和主题优化"><a href="#网站设置和主题优化" class="headerlink" title="网站设置和主题优化"></a>网站设置和主题优化</h3><p>这里的优化主要针对我用的主题-<a href="https://github.com/theme-next/hexo-theme-next">NexT</a>。</p><h4 id="设置网站"><a href="#设置网站" class="headerlink" title="设置网站"></a>设置网站</h4><p>在站点配置文件<code>_config.yml</code>中修改：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">你的博客名称</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">副标题（可不设置）</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">描述，通常由于搜索引擎搜索，SEO优化等（可不设置）</span><br><span class="hljs-attr">keywords:</span> <span class="hljs-string">关键字（可不设置）</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">作者</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN（设置语言）</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">时区（可不设置）</span><br></code></pre></div></td></tr></table></figure><h4 id="修改永久链接的路径"><a href="#修改永久链接的路径" class="headerlink" title="修改永久链接的路径"></a>修改永久链接的路径</h4><p>在站点配置文件<code>_config.yml</code>中修改：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:title/</span><br></code></pre></div></td></tr></table></figure><h4 id="跳过渲染某些文件"><a href="#跳过渲染某些文件" class="headerlink" title="跳过渲染某些文件"></a>跳过渲染某些文件</h4><p>在站点配置文件<code>_config.yml</code>中修改，为了显示某个自己做的网页，或者为了显示readme说明文件等等：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Directory</span><br><span class="hljs-attr">skip_render:</span> <br> <span class="hljs-bullet">-</span> <span class="hljs-string">README.md</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">test/*</span><br> <span class="hljs-comment"># 跳过文件夹下所有文件</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;文件夹名/*&quot;</span>  <br> <span class="hljs-comment"># 跳过子文件夹</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;文件夹名/子文件夹名/*&quot;</span><br> <span class="hljs-comment"># 跳过文件夹下所有子文件夹和文件</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;文件夹名/**&quot;</span>   <br></code></pre></div></td></tr></table></figure><h4 id="设置主题风格"><a href="#设置主题风格" class="headerlink" title="设置主题风格"></a>设置主题风格</h4><p>在主题配置文件<code>themes/next/_config.yml</code>中修改下面的代码，想用哪个就把那个前面的#去掉，给其他的加上#：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Schemes</span><br><span class="hljs-attr">scheme:</span> <span class="hljs-string">Muse</span><br><span class="hljs-comment">#scheme: Mist</span><br><span class="hljs-comment">#scheme: Pisces</span><br><span class="hljs-comment">#scheme: Gemini</span><br></code></pre></div></td></tr></table></figure><h4 id="修改头像"><a href="#修改头像" class="headerlink" title="修改头像"></a>修改头像</h4><p>打开主题配置文件<code>themes/next/_config.yml</code>，找到下面的代码修改：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">avatar:</span><br>  <span class="hljs-comment"># Replace the default image and set the url here.</span><br>  <span class="hljs-attr">url:</span> <span class="hljs-string">图片链接</span><br></code></pre></div></td></tr></table></figure><h4 id="文章信息设置"><a href="#文章信息设置" class="headerlink" title="文章信息设置"></a>文章信息设置</h4><p>还是在主题配置文件<code>themes/next/_config.yml</code>里面修改：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Post meta display settings</span><br><span class="hljs-attr">post_meta:</span><br>  <span class="hljs-attr">item_text:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">created_at:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">updated_at:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">another_day:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">categories:</span> <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><h4 id="回到顶部和文章阅读进度"><a href="#回到顶部和文章阅读进度" class="headerlink" title="回到顶部和文章阅读进度"></a>回到顶部和文章阅读进度</h4><p>修改主题配置文件<code>themes/next/_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">back2top:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># Back to top in sidebar.</span><br>  <span class="hljs-attr">sidebar:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># Scroll percent label in b2t button.</span><br>  <span class="hljs-attr">scrollpercent:</span> <span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure><h4 id="修改网站图标"><a href="#修改网站图标" class="headerlink" title="修改网站图标"></a>修改网站图标</h4><p>修改主题配置文件<code>themes/next/_config.yml</code>，把链接改为自己的：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">favicon:</span><br>  <span class="hljs-attr">small:</span> <span class="hljs-string">/images/favicon-16x16-next.png</span><br>  <span class="hljs-attr">medium:</span> <span class="hljs-string">/images/favicon-32x32-next.png</span><br>  <span class="hljs-attr">apple_touch_icon:</span> <span class="hljs-string">/images/apple-touch-icon-next.png</span><br>  <span class="hljs-attr">safari_pinned_tab:</span> <span class="hljs-string">/images/logo.svg</span><br>  <span class="hljs-comment">#android_manifest: /images/manifest.json</span><br>  <span class="hljs-comment">#ms_browserconfig: /images/browserconfig.xml</span><br></code></pre></div></td></tr></table></figure><h4 id="修改网站页脚信息"><a href="#修改网站页脚信息" class="headerlink" title="修改网站页脚信息"></a>修改网站页脚信息</h4><p>修改主题配置文件<code>themes/next/_config.yml</code>，icon图标去上面注释里面给的网站找，然后把图标名字改成你想要的就行（比如user改成heart），<code>powered</code>和<code>theme</code>是设置底部页脚是否显示hexo版本和主题版本的。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">footer:</span><br>  <span class="hljs-comment"># Specify the date when the site was setup. If not defined, current year will be used.</span><br>  <span class="hljs-comment">#since: 2015</span><br><br>  <span class="hljs-comment"># Icon between year and copyright info.</span><br>  <span class="hljs-attr">icon:</span><br>    <span class="hljs-comment"># Icon name in Font Awesome. See: https://fontawesome.com/v4.7.0/icons/</span><br>    <span class="hljs-comment"># `heart` is recommended with animation in red (#ff0000).</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">user</span><br>    <span class="hljs-comment"># If you want to animate the icon, set it to true.</span><br>    <span class="hljs-attr">animated:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># Change the color of icon, using Hex Code.</span><br>    <span class="hljs-attr">color:</span> <span class="hljs-string">&quot;#808080&quot;</span><br><br>  <span class="hljs-attr">powered:</span><br>    <span class="hljs-comment"># Hexo link (Powered by Hexo).</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># Version info of Hexo after Hexo link (vX.X.X).</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">theme:</span><br>    <span class="hljs-comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># Version info of NexT after scheme info (vX.X.X).</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><p>更多可修改信息在配置文件中查看。</p><h4 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h4><p>编辑主题配置文件<code>themes/next/_config.yml</code>，需要哪个就把哪个的注释去掉：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">menu:</span><br>  <span class="hljs-attr">home:</span> <span class="hljs-string">/</span> <span class="hljs-string">||</span> <span class="hljs-string">home</span><br>  <span class="hljs-comment">#about: /about/ || user</span><br>  <span class="hljs-comment">#tags: /tags/ || tags</span><br>  <span class="hljs-comment">#categories: /categories/ || th</span><br>  <span class="hljs-attr">archives:</span> <span class="hljs-string">/archives/</span> <span class="hljs-string">||</span> <span class="hljs-string">archive</span><br>  <span class="hljs-comment">#schedule: /schedule/ || calendar</span><br>  <span class="hljs-comment">#sitemap: /sitemap.xml || sitemap</span><br>  <span class="hljs-comment">#commonweal: /404/ || heartbeat</span><br><br><span class="hljs-comment"># Enable / Disable menu icons / item badges.</span><br><span class="hljs-attr">menu_settings:</span><br>  <span class="hljs-attr">icons:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">badges:</span> <span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure><h4 id="点击图片查看大图"><a href="#点击图片查看大图" class="headerlink" title="点击图片查看大图"></a>点击图片查看大图</h4><p>编辑主题配置文件<code>themes/next/_config.yml</code>，有两种选择，任选其一就行，把false改成true</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images.</span><br><span class="hljs-comment"># For more information: https://fancyapps.com/fancybox</span><br><span class="hljs-attr">fancybox:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># A JavaScript library for zooming images like Medium.</span><br><span class="hljs-comment"># Do not enable both `fancybox` and `mediumzoom`.</span><br><span class="hljs-comment"># For more information: https://github.com/francoischalifour/medium-zoom</span><br><span class="hljs-attr">mediumzoom:</span> <span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure><h4 id="设置图片懒加载"><a href="#设置图片懒加载" class="headerlink" title="设置图片懒加载"></a>设置图片懒加载</h4><p>编辑主题配置文件<code>themes/next/_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">lazyload:</span> <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><h4 id="设置动态网页背景"><a href="#设置动态网页背景" class="headerlink" title="设置动态网页背景"></a>设置动态网页背景</h4><p>编辑主题配置文件<code>themes/next/_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># JavaScript 3D library.</span><br><span class="hljs-comment"># Dependencies: https://github.com/theme-next/theme-next-three</span><br><span class="hljs-attr">three:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">three_waves:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">canvas_lines:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">canvas_sphere:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Canvas-nest</span><br><span class="hljs-comment"># Dependencies: https://github.com/theme-next/theme-next-canvas-nest</span><br><span class="hljs-comment"># For more information: https://github.com/hustcc/canvas-nest.js</span><br><span class="hljs-attr">canvas_nest:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">onmobile:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Display on mobile or not</span><br>  <span class="hljs-attr">color:</span> <span class="hljs-string">&quot;0,0,255&quot;</span> <span class="hljs-comment"># RGB values, use `,` to separate</span><br>  <span class="hljs-attr">opacity:</span> <span class="hljs-number">0.5</span> <span class="hljs-comment"># The opacity of line: 0~1</span><br>  <span class="hljs-attr">zIndex:</span> <span class="hljs-number">-1</span> <span class="hljs-comment"># z-index property of the background</span><br>  <span class="hljs-attr">count:</span> <span class="hljs-number">99</span> <span class="hljs-comment"># The number of lines</span><br><br><span class="hljs-comment"># Canvas-ribbon</span><br><span class="hljs-comment"># Dependencies: https://github.com/theme-next/theme-next-canvas-ribbon</span><br><span class="hljs-comment"># For more information: https://github.com/zproo/canvas-ribbon</span><br><span class="hljs-attr">canvas_ribbon:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">size:</span> <span class="hljs-number">300</span> <span class="hljs-comment"># The width of the ribbon</span><br>  <span class="hljs-attr">alpha:</span> <span class="hljs-number">0.6</span> <span class="hljs-comment"># The transparency of the ribbon</span><br>  <span class="hljs-attr">zIndex:</span> <span class="hljs-number">-1</span> <span class="hljs-comment"># The display level of the ribbon</span><br></code></pre></div></td></tr></table></figure><h4 id="设置网站顶部加载进度条"><a href="#设置网站顶部加载进度条" class="headerlink" title="设置网站顶部加载进度条"></a>设置网站顶部加载进度条</h4><p>编辑主题配置文件<code>themes/next/_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">pace:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><h4 id="自定义网页背景"><a href="#自定义网页背景" class="headerlink" title="自定义网页背景"></a>自定义网页背景</h4><p>首先在站点根目录的<code>source\_data</code>文件夹内新建一个名为<code>styles.styl</code>的文件，然后编辑主题配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">custom_file_path:</span><br>  <span class="hljs-attr">style:</span> <span class="hljs-string">source/_data/styles.styl</span><br></code></pre></div></td></tr></table></figure><p><strong>我们所有自定义的样式都会在<code>styles.styl</code>这个文件里添加</strong>。</p><p>编辑<code>styles.styl</code>，添加如下代码，把URL里面的地址改为你的背景图片的链接即可：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;<br>    <span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">/images/bg.jpg</span>);<br>    <span class="hljs-attribute">background-size</span>:cover;<br>    <span class="hljs-attribute">background-repeat</span>:no-repeat;<br>    <span class="hljs-attribute">background-attachment</span>:fixed;<br>    <span class="hljs-attribute">background-position</span>:center;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="自定义鼠标样式"><a href="#自定义鼠标样式" class="headerlink" title="自定义鼠标样式"></a>自定义鼠标样式</h4><p>还是在<code>styles.styl</code>里编辑，添加下面的代码：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">// 鼠标样式<br>  * &#123;<br>      <span class="hljs-attribute">cursor</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;鼠标图标地址&quot;</span>),auto<span class="hljs-meta">!important</span><br>  &#125;<br>  <span class="hljs-selector-pseudo">:active</span> &#123;<br>      <span class="hljs-attribute">cursor</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;鼠标图标地址&quot;</span>),auto<span class="hljs-meta">!important</span><br>  &#125;<br></code></pre></div></td></tr></table></figure><h4 id="点击出现爱心效果"><a href="#点击出现爱心效果" class="headerlink" title="点击出现爱心效果"></a>点击出现爱心效果</h4><p>在主题文件夹内的<code>/source/js/src</code>下新建文件<code>click-effect.js</code>，接着把下面的内容复制粘贴到<code>click-effect.js</code>文件中。<br>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e,t,a</span>)</span>&#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>)</span>&#123;c(<span class="hljs-string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>),o(),r()&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">r</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> e=<span class="hljs-number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="hljs-number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="hljs-number">1</span>)):(d[e].y--,d[e].scale+=<span class="hljs-number">.004</span>,d[e].alpha-=<span class="hljs-number">.013</span>,d[e].el.style.cssText=<span class="hljs-string">&quot;left:&quot;</span>+d[e].x+<span class="hljs-string">&quot;px;top:&quot;</span>+d[e].y+<span class="hljs-string">&quot;px;opacity:&quot;</span>+d[e].alpha+<span class="hljs-string">&quot;;transform:scale(&quot;</span>+d[e].scale+<span class="hljs-string">&quot;,&quot;</span>+d[e].scale+<span class="hljs-string">&quot;) rotate(45deg);background:&quot;</span>+d[e].color+<span class="hljs-string">&quot;;z-index:99999&quot;</span>);requestAnimationFrame(r)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">o</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">var</span> t=<span class="hljs-string">&quot;function&quot;</span>==<span class="hljs-keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">i</span>(<span class="hljs-params">e</span>)</span>&#123;<span class="hljs-keyword">var</span> a=t.createElement(<span class="hljs-string">&quot;div&quot;</span>);a.className=<span class="hljs-string">&quot;heart&quot;</span>,d.push(&#123;<span class="hljs-attr">el</span>:a,<span class="hljs-attr">x</span>:e.clientX-<span class="hljs-number">5</span>,<span class="hljs-attr">y</span>:e.clientY-<span class="hljs-number">5</span>,<span class="hljs-attr">scale</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">alpha</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params">e</span>)</span>&#123;<span class="hljs-keyword">var</span> a=t.createElement(<span class="hljs-string">&quot;style&quot;</span>);a.type=<span class="hljs-string">&quot;text/css&quot;</span>;<span class="hljs-keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="hljs-keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>].appendChild(a)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span><span class="hljs-string">&quot;rgb(&quot;</span>+~~(<span class="hljs-number">255</span>*<span class="hljs-built_in">Math</span>.random())+<span class="hljs-string">&quot;,&quot;</span>+~~(<span class="hljs-number">255</span>*<span class="hljs-built_in">Math</span>.random())+<span class="hljs-string">&quot;,&quot;</span>+~~(<span class="hljs-number">255</span>*<span class="hljs-built_in">Math</span>.random())+<span class="hljs-string">&quot;)&quot;</span>&#125;<span class="hljs-keyword">var</span> d=[];e.requestAnimationFrame=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;<span class="hljs-built_in">setTimeout</span>(e,<span class="hljs-number">1e3</span>/<span class="hljs-number">60</span>)&#125;&#125;(),n()&#125;(<span class="hljs-built_in">window</span>,<span class="hljs-built_in">document</span>);<br></code></pre></div></td></tr></table></figure><p>在主题文件夹的<code>\layout\_layout.swig</code>文件末尾添加：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 页面点击出现小桃心 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/src/clicklove.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h3><h4 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h4><p>这里搜索功能我用的是本地搜索，也有一些其他的搜索方法，比如Aloglia，使用前需要注册账号，具体操作因为没有实践所以跳过，下面说一下添加本地搜索功能的方法：</p><ol><li><p>安装 <code>hexo-generator-searchdb</code>，在站点的根目录下执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-generator-searchdb --save<br></code></pre></div></td></tr></table></figure></li><li><p>编辑站点配置文件<code>_config.yml</code>，新增以下内容到任意位置：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">search:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">search.xml</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">post</span><br>  <span class="hljs-attr">format:</span> <span class="hljs-string">html</span><br>  <span class="hljs-attr">limit:</span> <span class="hljs-number">10000</span><br></code></pre></div></td></tr></table></figure></li><li><p>编辑主题配置文件<code>themes/next/_config.yml</code>，启用本地搜索功能：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Local search</span><br><span class="hljs-attr">local_search:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure></li></ol><h4 id="添加评论和统计功能"><a href="#添加评论和统计功能" class="headerlink" title="添加评论和统计功能"></a>添加评论和统计功能</h4><p>略，没有实际添加这两个功能，想添加的话看下面参考链接。</p><h4 id="添加网页看板娘（Live2D）"><a href="#添加网页看板娘（Live2D）" class="headerlink" title="添加网页看板娘（Live2D）"></a>添加网页看板娘（Live2D）</h4><p>首先安装Live2D插件，在站点根目录下运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install --save hexo-helper-live2d<br></code></pre></div></td></tr></table></figure><p>然后选择自己喜欢的模型，复制名字。</p><p>Epsilon2.1</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>Gantzert_Felixander</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>haru</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>miku</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>ni-j</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>nico</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>nietzche</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>nipsilon</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>nito</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>shizuku</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>tsumiki</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>wanko</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>z16</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>hibiki</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>koharu</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>haruto</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>Unitychan</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>tororo</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>hijiki</p><p><img src="" srcset="/img/loading.gif" lazyload alt="img"></p><p>将下面的代码添加到站点配置文件<code>_config.yml</code>中，修改&lt;模型名字&gt;（有教程说放在主题配置文件中，但是实际测试放在主题文件中并不好用，不管使用哪个模型网页中都不生效，都显示默认的<code>shizuku</code>这个模型，但是把代码放在站点配置文件中就好用了，不知道是什么原因）</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Live2D</span><br><span class="hljs-comment">## https://github.com/EYHN/hexo-helper-live2d</span><br><span class="hljs-attr">live2d:</span><br>  <span class="hljs-comment"># enable: true</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">scriptFrom:</span> <span class="hljs-string">local</span> <span class="hljs-comment"># 默认</span><br>  <span class="hljs-attr">pluginRootPath:</span> <span class="hljs-string">live2dw/</span> <span class="hljs-comment"># 插件在站点上的根目录(相对路径)</span><br>  <span class="hljs-attr">pluginJsPath:</span> <span class="hljs-string">lib/</span> <span class="hljs-comment"># 脚本文件相对与插件根目录路径</span><br>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span> <span class="hljs-comment"># 模型文件相对与插件根目录路径</span><br>  <span class="hljs-comment"># scriptFrom: jsdelivr # jsdelivr CDN</span><br>  <span class="hljs-comment"># scriptFrom: unpkg # unpkg CDN</span><br>  <span class="hljs-comment"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span><br>  <span class="hljs-attr">tagMode:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br>  <span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 调试, 是否在控制台输出日志</span><br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-&lt;模型名字&gt;</span> <span class="hljs-comment"># npm-module package name</span><br>    <span class="hljs-comment"># use: wanko # 博客根目录/live2d_models/ 下的目录名</span><br>    <span class="hljs-comment"># use: ./wives/wanko # 相对于博客根目录的路径</span><br>    <span class="hljs-comment"># use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url</span><br>    <span class="hljs-attr">scale:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">hHeadPos:</span> <span class="hljs-number">0.5</span><br>    <span class="hljs-attr">vHeadPos:</span> <span class="hljs-number">0.618</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">superSample:</span> <span class="hljs-number">2</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">250</span><br>    <span class="hljs-attr">height:</span> <span class="hljs-number">500</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">right</span><br>    <span class="hljs-attr">hOffset:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">vOffset:</span> <span class="hljs-number">-20</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">scale:</span> <span class="hljs-number">0.5</span><br>  <span class="hljs-attr">react:</span><br>    <span class="hljs-attr">opacity:</span> <span class="hljs-number">0.7</span><br>  <span class="hljs-attr">dialog:</span> <br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">hitokoto:</span> <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><p>安装你选择的模型，在命令行运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install --save live2d-widget-model-&lt;你选择的模型名字&gt;<br></code></pre></div></td></tr></table></figure><p>然后在命令行运行以下命令，在浏览器里访问<code>localhost:4000</code>查看效果</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></div></td></tr></table></figure><p>上面的配置都完成以后就可以开始写博客了。</p><h3 id="利用GitHub备份博客源文件并且进行多终端操作"><a href="#利用GitHub备份博客源文件并且进行多终端操作" class="headerlink" title="利用GitHub备份博客源文件并且进行多终端操作"></a>利用GitHub备份博客源文件并且进行多终端操作</h3><p>在你换电脑或者重装系统的时候万一不小心把博客的站点文件夹删了或者弄丢了那就什么都没了，所以为了防止发生这样的情况，就可以用GitHub来保存博客的源文件。</p><h4 id="用命令行操作"><a href="#用命令行操作" class="headerlink" title="用命令行操作"></a>用命令行操作</h4><p>具体操作是在你的GitHub中新建一个仓库或者在你的博客仓库内新建一个分支，个人推荐新建一个仓库，和博客的静态文件分开管理比较好，然后在本地找一个空文件夹，运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:你的项目地址<br></code></pre></div></td></tr></table></figure><p>把仓库克隆到本地，然后把你的博客源文件全部复制过来，除了<code>.deploy_git</code>，注意复制过来的文件里面应该有一个叫<code>.gitignore</code>的文件，用来忽略一些不要提交到Git的文件，如果没有可以自己新建一个，在里面加上下面的内容：</p><figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-meta">.DS_Store</span><br>Thumbs<span class="hljs-number">.</span><span class="hljs-built_in">db</span><br><span class="hljs-built_in">db</span><span class="hljs-number">.</span>json<br>*.log<br>node_modules/<br><span class="hljs-meta">public</span>/<br><span class="hljs-meta">.deploy</span>*/<br></code></pre></div></td></tr></table></figure><p>如果还有其他自己不想提交的文件也可以加到这个文件中。</p><p>然后再在命令行中执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git add .<br>git commit –m <span class="hljs-string">&quot;commit message&quot;</span><br>git push <br></code></pre></div></td></tr></table></figure><p>可以在网页中查看是否上传成功。</p><p>当你换了电脑或者重装系统后想把博客下回来怎么操作？</p><p>首先前面的都一样，下载安装node，Git，然后设置git全局邮箱和用户名，设置SHH，安装hexo，然后在任意一个文件夹内，执行<code>git clone git@你的博客源文件仓库地址</code>，进入克隆下来的文件夹，运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install<br>npm install hexo-deployer-git --save<br></code></pre></div></td></tr></table></figure><p>然后就可以继续写博客了，写完之后运行<code>hexo g &amp;&amp; hexo d</code>，就可以部署到GitHub Pages上了。而且现在可以每次写完博客都把源文件备份一下了：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git add .<br>git commit –m <span class="hljs-string">&quot;commit message&quot;</span><br>git push <br></code></pre></div></td></tr></table></figure><h4 id="用GitHub-Desktop操作"><a href="#用GitHub-Desktop操作" class="headerlink" title="用GitHub Desktop操作"></a>用GitHub Desktop操作</h4><p>下载安装GitHub Desktop然后登陆GitHub，把对应的作为保存博客源文件的仓库克隆到本地，然后把除了<code>.deploy_git</code>以外的博客源文件复制进来，注意有没有<code>.gitignore</code>这个文件，没有按上面方法加上，然后再写上备注信息，，提交推送到Git上就行了。</p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://www.simon96.online/2018/10/12/hexo-tutorial/">【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析</a></p><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">hexo史上最全搭建教程</a></p><p><a href="https://uchuhimo.me/2017/04/11/genesis/">如何使用 Hexo 和 GitHub Pages 搭建这个博客</a></p><p><a href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></p><p><a href="http://theme-next.iissnan.com/getting-started.html">开始使用-NexT使用文档</a></p><p><a href="https://hexo-theme-next.netlify.com/docs/">Documention | NexT</a></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
