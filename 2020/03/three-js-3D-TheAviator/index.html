<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/-221011ca0d9ca71f.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="DogeLasVegas">
  <meta name="keywords" content="">
  <title>【转】利用Three.js制作一个3D动画飞行场景 - 性感咸鱼，在线翻身</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/hybrid.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/custom.css">



  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>道格拉斯维加斯</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/collect/">
                <i class="iconfont icon-brush"></i>
                恰独食
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('https://cdn.jsdelivr.net/gh/dogelasvegas/blog-img/page-bgimg/loadingpic160.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-03-10 09:41">
      2020年3月10日 上午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.2k 字
    </span>
  

  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年3月10日 上午
                
              </p>
            
            <article class="markdown-body">
              <p>一篇关于探讨使用 Three.js 创建 3D 动画场景的基础教程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" alt="img"></p>
<p><a href="http://tympanus.net/Tutorials/TheAviator/" target="_blank" rel="noopener">DEMO</a>     <a href="http://tympanus.net/Tutorials/TheAviator/TheAviator.zip" target="_blank" rel="noopener">源码下载</a></p>
<p>今日，我们将使用 Three.js 创建一个简单的 3D 飞机飞行的动画场景。Three.js 是一个 3D 类库，它能让 WebGL 变得更加简单。由于 GSL 语法的复杂性，对于许多开发人员来说 WebGL 是一个未知的领域。但是有了 Three.js，在浏览器中 3D 的实现变得简单。</p>
<blockquote>
<p>(译者注：WebGL 是一项利用 JavaScriptAPI 渲染交互式 3D 电脑图形和 2D 图形的技术，可兼容任何的网页浏览器，无需加装插件。通过 WebGL 的技术，只需要编写网页代码即可实现 3D 图像的展示。GLSL-OpenGL Shading Language 也称作 GLslang ，是一个以 C 语言为基础的高阶着色语言。它是由 OpenGL ARB 所建立，提供开发者对绘图管线更多的直接控制，而无需使用汇编语言或硬件规格语言。详细麻烦谷歌或百度一下～)</p>
</blockquote>
<p>在本教程中，我们将创建一个简单的 3D 场景, 在两个主要的部分会有一些交互。在<a href="http://tympanus.net/Tutorials/TheAviator/part1.html" target="_blank" rel="noopener">第一部分</a>，我们会讲解 Three.js 的基础和如何创建一个简单的场景。<a href="http://tympanus.net/Tutorials/TheAviator/part2.html" target="_blank" rel="noopener">第二部分</a>会详细讲述如何优化模型，如何为场景中的不同元素增添气氛以及更流畅的运动效果。</p>
<p>由于完整的<a href="http://tympanus.net/Tutorials/TheAviator/" target="_blank" rel="noopener">游戏</a>超出了本教程的范围，但是你可以下载或 check out 源码。它包含了许多额外有趣的部分如：碰撞，抓硬币和增加得分。</p>
<p>在本教程中，我们将重点学习 Three.js 中的一些基础概念。这些基础概念将带你走进 WebGL 这新领域！</p>
<p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" alt="img"></p>
<p>事不宜迟，我们马上开始~</p>
<h2 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h2><p>本教程主要采用 Three.js 类库，Three.js 让 WebGL 变得易于使用。从<a href="http://threejs.org/" target="_blank" rel="noopener">官网</a>或 <a href="https://github.com/mrdoob/three.js/" target="_blank" rel="noopener">GitHub repo</a> check out 获取关于 Three.js 更多的信息。</p>
<p>第一样要做的事情就是在 HTML <header> 标签中引入 Three.js：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/three.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<p>然后在 HTML 中需要添加一个元素作为容器。</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"world"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>

<p>你可以像下面那样写一些简单的样式，让它填满整个 viewport：<br> #world {<br> position: absolute;<br> width: 100%;<br> height: 100%;<br> overflow: hidden;<br> background: linear-gradient(#e4e0ba, #f7d9aa);<br> }<br> 正如你所见的一样，背景有些渐变的效果，就像天空。</p>
<p>以上是标签和样式！</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><hr>
<p>如果你已经掌握了一些 JavaScript 的基础知识，使用 Three.js 会变得相当简单。来~我们看看实现不同部分的代码。</p>
<h3 id="The-Color-Palette"><a href="#The-Color-Palette" class="headerlink" title="The Color Palette"></a>The Color Palette</h3><p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" alt="img"></p>
<p>在开始场景编码之前，我觉得定义一个调色板是很有用的。因为在整个项目中会经常使用到。在这个项目中，我们会选择以下这些颜色：</p>
<pre><code class="hljs csharp"><span class="hljs-keyword">var</span> Colors = &#123;
   red:<span class="hljs-number">0xf25346</span>,    
   white:<span class="hljs-number">0xd8d0d1</span>,  
   brown:<span class="hljs-number">0x59332e</span>,  
   pink:<span class="hljs-number">0xF5986E</span>,   
   brownDark:<span class="hljs-number">0x23190f</span>,  
   blue:<span class="hljs-number">0x68c3c0</span>
&#125;;</code></pre>

<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>虽然 JavaScript 代码十分冗长，但是它的结构很简单。我们需要创建所有主要的函数并放入初始函数中：</p>
<pre><code class="hljs jsx"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'load'</span>, init, <span class="hljs-literal">false</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>) </span>&#123;
   <span class="hljs-comment">// 创建场景，相机和渲染器</span>
   createScene(); 
   <span class="hljs-comment">// 添加光源</span>
   createLights(); 
   <span class="hljs-comment">// 添加对象 </span>
   createPlane();   
   createSea(); 
   createSky(); 
   <span class="hljs-comment">// 调用循环函数，在每帧更新对象的位置和渲染场景</span>
   loop();
&#125;</code></pre>

<h3 id="创建场景"><a href="#创建场景" class="headerlink" title="创建场景"></a>创建场景</h3><p>创建一个 Three.js 的项目，我们至少需要以下这些：</p>
<ol>
<li><strong>场景：</strong>把这看作一个舞台，将需要呈现的对象都添加进去。</li>
<li><strong>相机：</strong>在这情况下，我们将使用透视相机，但它也可能是正投影相机。</li>
<li><strong>渲染器：</strong>使用 WebGL 渲染器显示所有的场景。</li>
<li><strong>渲染一个或多个对象：</strong> 在我们的例子中，我们会创建飞机，大海，天空（一些云）。</li>
<li><strong>光源：</strong>有不同类型可用的光源。在我们的项目中，我们主要用到营造氛围的半球光和制造阴影的方向光。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" alt="img"></p>
<p>在 createScene 函数中创建场景，相机以及渲染器。</p>
<blockquote>
<p>译者注：</p>
</blockquote>
<ul>
<li><p>Three.js 场景只有一种，THREE.Scene 场景是所有物体的容器。</p>
</li>
<li><p>相机决定了场景中哪个角度的景色会显示出来。</p>
</li>
<li><p>渲染器决定了渲染的结果应该显示在页面的什么元素上，并以怎样的方式绘制。<br> 有了这三样东西，才能使用相机将对象渲染到页面中。</p>
<p>var scene, camera, fieldOfView, aspectRatio, nearPlane,<br> farPlane, HEIGHT, WIDTH, renderer, container;<br> function createScene() {<br> // 获得屏幕的宽和高，<br> // 用它们设置相机的纵横比<br> // 还有渲染器的大小<br> HEIGHT = window.innerHeight;<br> WIDTH = window.innerWidth;</p>
</li>
</ul>
  <pre><code class="hljs dart"><span class="hljs-comment">// 创建场景</span>
scene = <span class="hljs-keyword">new</span> THREE.Scene();       
  
<span class="hljs-comment">// 在场景中添加雾的效果；样式上使用和背景一样的颜色</span>
scene.fog = <span class="hljs-keyword">new</span> THREE.Fog(<span class="hljs-number">0xf7d9aa</span>, <span class="hljs-number">100</span>, <span class="hljs-number">950</span>);
  
<span class="hljs-comment">// 创建相机</span>
aspectRatio = WIDTH / HEIGHT;   
fieldOfView = <span class="hljs-number">60</span>;   
nearPlane = <span class="hljs-number">1</span>;  
farPlane = <span class="hljs-number">10000</span>;
<span class="hljs-comment"><span class="markdown">/**
<span class="hljs-bullet"> * </span>PerspectiveCamera 透视相机
<span class="hljs-bullet"> * </span>@param fieldOfView 视角
<span class="hljs-bullet"> * </span>@param aspectRatio 纵横比
<span class="hljs-bullet"> * </span>@param nearPlane 近平面
<span class="hljs-bullet"> * </span>@param farPlane 远平面
 */</span></span>
camera = <span class="hljs-keyword">new</span> THREE.PerspectiveCamera(       
  fieldOfView,
  aspectRatio,
  nearPlane,
  farPlane
  );
  
<span class="hljs-comment">// 设置相机的位置</span>
camera.position.x = <span class="hljs-number">0</span>;  
camera.position.z = <span class="hljs-number">200</span>;    
camera.position.y = <span class="hljs-number">100</span>; 
  
<span class="hljs-comment">// 创建渲染器</span>
renderer = <span class="hljs-keyword">new</span> THREE.WebGLRenderer(&#123; 
<span class="hljs-comment">// 在 css 中设置背景色透明显示渐变色</span>
  alpha: <span class="hljs-keyword">true</span>, 
<span class="hljs-comment">// 开启抗锯齿，但这样会降低性能。</span>
<span class="hljs-comment">// 不过，由于我们的项目基于低多边形的，那还好 :) </span>
  antialias: <span class="hljs-keyword">true</span> 
&#125;);
  
<span class="hljs-comment">// 定义渲染器的尺寸；在这里它会填满整个屏幕</span>
renderer.setSize(WIDTH, HEIGHT); 
  
<span class="hljs-comment">// 打开渲染器的阴影地图</span>
renderer.shadowMap.enabled = <span class="hljs-keyword">true</span>; 
  
<span class="hljs-comment">// 在 HTML 创建的容器中添加渲染器的 DOM 元素</span>
container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'world'</span>);   
container.appendChild(renderer.domElement);
  
<span class="hljs-comment">// 监听屏幕，缩放屏幕更新相机和渲染器的尺寸</span>
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'resize'</span>, handleWindowResize, <span class="hljs-keyword">false</span>);</code></pre>

<p>  }</p>
<p>由于屏幕的尺寸改变，我们需要更新渲染器的尺寸和相机的纵横比。</p>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleWindowResize</span>(<span class="hljs-params"></span>) </span>&#123; 
   <span class="hljs-comment">// 更新渲染器的高度和宽度以及相机的纵横比</span>
   HEIGHT = <span class="hljs-built_in">window</span>.innerHeight; 
   WIDTH = <span class="hljs-built_in">window</span>.innerWidth;           
   renderer.setSize(WIDTH, HEIGHT); 
   camera.aspect = WIDTH / HEIGHT;        
   camera.updateProjectionMatrix();
&#125;</code></pre>

<h3 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h3><p>当创建一个场景时，光源是最棘手的一部分。光源可以奠定整个场景的基调，所以要适当地选取。在这部分我们要尽量制造足以让对象可见的光源。</p>
<pre><code class="hljs csharp"><span class="hljs-keyword">var</span> hemisphereLight, shadowLight;
<span class="hljs-function">function <span class="hljs-title">createLights</span>(<span class="hljs-params"></span>)</span> &#123;
   <span class="hljs-comment">// 半球光就是渐变的光；</span>
   <span class="hljs-comment">// 第一个参数是天空的颜色，第二个参数是地上的颜色，第三个参数是光源的强度</span>
   hemisphereLight = <span class="hljs-keyword">new</span> THREE.HemisphereLight(<span class="hljs-number">0xaaaaaa</span>,<span class="hljs-number">0x000000</span>, <span class="hljs-number">.9</span>);

   <span class="hljs-comment">// 方向光是从一个特定的方向的照射</span>
   <span class="hljs-comment">// 类似太阳，即所有光源是平行的</span>
   <span class="hljs-comment">// 第一个参数是关系颜色，第二个参数是光源强度</span>
   shadowLight = <span class="hljs-keyword">new</span> THREE.DirectionalLight(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">.9</span>);

   <span class="hljs-comment">// 设置光源的方向。  </span>
   <span class="hljs-comment">// 位置不同，方向光作用于物体的面也不同，看到的颜色也不同</span>
   shadowLight.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">150</span>, <span class="hljs-number">350</span>, <span class="hljs-number">350</span>);

   <span class="hljs-comment">// 开启光源投影 </span>
   shadowLight.castShadow = <span class="hljs-literal">true</span>;

   <span class="hljs-comment">// 定义可见域的投射阴影</span>
   shadowLight.shadow.camera.left = <span class="hljs-number">-400</span>;
   shadowLight.shadow.camera.right = <span class="hljs-number">400</span>;
   shadowLight.shadow.camera.top = <span class="hljs-number">400</span>;
   shadowLight.shadow.camera.bottom = <span class="hljs-number">-400</span>;
   shadowLight.shadow.camera.near = <span class="hljs-number">1</span>;
   shadowLight.shadow.camera.far = <span class="hljs-number">1000</span>;

   <span class="hljs-comment">// 定义阴影的分辨率；虽然分辨率越高越好，但是需要付出更加昂贵的代价维持高性能的表现。</span>
   shadowLight.shadow.mapSize.width = <span class="hljs-number">2048</span>;
   shadowLight.shadow.mapSize.height = <span class="hljs-number">2048</span>;

   <span class="hljs-comment">// 为了使这些光源呈现效果，只需要将它们添加到场景中</span>
   scene.<span class="hljs-keyword">add</span>(hemisphereLight);  
   scene.<span class="hljs-keyword">add</span>(shadowLight);
&#125;</code></pre>

<p>正如你所见，创建光源用到许多参数。不要再犹豫，大胆尝试用不同的颜色，强度的光源。你发现不同的光源在场景中能够营造有趣的氛围和环境。而且你会找到感觉：如何按照你的需求优化它们。</p>
<h2 id="用-Three-js-创建对象"><a href="#用-Three-js-创建对象" class="headerlink" title="用 Three.js 创建对象"></a>用 Three.js 创建对象</h2><hr>
<blockquote>
<p>如果你熟悉使用 3D 建模软件，你可以先在软件中建立物体且能简单地将它们导入到你的 Three.js 项目中。在本教程中不涉及具体的解决方案。为了更好地了解它们具体是如何工作的。我们使用 Three.js 中现成的几何体创建对象。</p>
</blockquote>
<p>Three.js 中已经有大量的现成几何体如：立方体，球体，圆环面，圆柱体以及飞机原型。</p>
<p>对于我们的项目，所有的对象只需要通过这些几何体组合而成。这非常适合低多边形的风格，而且我们可以不必在 3D 建模软件中创建对象。</p>
<h3 id="用一个圆柱体代表大海"><a href="#用一个圆柱体代表大海" class="headerlink" title="用一个圆柱体代表大海"></a>用一个圆柱体代表大海</h3><p>我们开始创建大海模型，因为它是我们实现中最简单的对象。为了简单起见，我们将大海看作一个简单的圆柱体放置在屏幕的底部。之后我们再深入研究如何改善大海的外观。<br> 接着，让我们使大海看起来更具吸引力，海浪更加逼真。</p>
<pre><code class="hljs jsx"><span class="hljs-comment">//首先定义一个大海对象</span>
Sea = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;

   <span class="hljs-comment">// 创建一个圆柱几何体</span>
   <span class="hljs-comment">// 参数为：顶面半径，底面半径，高度，半径分段，高度分段</span>
   <span class="hljs-keyword">var</span> geom = <span class="hljs-keyword">new</span> THREE.CylinderGeometry(<span class="hljs-number">600</span>,<span class="hljs-number">600</span>,<span class="hljs-number">800</span>,<span class="hljs-number">40</span>,<span class="hljs-number">10</span>);

   <span class="hljs-comment">// 在 x 轴旋转几何体</span>
   geom.applyMatrix(<span class="hljs-keyword">new</span> THREE.Matrix4().makeRotationX(-<span class="hljs-built_in">Math</span>.PI/<span class="hljs-number">2</span>));

   <span class="hljs-comment">// 创建材质</span>
   <span class="hljs-keyword">var</span> mat = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;
       <span class="hljs-attr">color</span>:Colors.blue,
       <span class="hljs-attr">transparent</span>:<span class="hljs-literal">true</span>,
       <span class="hljs-attr">opacity</span>:<span class="hljs-number">.6</span>,
       <span class="hljs-attr">shading</span>:THREE.FlatShading,
   &#125;);

   <span class="hljs-comment">// 为了在 Three.js 创建一个物体，我们必须创建网格用来组合几何体和一些材质 </span>
   <span class="hljs-keyword">this</span>.mesh = <span class="hljs-keyword">new</span> THREE.Mesh(geom, mat);

   <span class="hljs-comment">// 允许大海对象接收阴影</span>
   <span class="hljs-keyword">this</span>.mesh.receiveShadow = <span class="hljs-literal">true</span>; 
&#125;

<span class="hljs-comment">//实例化大海对象，并添加至场景</span>
<span class="hljs-keyword">var</span> sea;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSea</span>(<span class="hljs-params"></span>)</span>&#123;
   sea = <span class="hljs-keyword">new</span> Sea();

   <span class="hljs-comment">// 在场景底部，稍微推挤一下</span>
   sea.mesh.position.y = <span class="hljs-number">-600</span>;

   <span class="hljs-comment">// 添加大海的网格至场景</span>
   scene.add(sea.mesh);
&#125;</code></pre>

<p>总结一下创建对象，需要什么东西。<br> 我们需要：</p>
<ol>
<li>创建几何体</li>
<li>创建材质</li>
<li>将它们传入网格</li>
<li>将网格添加至场景</li>
</ol>
<p>通过这些步骤，我们可以创建许多不同种类的几何体。现在，如果我们把它们组合起来，就可以创建更多复杂的形状。</p>
<p>在以下步骤中，我们将精确地学习如何创建复杂的形状。</p>
<h3 id="把简单的正方体组合建造复杂的形状"><a href="#把简单的正方体组合建造复杂的形状" class="headerlink" title="把简单的正方体组合建造复杂的形状"></a>把简单的正方体组合建造复杂的形状</h3><p>云的制作会有一点点复杂，因为他们是由若干个正方体组合而成的一个随机形状。</p>
<p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" alt="img"></p>
<pre><code class="hljs jsx">Cloud = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
   <span class="hljs-comment">// 创建一个空的容器放置不同形状的云</span>
   <span class="hljs-keyword">this</span>.mesh = <span class="hljs-keyword">new</span> THREE.Object3D();

   <span class="hljs-comment">// 创建一个正方体</span>
   <span class="hljs-comment">// 这个形状会被复制创建云</span>
   <span class="hljs-keyword">var</span> geom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">20</span>,<span class="hljs-number">20</span>,<span class="hljs-number">20</span>);

   <span class="hljs-comment">// 创建材质；一个简单的白色材质就可以达到效果</span>
   <span class="hljs-keyword">var</span> mat = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;
       <span class="hljs-attr">color</span>:Colors.white,  
   &#125;);

   <span class="hljs-comment">// 随机多次复制几何体</span>
   <span class="hljs-keyword">var</span> nBlocs = <span class="hljs-number">3</span>+<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">3</span>);
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;nBlocs; i++ )&#123;
    
       <span class="hljs-comment">// 通过复制几何体创建网格</span>
       <span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> THREE.Mesh(geom, mat); 
    
       <span class="hljs-comment">// 随机设置每个正方体的位置和旋转角度</span>
       m.position.x = i*<span class="hljs-number">15</span>;
       m.position.y = <span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">10</span>;
       m.position.z = <span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">10</span>;
       m.rotation.z = <span class="hljs-built_in">Math</span>.random()*<span class="hljs-built_in">Math</span>.PI*<span class="hljs-number">2</span>;
       m.rotation.y = <span class="hljs-built_in">Math</span>.random()*<span class="hljs-built_in">Math</span>.PI*<span class="hljs-number">2</span>;
    
       <span class="hljs-comment">// 随机设置正方体的大小</span>
       <span class="hljs-keyword">var</span> s = <span class="hljs-number">.1</span> + <span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">.9</span>;
       m.scale.set(s,s,s);
    
       <span class="hljs-comment">// 允许每个正方体生成投影和接收阴影</span>
       m.castShadow = <span class="hljs-literal">true</span>;
       m.receiveShadow = <span class="hljs-literal">true</span>;
    
       <span class="hljs-comment">// 将正方体添加至开始时我们创建的容器中</span>
       <span class="hljs-keyword">this</span>.mesh.add(m);
   &#125; 
&#125;</code></pre>

<p>现在，我们已经创建一朵云，我们通过复制它来创建天空，而且将其放置在 z 轴任意位置。</p>
<pre><code class="hljs jsx"><span class="hljs-comment">// 定义一个天空对象</span>
Sky = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
   <span class="hljs-comment">// 创建一个空的容器</span>
   <span class="hljs-keyword">this</span>.mesh = <span class="hljs-keyword">new</span> THREE.Object3D();

   <span class="hljs-comment">// 选取若干朵云散布在天空中</span>
   <span class="hljs-keyword">this</span>.nClouds = <span class="hljs-number">20</span>;

   <span class="hljs-comment">// 把云均匀地散布</span>
   <span class="hljs-comment">// 我们需要根据统一的角度放置它们</span>
   <span class="hljs-keyword">var</span> stepAngle = <span class="hljs-built_in">Math</span>.PI*<span class="hljs-number">2</span> / <span class="hljs-keyword">this</span>.nClouds;

   <span class="hljs-comment">// 创建云对象</span>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-keyword">this</span>.nClouds; i++)&#123;
       <span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> Cloud();
 
       <span class="hljs-comment">// 设置每朵云的旋转角度和位置</span>
       <span class="hljs-comment">// 因此我们使用了一点三角函数</span>
       <span class="hljs-keyword">var</span> a = stepAngle*i; <span class="hljs-comment">//这是云的最终角度</span>
       <span class="hljs-keyword">var</span> h = <span class="hljs-number">750</span> + <span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">200</span>; <span class="hljs-comment">// 这是轴的中心和云本身之间的距离</span>

       <span class="hljs-comment">// 三角函数！！！希望你还记得数学学过的东西 :)</span>
       <span class="hljs-comment">// 假如你不记得: </span>
       <span class="hljs-comment">// 我们简单地把极坐标转换成笛卡坐标</span>
       c.mesh.position.y = <span class="hljs-built_in">Math</span>.sin(a)*h;
       c.mesh.position.x = <span class="hljs-built_in">Math</span>.cos(a)*h;

       <span class="hljs-comment">// 根据云的位置旋转它</span>
       c.mesh.rotation.z = a + <span class="hljs-built_in">Math</span>.PI/<span class="hljs-number">2</span>;

       <span class="hljs-comment">// 为了有更好的效果，我们把云放置在场景中的随机深度位置</span>
       c.mesh.position.z = <span class="hljs-number">-400</span>-<span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">400</span>;
    
       <span class="hljs-comment">// 而且我们为每朵云设置一个随机大小</span>
       <span class="hljs-keyword">var</span> s = <span class="hljs-number">1</span>+<span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">2</span>;
       c.mesh.scale.set(s,s,s);

       <span class="hljs-comment">// 不要忘记将每朵云的网格添加到场景中</span>
       <span class="hljs-keyword">this</span>.mesh.add(c.mesh); 
   &#125;  
&#125;

<span class="hljs-comment">// 现在我们实例化天空对象，而且将它放置在屏幕中间稍微偏下的位置。</span>

<span class="hljs-keyword">var</span> sky;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSky</span>(<span class="hljs-params"></span>)</span>&#123;
   sky = <span class="hljs-keyword">new</span> Sky();
   sky.mesh.position.y = <span class="hljs-number">-600</span>;
   scene.add(sky.mesh);
&#125;</code></pre>

<h3 id="更加复杂的形状：创建飞机模型"><a href="#更加复杂的形状：创建飞机模型" class="headerlink" title="更加复杂的形状：创建飞机模型"></a>更加复杂的形状：创建飞机模型</h3><p>坏消息是：创建飞机模型的代码有点复杂有点长。但是好消息是：为了创建它我们已经学习了所有应该知道的。这里所有都是关于组合和封装形状的代码。</p>
<p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" alt="img"></p>
<pre><code class="hljs csharp"><span class="hljs-keyword">var</span> AirPlane = function() &#123;

   <span class="hljs-keyword">this</span>.mesh = <span class="hljs-keyword">new</span> THREE.Object3D();

   <span class="hljs-comment">// 创建机舱</span>
   <span class="hljs-keyword">var</span> geomCockpit = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">60</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
   <span class="hljs-keyword">var</span> matCockpit = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;
       color: Colors.red,
       shading: THREE.FlatShading
   &#125;);
   <span class="hljs-keyword">var</span> cockpit = <span class="hljs-keyword">new</span> THREE.Mesh(geomCockpit, matCockpit);
   cockpit.castShadow = <span class="hljs-literal">true</span>;
   cockpit.receiveShadow = <span class="hljs-literal">true</span>;
   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(cockpit);

   <span class="hljs-comment">// 创建引擎</span>
   <span class="hljs-keyword">var</span> geomEngine = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
   <span class="hljs-keyword">var</span> matEngine = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;
         color: Colors.white,
         shading: THREE.FlatShading
   &#125;);
   <span class="hljs-keyword">var</span> engine = <span class="hljs-keyword">new</span> THREE.Mesh(geomEngine, matEngine);
   engine.position.x = <span class="hljs-number">40</span>;
   engine.castShadow = <span class="hljs-literal">true</span>;
   engine.receiveShadow = <span class="hljs-literal">true</span>;
   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(engine);

   <span class="hljs-comment">// 创建机尾</span>
   <span class="hljs-keyword">var</span> geomTailPlane = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
   <span class="hljs-keyword">var</span> matTailPlane = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;
       color: Colors.red,
       shading: THREE.FlatShading
   &#125;);
   <span class="hljs-keyword">var</span> tailPlane = <span class="hljs-keyword">new</span> THREE.Mesh(geomTailPlane, matTailPlane);
   tailPlane.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">-35</span>, <span class="hljs-number">25</span>, <span class="hljs-number">0</span>);
   tailPlane.castShadow = <span class="hljs-literal">true</span>;
   tailPlane.receiveShadow = <span class="hljs-literal">true</span>;
   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(tailPlane);

    <span class="hljs-comment">// 创建机翼</span>
   <span class="hljs-keyword">var</span> geomSideWing = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">40</span>, <span class="hljs-number">8</span>, <span class="hljs-number">150</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
   <span class="hljs-keyword">var</span> matSideWing = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;
       color: Colors.red,
       shading: THREE.FlatShading
   &#125;);
   <span class="hljs-keyword">var</span> sideWing = <span class="hljs-keyword">new</span> THREE.Mesh(geomSideWing, matSideWing);
   sideWing.castShadow = <span class="hljs-literal">true</span>;
   sideWing.receiveShadow = <span class="hljs-literal">true</span>;
   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(sideWing);

   <span class="hljs-comment">// 创建螺旋桨</span>
   <span class="hljs-keyword">var</span> geomPropeller = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
   <span class="hljs-keyword">var</span> matPropeller = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;
       color: Colors.brown,
       shading: THREE.FlatShading
   &#125;);
   <span class="hljs-keyword">this</span>.propeller = <span class="hljs-keyword">new</span> THREE.Mesh(geomPropeller, matPropeller);
   <span class="hljs-keyword">this</span>.propeller.castShadow = <span class="hljs-literal">true</span>;
   <span class="hljs-keyword">this</span>.propeller.receiveShadow = <span class="hljs-literal">true</span>;

   <span class="hljs-comment">// 创建螺旋桨的桨叶</span>
   <span class="hljs-keyword">var</span> geomBlade = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
   <span class="hljs-keyword">var</span> matBlade = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;
       color: Colors.brownDark,
       shading: THREE.FlatShading
   &#125;);

   <span class="hljs-keyword">var</span> blade = <span class="hljs-keyword">new</span> THREE.Mesh(geomBlade, matBlade);
   blade.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
   blade.castShadow = <span class="hljs-literal">true</span>;
   blade.receiveShadow = <span class="hljs-literal">true</span>;
   <span class="hljs-keyword">this</span>.propeller.<span class="hljs-keyword">add</span>(blade);
   <span class="hljs-keyword">this</span>.propeller.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">this</span>.propeller);
&#125;;</code></pre>

<blockquote>
<p>这飞机看起来很简单吧？<br> 不要担心它现在的样子，接着我们将看到如何改进形状，让飞机更加好看!</p>
</blockquote>
<p>现在，我们可以实例化这飞机并添加到场景中：</p>
<pre><code class="hljs csharp"><span class="hljs-keyword">var</span> airplane;

<span class="hljs-function">function <span class="hljs-title">createPlane</span>(<span class="hljs-params"></span>)</span>&#123; 
   airplane = <span class="hljs-keyword">new</span> AirPlane();
   airplane.mesh.scale.<span class="hljs-keyword">set</span>(<span class="hljs-number">.25</span>,<span class="hljs-number">.25</span>,<span class="hljs-number">.25</span>);
   airplane.mesh.position.y = <span class="hljs-number">100</span>;
   scene.<span class="hljs-keyword">add</span>(airplane.mesh);
&#125;</code></pre>

<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><hr>
<p>我们已经创建了几个对象并把它们添加到我们的场景中了，但是为啥运行游戏的时候什么都看不到呢？那是因为我们需要渲染场景，添加一下这句简单的代码：</p>
<pre><code class="hljs css"><span class="hljs-selector-tag">renderer</span><span class="hljs-selector-class">.render</span>(<span class="hljs-selector-tag">scene</span>, <span class="hljs-selector-tag">camera</span>);</code></pre>

<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><hr>
<p>通过使螺旋桨旋转并转动大海和云让我们的场景更具生命力。<br> 因此我们需要一个无限循环函数</p>
<blockquote>
<p>译者注：渲染有两种类型：实时渲染和离线渲染</p>
</blockquote>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span>(<span class="hljs-params"></span>)</span>&#123;
   <span class="hljs-comment">// 使螺旋桨旋转并转动大海和云</span>
   airplane.propeller.rotation.x += <span class="hljs-number">0.3</span>;
   sea.mesh.rotation.z += <span class="hljs-number">.005</span>;
   sky.mesh.rotation.z += <span class="hljs-number">.01</span>;

   <span class="hljs-comment">// 渲染场景</span>
   renderer.render(scene, camera);

   <span class="hljs-comment">// 重新调用 render() 函数</span>
   requestAnimationFrame(loop);
&#125;</code></pre>

<p>正如你看到的一样，我们将渲染器的 render() 函数移动到 loop() 函数中。因为每次修改物体的位置或颜色之类的属性就需要重新调用一次 render() 函数。</p>
<h2 id="随着鼠标的移动，添加交互"><a href="#随着鼠标的移动，添加交互" class="headerlink" title="随着鼠标的移动，添加交互"></a>随着鼠标的移动，添加交互</h2><hr>
<p>在这刻，我们已经看见飞机在场景在中间，接下来我们还需要实现什么呢？就是监听鼠标的移动实现交互。</p>
<p>当文档加载完成，我们就需要为文档添加监听器，检测鼠标是否有移动。因此，我们需要对初始化函数作出以下的修改。</p>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params">event</span>)</span>&#123;
   createScene();
   createLights();
   createPlane();
   createSea();
   createSky();

   <span class="hljs-comment">//添加监听器</span>
   <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'mousemove'</span>, handleMouseMove, <span class="hljs-literal">false</span>);

   loop();
&#125;</code></pre>

<p>另外，我们创建一个 mousemove 事件的事件处理函数。</p>
<pre><code class="hljs csharp"><span class="hljs-keyword">var</span> mousePos=&#123;x:<span class="hljs-number">0</span>, y:<span class="hljs-number">0</span>&#125;;

<span class="hljs-comment">// mousemove 事件处理函数</span>

<span class="hljs-function">function <span class="hljs-title">handleMouseMove</span>(<span class="hljs-params"><span class="hljs-keyword">event</span></span>)</span> &#123;

   <span class="hljs-comment">// 这里我把接收到的鼠标位置的值转换成归一化值，在-1与1之间变化 </span>
   <span class="hljs-comment">// 这是x轴的公式:</span>

   <span class="hljs-keyword">var</span> tx = <span class="hljs-number">-1</span> + (<span class="hljs-keyword">event</span>.clientX / WIDTH)*<span class="hljs-number">2</span>;

   <span class="hljs-comment">// 对于 y 轴，我们需要一个逆公式</span>
   <span class="hljs-comment">// 因为 2D 的 y 轴与 3D 的 y 轴方向相反</span>

   <span class="hljs-keyword">var</span> ty = <span class="hljs-number">1</span> - (<span class="hljs-keyword">event</span>.clientY / HEIGHT)*<span class="hljs-number">2</span>;
   mousePos = &#123;x:tx, y:ty&#125;;
&#125;</code></pre>

<p>现在获得鼠标的 x , y 坐标值，我们可以适当地移动飞机。</p>
<p>我们需要修改循环函数并添加一个新功能去更新飞机的位置。</p>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span>(<span class="hljs-params"></span>)</span>&#123;
   sea.mesh.rotation.z += <span class="hljs-number">.005</span>;
   sky.mesh.rotation.z += <span class="hljs-number">.01</span>;

   <span class="hljs-comment">// 更新每帧的飞机</span>
   updatePlane();

   renderer.render(scene, camera);
   requestAnimationFrame(loop);
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatePlane</span>(<span class="hljs-params"></span>)</span>&#123;

   <span class="hljs-comment">// 让我们在x轴上-100至100之间和y轴25至175之间移动飞机</span>
   <span class="hljs-comment">// 根据鼠标的位置在-1与1之间的范围，我们使用的 normalize 函数实现（如下）</span>

   <span class="hljs-keyword">var</span> targetX = normalize(mousePos.x, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-100</span>, <span class="hljs-number">100</span>);
   <span class="hljs-keyword">var</span> targetY = normalize(mousePos.y, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">25</span>, <span class="hljs-number">175</span>);

   <span class="hljs-comment">// 更新飞机的位置</span>
   airplane.mesh.position.y = targetY;
   airplane.mesh.position.x = targetX;
   airplane.propeller.rotation.x += <span class="hljs-number">0.3</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalize</span>(<span class="hljs-params">v,vmin,vmax,tmin, tmax</span>)</span>&#123;

   <span class="hljs-keyword">var</span> nv = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.min(v,vmax), vmin);
   <span class="hljs-keyword">var</span> dv = vmax-vmin;
   <span class="hljs-keyword">var</span> pc = (nv-vmin)/dv;
   <span class="hljs-keyword">var</span> dt = tmax-tmin;
   <span class="hljs-keyword">var</span> tv = tmin + (pc*dt);
   <span class="hljs-keyword">return</span> tv;
&#125;</code></pre>

<p>恭喜你！到这里，已经实现了飞机随着鼠标的移动而移动。到目前为止，看看我们已经实现了什么功能：<a href="http://tympanus.net/Tutorials/TheAviator/part1.html" target="_blank" rel="noopener">第一部分的 Demo</a></p>
<h2 id="几乎完成！"><a href="#几乎完成！" class="headerlink" title="几乎完成！"></a>几乎完成！</h2><p>正如你所看见的，使用 Three.js 对创建 WebGL 内容有非常大的帮助。建立一个场景和渲染一些自定义对象不需要懂太多 WebGL 的知识。到目前为止，我们已经学会一些基础概念和你已经可以开始通过调整一些参数类似光源的强度，雾的颜色和物体的大小掌握了一些基本的诀窍。或许现在你已经很熟悉创建一些新的对象了。</p>
<p><em>如果你想学习更加深入的技术，请继续阅读。因为你将会学习到如何改进 3D 场景，使飞机飞行得更加平稳，并模仿低多边形海浪对大海的影响。</em></p>
<h2 id="一架更酷的飞机"><a href="#一架更酷的飞机" class="headerlink" title="一架更酷的飞机"></a>一架更酷的飞机</h2><p>好了~我们之前创建了非常基础的飞机。我们现在知道如何创建对象并组合它们，但是我们仍然需要学习如何修改几何体令其更加符合我们的需求。</p>
<p>例如正方体，可以移动它的顶点。在我们的案例中，我们需要使它更加像驾驶舱。</p>
<p>让我们看一下驾驶舱这部分的代码，还有看下我们是如何让他的背部变得更窄的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" alt="img"></p>
<pre><code class="hljs csharp"><span class="hljs-comment">// 驾驶舱</span>

<span class="hljs-keyword">var</span> geomCockpit = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">80</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);
<span class="hljs-keyword">var</span> matCockpit = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;color:Colors.red, shading:THREE.FlatShading&#125;);

<span class="hljs-comment">// 我们可以通过访问形状中顶点数组中一组特定的顶点</span>
<span class="hljs-comment">// 然后移动它的 x, y, z 属性:</span>
geomCockpit.vertices[<span class="hljs-number">4</span>].y-=<span class="hljs-number">10</span>;
geomCockpit.vertices[<span class="hljs-number">4</span>].z+=<span class="hljs-number">20</span>;
geomCockpit.vertices[<span class="hljs-number">5</span>].y-=<span class="hljs-number">10</span>;
geomCockpit.vertices[<span class="hljs-number">5</span>].z-=<span class="hljs-number">20</span>;
geomCockpit.vertices[<span class="hljs-number">6</span>].y+=<span class="hljs-number">30</span>;
geomCockpit.vertices[<span class="hljs-number">6</span>].z+=<span class="hljs-number">20</span>;
geomCockpit.vertices[<span class="hljs-number">7</span>].y+=<span class="hljs-number">30</span>;
geomCockpit.vertices[<span class="hljs-number">7</span>].z-=<span class="hljs-number">20</span>;

<span class="hljs-keyword">var</span> cockpit = <span class="hljs-keyword">new</span> THREE.Mesh(geomCockpit, matCockpit);
cockpit.castShadow = <span class="hljs-literal">true</span>;
cockpit.receiveShadow = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(cockpit);</code></pre>

<p>这就是如何操纵一个形状以适应我们的需求的一个例子。</p>
<p><em>如果你看到飞机的完整代码，你会看到几个对象：更像窗口的对象和更美观的螺旋桨。没有什么复杂的东西，试着调整相关的值找找感觉，制造属于你自己的飞机。</em></p>
<h2 id="但是，是谁在开飞机呢？"><a href="#但是，是谁在开飞机呢？" class="headerlink" title="但是，是谁在开飞机呢？"></a>但是，是谁在开飞机呢？</h2><hr>
<p>为我们的飞机添加一个飞行员，就好像添加几个盒子一样容易。</p>
<p>但是我们只需要一个酷酷的飞行员，头发要很飘逸的！感觉它好像很难实现的样子，但是由于我们开始的时候是在低多边形的场景下开始的，所以这就变得简单多了！尝试通过几个盒子模拟创建飘逸的头发，同时会给予一种独特的感觉。</p>
<p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" alt="img"></p>
<p>让我们看看源码：</p>
<pre><code class="hljs csharp"><span class="hljs-keyword">var</span> Pilot = function()&#123;
   <span class="hljs-keyword">this</span>.mesh = <span class="hljs-keyword">new</span> THREE.Object3D();
   <span class="hljs-keyword">this</span>.mesh.name = <span class="hljs-string">"pilot"</span>;

   <span class="hljs-comment">// angleHairs是用于后面头发的动画的属性 </span>
   <span class="hljs-keyword">this</span>.angleHairs=<span class="hljs-number">0</span>;

   <span class="hljs-comment">// 飞行员的身体</span>
   <span class="hljs-keyword">var</span> bodyGeom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>);
   <span class="hljs-keyword">var</span> bodyMat = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;color:Colors.brown, shading:THREE.FlatShading&#125;);
   <span class="hljs-keyword">var</span> body = <span class="hljs-keyword">new</span> THREE.Mesh(bodyGeom, bodyMat);
   body.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">2</span>,<span class="hljs-number">-12</span>,<span class="hljs-number">0</span>);
   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(body);

   <span class="hljs-comment">// 飞行员的脸部</span>
   <span class="hljs-keyword">var</span> faceGeom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);
   <span class="hljs-keyword">var</span> faceMat = <span class="hljs-keyword">new</span> THREE.MeshLambertMaterial(&#123;color:Colors.pink&#125;);
   <span class="hljs-keyword">var</span> face = <span class="hljs-keyword">new</span> THREE.Mesh(faceGeom, faceMat);
   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(face);

   <span class="hljs-comment">// 飞行员的头发</span>
   <span class="hljs-keyword">var</span> hairGeom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>);
   <span class="hljs-keyword">var</span> hairMat = <span class="hljs-keyword">new</span> THREE.MeshLambertMaterial(&#123;color:Colors.brown&#125;);
   <span class="hljs-keyword">var</span> hair = <span class="hljs-keyword">new</span> THREE.Mesh(hairGeom, hairMat);
   <span class="hljs-comment">// 调整头发的形状至底部的边界，这将使它更容易扩展。</span>
   hair.geometry.applyMatrix(<span class="hljs-keyword">new</span> THREE.Matrix4().makeTranslation(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>));

   <span class="hljs-comment">// 创建一个头发的容器</span>
   <span class="hljs-keyword">var</span> hairs = <span class="hljs-keyword">new</span> THREE.Object3D();

   <span class="hljs-comment">// 创建一个头发顶部的容器（这会有动画效果）</span>
   <span class="hljs-keyword">this</span>.hairsTop = <span class="hljs-keyword">new</span> THREE.Object3D();

   <span class="hljs-comment">// 创建头顶的头发并放置他们在一个3*4的网格中</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">12</span>; i++)&#123;
       <span class="hljs-keyword">var</span> h = hair.clone();
       <span class="hljs-keyword">var</span> col = i%<span class="hljs-number">3</span>;
       <span class="hljs-keyword">var</span> row = Math.floor(i/<span class="hljs-number">3</span>);
       <span class="hljs-keyword">var</span> startPosZ = <span class="hljs-number">-4</span>;
       <span class="hljs-keyword">var</span> startPosX = <span class="hljs-number">-4</span>;
       h.position.<span class="hljs-keyword">set</span>(startPosX + row*<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, startPosZ + col*<span class="hljs-number">4</span>);
       <span class="hljs-keyword">this</span>.hairsTop.<span class="hljs-keyword">add</span>(h);
   &#125;
   hairs.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">this</span>.hairsTop);

   <span class="hljs-comment">// 创建脸庞的头发</span>
   <span class="hljs-keyword">var</span> hairSideGeom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">12</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>);
   hairSideGeom.applyMatrix(<span class="hljs-keyword">new</span> THREE.Matrix4().makeTranslation(<span class="hljs-number">-6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));
   <span class="hljs-keyword">var</span> hairSideR = <span class="hljs-keyword">new</span> THREE.Mesh(hairSideGeom, hairMat);
   <span class="hljs-keyword">var</span> hairSideL = hairSideR.clone();
   hairSideR.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">8</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">6</span>);
   hairSideL.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">8</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-6</span>);
   hairs.<span class="hljs-keyword">add</span>(hairSideR);
   hairs.<span class="hljs-keyword">add</span>(hairSideL);

   <span class="hljs-comment">// 创建后脑勺的头发</span>
   <span class="hljs-keyword">var</span> hairBackGeom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>);
   <span class="hljs-keyword">var</span> hairBack = <span class="hljs-keyword">new</span> THREE.Mesh(hairBackGeom, hairMat);
   hairBack.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">-1</span>,<span class="hljs-number">-4</span>,<span class="hljs-number">0</span>)
   hairs.<span class="hljs-keyword">add</span>(hairBack);
   hairs.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>);

   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(hairs);

   <span class="hljs-keyword">var</span> glassGeom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>);
   <span class="hljs-keyword">var</span> glassMat = <span class="hljs-keyword">new</span> THREE.MeshLambertMaterial(&#123;color:Colors.brown&#125;);
   <span class="hljs-keyword">var</span> glassR = <span class="hljs-keyword">new</span> THREE.Mesh(glassGeom,glassMat);
   glassR.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);
   <span class="hljs-keyword">var</span> glassL = glassR.clone();
   glassL.position.z = -glassR.position.z;

   <span class="hljs-keyword">var</span> glassAGeom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">11</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>);
   <span class="hljs-keyword">var</span> glassA = <span class="hljs-keyword">new</span> THREE.Mesh(glassAGeom, glassMat);
   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(glassR);
   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(glassL);
   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(glassA);

   <span class="hljs-keyword">var</span> earGeom = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);
   <span class="hljs-keyword">var</span> earL = <span class="hljs-keyword">new</span> THREE.Mesh(earGeom,faceMat);
   earL.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-6</span>);
   <span class="hljs-keyword">var</span> earR = earL.clone();
   earR.position.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);
   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(earL);
   <span class="hljs-keyword">this</span>.mesh.<span class="hljs-keyword">add</span>(earR);
 &#125;

<span class="hljs-comment">// 移动头发</span>
Pilot.prototype.updateHairs = function()&#123;

   <span class="hljs-comment">// 获得头发</span>
   <span class="hljs-keyword">var</span> hairs = <span class="hljs-keyword">this</span>.hairsTop.children;

   <span class="hljs-comment">// 根据 angleHairs 的角度更新头发</span>
   <span class="hljs-keyword">var</span> l = hairs.length;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;l; i++)&#123;
       <span class="hljs-keyword">var</span> h = hairs[i];
       <span class="hljs-comment">// 每根头发将周期性的基础上原始大小的75%至100%之间作调整。</span>
       h.scale.y = <span class="hljs-number">.75</span> + Math.cos(<span class="hljs-keyword">this</span>.angleHairs+i/<span class="hljs-number">3</span>)*<span class="hljs-number">.25</span>;
   &#125;
   <span class="hljs-comment">// 在下一帧增加角度</span>
   <span class="hljs-keyword">this</span>.angleHairs += <span class="hljs-number">0.16</span>;
&#125;</code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" alt="img"></p>
<p>现在让头发动起来，只需要在循环函数里添加以下这句代码。</p>
<pre><code class="hljs css"><span class="hljs-selector-tag">airplane</span><span class="hljs-selector-class">.pilot</span><span class="hljs-selector-class">.updateHairs</span>();</code></pre>

<h2 id="制作海浪"><a href="#制作海浪" class="headerlink" title="制作海浪"></a>制作海浪</h2><hr>
<p>或许你已经注意到这大海不像真的大海那样，但更像被压路机压平的表面。</p>
<p>它需要一些海浪。这需要结合我们之前用到的两项技术来完成：</p>
<ul>
<li><p>操纵几何体的顶点就像我们处理飞机的驾驶舱那样</p>
</li>
<li><p>每个顶点执行循环移动就像我们移动飞行员的头发一样</p>
<p>为了制造海浪，我们将围绕圆柱体的初始位置对每个顶点旋转。通过给它们一个随机旋转速度和一个随机距离（旋转半径）。很抱歉，这里还是需要用到一些三角函数！</p>
<p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" alt="img"></p>
</li>
</ul>
<p>让我们对大海作出一些修改：</p>
<pre><code class="hljs jsx">Sea = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
   <span class="hljs-keyword">var</span> geom = <span class="hljs-keyword">new</span> THREE.CylinderGeometry(<span class="hljs-number">600</span>,<span class="hljs-number">600</span>,<span class="hljs-number">800</span>,<span class="hljs-number">40</span>,<span class="hljs-number">10</span>);
   geom.applyMatrix(<span class="hljs-keyword">new</span> THREE.Matrix4().makeRotationX(-<span class="hljs-built_in">Math</span>.PI/<span class="hljs-number">2</span>));

   <span class="hljs-comment">// 重点：通过合并顶点，我们确保海浪的连续性</span>
   geom.mergeVertices();

   <span class="hljs-comment">// 获得顶点</span>
   <span class="hljs-keyword">var</span> l = geom.vertices.length;

   <span class="hljs-comment">// 创建一个新的数组存储与每个顶点关联的值：</span>
   <span class="hljs-keyword">this</span>.waves = [];

   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;l; i++)&#123;
       <span class="hljs-comment">// 获取每个顶点</span>
       <span class="hljs-keyword">var</span> v = geom.vertices[i];

       <span class="hljs-comment">// 存储一些关联的数值</span>
       <span class="hljs-keyword">this</span>.waves.push(&#123;<span class="hljs-attr">y</span>:v.y,
                        <span class="hljs-attr">x</span>:v.x,
                        <span class="hljs-attr">z</span>:v.z,
                        <span class="hljs-comment">// 随机角度</span>
                        <span class="hljs-attr">ang</span>:<span class="hljs-built_in">Math</span>.random()*<span class="hljs-built_in">Math</span>.PI*<span class="hljs-number">2</span>,
                        <span class="hljs-comment">// 随机距离</span>
                        <span class="hljs-attr">amp</span>:<span class="hljs-number">5</span> + <span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">15</span>,
                        <span class="hljs-comment">// 在0.016至0.048度/帧之间的随机速度</span>
                        <span class="hljs-attr">speed</span>:<span class="hljs-number">0.016</span> + <span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">0.032</span>
       &#125;);
   &#125;;
   <span class="hljs-keyword">var</span> mat = <span class="hljs-keyword">new</span> THREE.MeshPhongMaterial(&#123;
       <span class="hljs-attr">color</span>:Colors.blue,
       <span class="hljs-attr">transparent</span>:<span class="hljs-literal">true</span>,
       <span class="hljs-attr">opacity</span>:<span class="hljs-number">.8</span>,
       <span class="hljs-attr">shading</span>:THREE.FlatShading,
   &#125;);

   <span class="hljs-keyword">this</span>.mesh = <span class="hljs-keyword">new</span> THREE.Mesh(geom, mat);
   <span class="hljs-keyword">this</span>.mesh.receiveShadow = <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-comment">// 现在我们创建一个在每帧可以调用的函数，用于更新顶点的位置来模拟海浪。</span>

Sea.prototype.moveWaves = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;

   <span class="hljs-comment">// 获取顶点</span>
   <span class="hljs-keyword">var</span> verts = <span class="hljs-keyword">this</span>.mesh.geometry.vertices;
   <span class="hljs-keyword">var</span> l = verts.length;

   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;l; i++)&#123;
       <span class="hljs-keyword">var</span> v = verts[i];

       <span class="hljs-comment">// 获取关联的值</span>
       <span class="hljs-keyword">var</span> vprops = <span class="hljs-keyword">this</span>.waves[i];

       <span class="hljs-comment">// 更新顶点的位置</span>
       v.x = vprops.x + <span class="hljs-built_in">Math</span>.cos(vprops.ang)*vprops.amp;
       v.y = vprops.y + <span class="hljs-built_in">Math</span>.sin(vprops.ang)*vprops.amp;

       <span class="hljs-comment">// 下一帧自增一个角度</span>
       vprops.ang += vprops.speed;
   &#125;

   <span class="hljs-comment">// 告诉渲染器代表大海的几何体发生改变</span>
   <span class="hljs-comment">// 事实上，为了维持最好的性能</span>
   <span class="hljs-comment">// Three.js 会缓存几何体和忽略一些修改</span>
   <span class="hljs-comment">// 除非加上这句</span>
   <span class="hljs-keyword">this</span>.mesh.geometry.verticesNeedUpdate=<span class="hljs-literal">true</span>;

   sea.mesh.rotation.z += <span class="hljs-number">.005</span>;
&#125;</code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" alt="img"></p>
<p>就好像我们对飞行员的头发做的那样，我们在循环函数中添加以下这句代码：</p>
<pre><code class="hljs css"><span class="hljs-selector-tag">sea</span><span class="hljs-selector-class">.moveWaves</span>();</code></pre>

<p>现在好好欣赏海浪吧！</p>
<h2 id="改善场景中的光源"><a href="#改善场景中的光源" class="headerlink" title="改善场景中的光源"></a>改善场景中的光源</h2><hr>
<p>在教程中的第一部分，我们已经创建了一些光源。但是想为场景添加更好的气氛，并使阴影更加柔和。为了实现它，我们打算使用环境光源。</p>
<p>在 createLight 函数中，我们添加以下几行代码：</p>
<pre><code class="hljs csharp"><span class="hljs-comment">// 环境光源修改场景中的全局颜色和使阴影更加柔和</span>
ambientLight = <span class="hljs-keyword">new</span> THREE.AmbientLight(<span class="hljs-number">0xdc8874</span>, <span class="hljs-number">.5</span>);scene.<span class="hljs-keyword">add</span>(ambientLight);</code></pre>

<p>别再犹豫了！调节环境光源的颜色和强度，它会为你的场景增添独特的润色。</p>
<h2 id="一次平稳的飞行"><a href="#一次平稳的飞行" class="headerlink" title="一次平稳的飞行"></a>一次平稳的飞行</h2><hr>
<p>我们的小小飞机已经随着我们的鼠标移动。但它总感觉不像真正的飞行。当飞机改变它的飞行高度，如何改变它的位置和方向时更加流畅就完美了。在教程的最后一点，我们将实现它。</p>
<p>一个简单的方法就是让它移动到目标位置，通过添加一点点距离让它在每一帧与目标位置分离。</p>
<p>基本上，相关的代码会这样（这是一个通用的公式，不要马上添加到你的代码中）：</p>
<pre><code class="hljs undefined">currentPosition +&#x3D; (finalPosition - currentPosition)*fraction;</code></pre>

<p>更现实点来说，飞机旋转也可以根据运动的方向。如果飞机很快的向上移动，它应该很快地沿着逆时针方向旋转；如果飞机慢慢向下移动，它应该慢慢地沿着顺时针方向旋转；为了准确地实现它，我们应该把旋转比例值简单地分配给在目标和飞机位置之间的剩余距离。</p>
<p>在我们的代码里，updatePlane 函数需要像以下这样：</p>
<pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatePlane</span>(<span class="hljs-params"></span>)</span>&#123;
   <span class="hljs-keyword">var</span> targetY = normalize(mousePos.y,<span class="hljs-number">-.75</span>,<span class="hljs-number">.75</span>,<span class="hljs-number">25</span>, <span class="hljs-number">175</span>);
   <span class="hljs-keyword">var</span> targetX = normalize(mousePos.x,<span class="hljs-number">-.75</span>,<span class="hljs-number">.75</span>,<span class="hljs-number">-100</span>, <span class="hljs-number">100</span>);

   <span class="hljs-comment">// 在每帧通过添加剩余距离的一小部分的值移动飞机</span>
   airplane.mesh.position.y += (targetY-airplane.mesh.position.y)*<span class="hljs-number">0.1</span>;

   <span class="hljs-comment">// 剩余的距离按比例转动飞机</span>
   airplane.mesh.rotation.z = (targetY-airplane.mesh.position.y)*<span class="hljs-number">0.0128</span>;
   airplane.mesh.rotation.x = (airplane.mesh.position.y-targetY)*<span class="hljs-number">0.0064</span>;

   airplane.propeller.rotation.x += <span class="hljs-number">0.3</span>;
&#125;</code></pre>

<p>现在飞机的移动看起来更加自然和真实。通过修改一下小数值，你可以使用飞机随着鼠标的移动响应速度更加快或更加慢。</p>
<p>看下我们场景中的最后一个阶段：<a href="http://tympanus.net/Tutorials/TheAviator/part2.html" target="_blank" rel="noopener">第二部分 Demo</a></p>
<p>很好！！！</p>
<h2 id="接着要干嘛呢？"><a href="#接着要干嘛呢？" class="headerlink" title="接着要干嘛呢？"></a>接着要干嘛呢？</h2><hr>
<p>如果你看到这，你已经学会 Three.js 中的通用的一些技术了，能够让你创建您的第一个场景。现在你知道如何通过原始几何体创建物体，如何激活它们，以及如何设置一个场景中的光源，你已经知道如何改进你的对象的外观和运动，还有如何调整环境氛围。</p>
<p>下一步已经超出本文范围了，由于它涉及到更多复杂的技术，它是实现一个<a href="http://tympanus.net/Tutorials/TheAviator/" target="_blank" rel="noopener">游戏</a>，大概思路是碰撞，收集点数，液位控制。下载源码，看看实现的思路；你会看到到目前为止你学到过的概念和一些高阶的知识点，你可以研究一下和玩一下。请注意这游戏已经优化了以便桌面使用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/DogeLasVegas/image-source/2020/2020-01/99%E4%B9%98%E6%B3%95%E8%A1%A8.png" srcset="/img/loading.gif" alt="img"></p>
<p>但愿，这篇教程帮助你熟悉Three.js和激发你实现属于你自己的项目。让我看到你的创造力；我希望看到你做出什么来~</p>
<p><a href="http://tympanus.net/Tutorials/TheAviator/" target="_blank" rel="noopener">DEMO</a>   <a href="http://tympanus.net/Tutorials/TheAviator/TheAviator.zip" target="_blank" rel="noopener">源码下载</a></p>
<p><strong>本文转自</strong> <a href="https://www.jianshu.com/p/92771817c73f" target="_blank" rel="noopener">译文：一个采用 Three.js 的 3D 动画场景制作：飞行者</a>，作者：LeeChingYin</p>
<p><strong>英文原文链接：</strong><a href="https://tympanus.net/codrops/2016/04/26/the-aviator-animating-basic-3d-scene-threejs/" target="_blank" rel="noopener">The Making of “The Aviator”: Animating a Basic 3D Scene with Three.js</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/HTML/">HTML</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JS/">JS</a>
                    
                      <a class="hover-with-bg" href="/tags/Web/">Web</a>
                    
                      <a class="hover-with-bg" href="/tags/Three-js/">Three.js</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/04/get-url-id/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">获取URL地址最后的id值</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/03/gufeng/">
                        <span class="hidden-mobile">【转】恶俗古风自动生成器</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81MDkyMy8yNzQwNQ==">
    <script type="text/javascript">
      function loadLivere() {
        addScript('https://cdn-city.livere.com/js/embed.dist.js');
      }
      createObserver(loadLivere, 'lv-container');
    </script>
    <noscript>为正常使用来必力评论功能请允许 JavaScript 运行</noscript>
  </div>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    
      <script  src="/js/lazyload.js" ></script>
    
  





  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "【转】利用Three.js制作一个3D动画飞行场景&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":250,"height":500,"position":"left","hOffset":-30,"vOffset":-100},"mobile":{"show":false,"scale":0.5},"react":{"opacity":0.8},"dialog":{"enable":true,"hitokoto":true},"log":false});</script></body>
</html>
